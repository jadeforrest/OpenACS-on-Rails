--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;

--
-- Name: plpgsql; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: -
--

CREATE PROCEDURAL LANGUAGE plpgsql;


SET search_path = public, pg_catalog;

--
-- Name: __exec_100_unused(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_100_unused() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
        begin return membership_rel__deleted('31627'); end;
      
                      $$;


--
-- Name: __exec_101_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_101_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'happy go lucky pic of me,always make a funny face in pics,i like to pose for the camera',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '31675',
                                       null,
                                       now(),
                                       '31673',
                                       '205.188.116.135'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '31675';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_32_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_32_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '5610',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '5610',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_33_unused(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_33_unused() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
        begin return membership_rel__deleted('5664'); end;
      
                      $$;


--
-- Name: __exec_34_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_34_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       null,
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '5767',
                                       null,
                                       now(),
                                       '5764',
                                       '12.215.38.90'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '5767';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_35_ban(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_35_ban() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
            begin return membership_rel__ban('5791'); end;
        
                      $$;


--
-- Name: __exec_36_ban(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_36_ban() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
            begin return membership_rel__ban('5789'); end;
        
                      $$;


--
-- Name: __exec_37_ban(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_37_ban() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
            begin return membership_rel__ban('5787'); end;
        
                      $$;


--
-- Name: __exec_38_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_38_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '5801',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '5801',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_39_unset_live_revisions(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_39_unset_live_revisions() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

	begin
	  PERFORM content_item__unset_live_revision('5801');
	  return 0;
        end;
    
      
                      $$;


--
-- Name: __exec_40_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_40_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'I had an acting/modeling competition in New York and well, this is my mugshot... I mean... headshot ;P',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '6145',
                                       null,
                                       now(),
                                       '6143',
                                       '66.199.83.78'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '6145';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_41_delete(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_41_delete() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
            begin return membership_rel__deleted('6510'); end;
        
                      $$;


--
-- Name: __exec_42_relation_delete(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_42_relation_delete() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
      begin perform membership_rel__delete('4030'); return null; end;
      
                      $$;


--
-- Name: __exec_43_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_43_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '6591',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '6591',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_44_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_44_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'Well this is me this one is taken for my friend class that take photography class and I am the model LOL, funny when I think back why I want to do this.',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '6719',
                                       null,
                                       now(),
                                       '6717',
                                       '68.12.125.253'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '6719';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_45_unused(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_45_unused() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
        begin return membership_rel__deleted('6723'); end;
      
                      $$;


--
-- Name: __exec_46_relation_delete(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_46_relation_delete() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
      begin perform membership_rel__delete('6733'); return null; end;
      
                      $$;


--
-- Name: __exec_47_relation_delete(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_47_relation_delete() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
      begin perform membership_rel__delete('2702'); return null; end;
      
                      $$;


--
-- Name: __exec_48_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_48_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '6765',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '6765',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_49_insert_comment(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_49_insert_comment() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
    declare 
		v_revision_id integer;
    begin
        select acs_message__edit (
            /* message_id    => */ '6765',
            /* title         => */ 'More details on the conference',
	    /* p_description    */ NULL, 
            /* mime_type     => */ 'text/html',
	    /* text	        */ NULL,
            /* data          => */ NULL, 	-- was empty_blob(),
	    /* creation_date    */ now(),
            /* creation_user => */ '2539',
            /* creation_ip   => */ '63.225.87.43',
            /* is_live       => */ 't'
        ) into v_revision_id;

	return v_revision_id;
    end;
  
      
                      $$;


--
-- Name: __exec_50_unset_live_revisions(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_50_unset_live_revisions() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

	begin
	  PERFORM content_item__unset_live_revision('6765');
	  return 0;
        end;
    
      
                      $$;


--
-- Name: __exec_51_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_51_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '9982',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '9982',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_52_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_52_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '10212',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '10212',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_53_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_53_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'America''s most authentic Chinese Classical garden is in my Portland neighborhood.    A barefoot walk on its river stone courtyards provides a soothing foot massage and the beauty of the place brings great peace.  ',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '10373',
                                       null,
                                       now(),
                                       '10371',
                                       '12.224.66.53'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '10373';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_54_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_54_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '10379',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '10379',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_55_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_55_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '10883',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '10883',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_56_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_56_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '10904',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '10904',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_57_delete_comment(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_57_delete_comment() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

    begin
        PERFORM acs_message__delete('6765');
	return 1;
    end;

      
                      $$;


--
-- Name: __exec_58_delete_comment(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_58_delete_comment() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

    begin
        PERFORM acs_message__delete('5801');
	return 1;
    end;

      
                      $$;


--
-- Name: __exec_59_unused(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_59_unused() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
        begin return membership_rel__deleted('5669'); end;
      
                      $$;


--
-- Name: __exec_60_unused(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_60_unused() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
        begin return membership_rel__deleted('12403'); end;
      
                      $$;


--
-- Name: __exec_61_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_61_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '13114',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '13114',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_62_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_62_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '13325',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '13325',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_63_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_63_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       null,
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '13525',
                                       null,
                                       now(),
                                       '13522',
                                       '199.179.239.145'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '13525';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_64_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_64_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'Yep, that''s my goofy mug. ;-)',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '13563',
                                       null,
                                       now(),
                                       '13561',
                                       '4.62.186.202'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '13563';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_65_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_65_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'Ive lost 45 lbs and going down.  My wife says Im fat, disgusting ugly because even my soul is ugly. I believed it for a while which is why I got to 265 lbs.  But, I dont know what to do.  What do you think.',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '13756',
                                       null,
                                       now(),
                                       '13754',
                                       '12.80.22.163'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '13756';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_66_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_66_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       null,
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '14270',
                                       null,
                                       now(),
                                       '5819',
                                       '81.64.119.181'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '14270';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_67_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_67_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'This was taken by my fiance just after our daughter, Danielle, was born on Nov. 11, 2003.  ',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '15247',
                                       null,
                                       now(),
                                       '15245',
                                       '65.130.38.126'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '15247';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_68_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_68_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '16194',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '16194',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_69_unused(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_69_unused() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
        begin return membership_rel__deleted('16439'); end;
      
                      $$;


--
-- Name: __exec_70_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_70_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '16545',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '16545',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_71_insert_comment(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_71_insert_comment() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
    declare 
		v_revision_id integer;
    begin
        select acs_message__edit (
            /* message_id    => */ '16545',
            /* title         => */ 'Link to story',
	    /* p_description    */ NULL, 
            /* mime_type     => */ 'text/html',
	    /* text	        */ NULL,
            /* data          => */ NULL, 	-- was empty_blob(),
	    /* creation_date    */ now(),
            /* creation_user => */ '2539',
            /* creation_ip   => */ '63.225.85.168',
            /* is_live       => */ 't'
        ) into v_revision_id;

	return v_revision_id;
    end;
  
      
                      $$;


--
-- Name: __exec_72_insert_comment(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_72_insert_comment() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
    declare 
		v_revision_id integer;
    begin
        select acs_message__edit (
            /* message_id    => */ '6591',
            /* title         => */ 'Original link to article',
	    /* p_description    */ NULL, 
            /* mime_type     => */ 'text/html',
	    /* text	        */ NULL,
            /* data          => */ NULL, 	-- was empty_blob(),
	    /* creation_date    */ now(),
            /* creation_user => */ '2539',
            /* creation_ip   => */ '63.225.85.168',
            /* is_live       => */ 't'
        ) into v_revision_id;

	return v_revision_id;
    end;
  
      
                      $$;


--
-- Name: __exec_73_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_73_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '17511',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '17511',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_74_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_74_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '17708',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '17708',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_75_insert_comment(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_75_insert_comment() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
    declare 
	v_extlink_id cr_extlinks.extlink_id%TYPE;
	
    begin
	select content_extlink__new (
                /* name            => */ 'extlink_17710',
                /* url             => */ 'http://www.americandaily.com/item/3912',
                /* label           => */ 'Ask Before You Give',
		/* description        */ NULL,
                /* parent_id       => */ '17708',
                /* extlink_id      => */ '17710',
		/* creation_date      */ now(),
                /* creation_user   => */ '2539',
                /* creation_ip     => */ '63.225.85.168'
         ) into v_extlink_id;

	return v_extlink_id;
    end;

      
                      $$;


--
-- Name: __exec_76_relation_delete(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_76_relation_delete() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
      begin perform membership_rel__delete('3268'); return null; end;
      
                      $$;


--
-- Name: __exec_77_ban(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_77_ban() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
            begin return membership_rel__ban('20903'); end;
        
                      $$;


--
-- Name: __exec_78_ban(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_78_ban() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
            begin return membership_rel__ban('3085'); end;
        
                      $$;


--
-- Name: __exec_79_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_79_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '21010',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '21010',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_80_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_80_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'Well, this is a lil bad pic, but this is the only one and my group one that i did close to today. but yea, their be another , so better yet next tiem!',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '21175',
                                       null,
                                       now(),
                                       '19818',
                                       '68.73.203.133'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '21175';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_81_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_81_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '21775',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '21775',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_82_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_82_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '22217',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '22217',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_83_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_83_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'Santa Cruz CA: Local Father falsely prosecuted for "child abuse" for removing teenager from his office during custody pleadings preparation. 
   The County Sheriffs Conducted an illicit custody transfer to a mentally disturbed narcotics addict in Monterey County CA who was evading $20,000 in child support, after the psychotic Mother enticed teenager to assault custodial Father. Parental Alienation.  
    Seeking Attorney for malpractice, civil rights violations, evidence tampering,
conspiracy, perjury, collusion, deceit. 
    Similar cases e-me',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '24606',
                                       null,
                                       now(),
                                       '24604',
                                       '68.126.183.228'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '24606';

  return v_revision_id;

  end;

        
                      $_$;


--
-- Name: __exec_84_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_84_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'Hula, the dog in the photo was a stray that an associate of mine found and we are both working with Hula to socialize her. The associate of mine has a non-profit called "Autisim Service Dogs of America" and the organization''s mission is to provide assistance dogs for Autistic children.  These days, I seem to find myself involved with several non-profits, including the Red Cross. ',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '24666',
                                       null,
                                       now(),
                                       '2669',
                                       '67.75.230.227'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '24666';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_85_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_85_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '24952',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '24952',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_86_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_86_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '24954',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '24954',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_87_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_87_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'Late night webwork',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '25235',
                                       null,
                                       now(),
                                       '25233',
                                       '62.255.32.4'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '25235';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_88_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_88_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       null,
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '25792',
                                       null,
                                       now(),
                                       '25790',
                                       '24.64.223.204'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '25792';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_89_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_89_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '25800',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '25800',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_90_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_90_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'My son and I at the Mn State Fair summer of 2003.
We have a super great relationship. I love being a Dad and Father for my son.',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '25804',
                                       null,
                                       now(),
                                       '25802',
                                       '66.41.116.205'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '25804';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_91_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_91_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '26490',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '26490',
                /* grantee_id => */ '2539',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_92_insert_comment(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_92_insert_comment() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
    declare 
		v_revision_id integer;
    begin
        select acs_message__edit (
            /* message_id    => */ '26490',
            /* title         => */ 'Link to SAFE Place',
	    /* p_description    */ NULL, 
            /* mime_type     => */ 'text/html',
	    /* text	        */ NULL,
            /* data          => */ NULL, 	-- was empty_blob(),
	    /* creation_date    */ now(),
            /* creation_user => */ '2539',
            /* creation_ip   => */ '63.225.85.9',
            /* is_live       => */ 't'
        ) into v_revision_id;

	return v_revision_id;
    end;
  
      
                      $$;


--
-- Name: __exec_93_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_93_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       null,
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '26579',
                                       null,
                                       now(),
                                       '26577',
                                       '216.193.162.22'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '26579';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_94_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_94_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '26587',
                /* grantee_id => */ '26577',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '26587',
                /* grantee_id => */ '26577',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __exec_95_ban(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_95_ban() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
            begin return membership_rel__ban('27980'); end;
        
                      $$;


--
-- Name: __exec_96_unused(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_96_unused() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      
        begin return membership_rel__deleted('30729'); end;
      
                      $$;


--
-- Name: __exec_97_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_97_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       'This pic was taken on Fat Tuesday end of Feb.2004 during the "Separation". Can''t you all see how HAPPY I look here. A month or so later...he sweet talked me and swindled his way back in the door.  Now I''m lucky to get out of bed each day due to depression.  Somewhere inside of me I KNOW theres a VIVACIOUS HAPPY SOULFUL WOMAN DYING TO COME OUT AGAIN.  I just feel like I can''t overcome his strength.',
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '30767',
                                       null,
                                       now(),
                                       '30765',
                                       '12.74.157.123'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '30767';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_98_create_revision(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_98_create_revision() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

  declare
        v_revision_id      integer;
  begin

  v_revision_id := content_revision__new(
                                       null,
                                       null,
                                       now(),
                                       'image/jpeg',
                                       null,
                                       null,
                                       '30953',
                                       null,
                                       now(),
                                       '30899',
                                       '68.155.196.158'
                                       );

  update cr_items
  set live_revision = v_revision_id
  where item_id = '30953';

  return v_revision_id;

  end;

        
                      $$;


--
-- Name: __exec_99_grant_permission(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __exec_99_grant_permission() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
                      

        begin
            perform acs_permission__grant_permission (
                /* object_id  => */ '31614',
                /* grantee_id => */ '31463',
                /* privilege  => */ 'read'
            );
            perform acs_permission__grant_permission (
                /* object_id  => */ '31614',
                /* grantee_id => */ '31463',
                /* privilege  => */ 'write'
            );
	    return 0;
        end;
	
    
      
                      $$;


--
-- Name: __workflow__simple_p(character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION __workflow__simple_p(character varying, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  simple_p__workflow_key           alias for $1;  
  v_session_id                     alias for $2;
  -- previous_place_list              t_place_table; 
  -- target_place_list                t_place_table; 
  -- guard_list                       t_guard_table; 
  guard_list_1                     varchar;
  guard_list_2                     varchar;
  target_place_list_1              varchar;
  target_place_list_2              varchar;
  previous_place_list_i            varchar;
  v_row_count                      integer default 0;       
  v_count                          integer;       
  v_count2                         integer;       
  v_place_key                      wf_places.place_key%TYPE;
  v_end_place                      wf_places.place_key%TYPE;
  v_transition_key                 wf_transitions.transition_key%TYPE;
  v_rownum                         integer;
  v_target                         record;
begin

        /* Let us do some simple checks first */

        /* Places with more than one arc out */
        select count(*) into v_count
        from   wf_places p
        where  p.workflow_key = simple_p__workflow_key
        and    1 < (select count(*) 
                    from   wf_arcs a
                    where  a.workflow_key = p.workflow_key
                    and    a.place_key = p.place_key
                    and    direction = 'in');
        raise notice 'query 1';
        if v_count > 0 then
            return 'f';
        end if;

        /* Transitions with more than one arc in */
        select count(*) into v_count
        from   wf_transitions t
        where  t.workflow_key = simple_p__workflow_key
        and    1 < (select count(*)
                    from   wf_arcs a
                    where  a.workflow_key = t.workflow_key
                    and    a.transition_key = t.transition_key
                    and    direction = 'in');

        raise notice 'query 2';
        if v_count > 0 then
            return 'f';
        end if;

        /* Transitions with more than two arcs out */
        select count(*) into v_count
        from   wf_transitions t
        where  t.workflow_key = simple_p__workflow_key
        and    2 < (select count(*)
                    from   wf_arcs a
                    where  a.workflow_key = t.workflow_key
                    and    a.transition_key = t.transition_key
                    and    direction = 'out');

        raise notice 'query 3';
        if v_count > 0 then
            return 'f';
        end if;

        /* Now we do the more complicated checks.
         * We keep a list of visited places because I could not think
         * of a nicer way that was not susceptable to infinite loops.
         */


        v_place_key := 'start';
        v_end_place := 'end';

        loop
            exit when v_place_key = v_end_place;

            -- previous_place_list(v_row_count) := v_place_key;
            insert into previous_place_list 
            (session_id,rcnt,ky) 
            values 
            (v_session_id,v_row_count,v_place_key);
        raise notice 'query 4';

            select distinct transition_key into v_transition_key
            from   wf_arcs
            where  workflow_key = simple_p__workflow_key
            and    place_key = v_place_key
            and    direction = 'in';
        raise notice 'query 5';

            select count(*) into v_count
            from wf_arcs
            where workflow_key = simple_p__workflow_key
            and   transition_key = v_transition_key
            and   direction = 'out';
        raise notice 'query 6';

            if v_count = 1 then
                select distinct place_key into v_place_key
                from wf_arcs
                where workflow_key = simple_p__workflow_key
                and   transition_key = v_transition_key
                and   direction = 'out';
        raise notice 'query 7';

            else if v_count = 0 then
                /* deadend! */
                return 'f';

            else
                /* better be two based on our earlier test */

                v_rownum := 1;
                for v_target in 
                select place_key,guard_callback
                from   wf_arcs
                where  workflow_key = simple_p__workflow_key
                and    transition_key = v_transition_key
                and    direction = 'out'
                LOOP
                    -- target_place_list(v_target.rownum) := v_target.place_key;
        raise notice 'query 8';
                    insert into target_place_list 
                    (session_id,rcnt,ky) 
                    values 
                    (v_session_id,v_rownum,v_target.place_key);
        raise notice 'query 9';

                    -- guard_list(v_target.rownum) := v_target.guard_callback; 
                    insert into guard_list 
                    (session_id,rcnt,ky) 
                    values 
                    (v_session_id,v_rownum,v_target.guard_callback);
                    v_rownum := v_rownum + 1;
        raise notice 'query 10';
                end loop;
    
                /* Check that the guard functions are the negation of each other 
                 * by looking for the magic entry "#" (exactly once)
                 */
                select ky into guard_list_1 from guard_list 
                where session_id = v_session_id and rcnt = 1;
        raise notice 'query 11';

                select ky into guard_list_2 from guard_list 
                where session_id = v_session_id and rcnt = 2;
        raise notice 'query 12';

                if ((guard_list_1 != '#' and guard_list_2 != '#') or
                    (guard_list_1 = '#' and guard_list_2 = '#')) then
                    return 'f';
                end if;
    
                /* Check that exactly one of the targets is in the previous list */

                v_count2 := 0;
                select ky into target_place_list_1 from target_place_list 
                where session_id = v_session_id and rcnt = 1;
        raise notice 'query 13';

                select ky into target_place_list_2 from target_place_list 
                where session_id = v_session_id and rcnt = 2;                
        raise notice 'query 14';

                for i in 0..v_row_count LOOP
                    select ky into previous_place_list_i 
                    from previous_place_list where session_id = v_session_id 
                    and rcnt = i;
                    if target_place_list_1 = previous_place_list_i then
                        v_count2 := v_count2 + 1;
                        v_place_key := target_place_list_2;
                    end if;
                    if target_place_list_2 = previous_place_list_i then
                        v_count2 := v_count2 + 1;
                        v_place_key := target_place_list_1;
                    end if;
                end loop;
        raise notice 'query 15';

                if v_count2 != 1 then
                    return 'f';
                end if;

            end if; end if;

            v_row_count := v_row_count + 1;

        end loop;

        /* if we got here, it must be okay */
        return 't';

     
end;$_$;


--
-- Name: acs__add_user(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character, character, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs__add_user(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character, character, character varying, boolean, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_user_id              alias for $1;  -- default null    
    p_object_type          alias for $2;  -- default 'user'
    p_creation_date        alias for $3;  -- default now()
    p_creation_user        alias for $4;  -- default null
    p_creation_ip          alias for $5;  -- default null
    p_authority_id         alias for $6;  -- defaults to local authority
    p_username             alias for $7;  --
    p_email                alias for $8;  
    p_url                  alias for $9;  -- default null
    p_first_names          alias for $10;  
    p_last_name            alias for $11;  
    p_password             alias for $12; 
    p_salt                 alias for $13; 
    p_screen_name          alias for $14; -- default null
    p_email_verified_p     alias for $15; -- default 't'
    p_member_state         alias for $16; -- default 'approved'
    v_user_id              users.user_id%TYPE;
    v_rel_id               membership_rels.rel_id%TYPE;
begin
    v_user_id := acs_user__new (
        p_user_id, 
        p_object_type, 
        p_creation_date,
        p_creation_user, 
        p_creation_ip, 
        p_authority_id,
        p_username,
        p_email,
        p_url, 
        p_first_names, 
        p_last_name, 
        p_password,
	p_salt, 
        p_screen_name, 
        p_email_verified_p,
        null                  -- context_id
    );
   
    v_rel_id := membership_rel__new (
      null,
      'membership_rel',
      acs__magic_object_id('registered_users'),      
      v_user_id,
      p_member_state,
      null,
      null);

    PERFORM acs_permission__grant_permission (
      v_user_id,
      v_user_id,
      'read'
      );

    PERFORM acs_permission__grant_permission (
      v_user_id,
      v_user_id,
      'write'
      );

    return v_user_id;
   
end;$_$;


--
-- Name: acs__magic_object_id(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs__magic_object_id(character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  magic_object_id__name                   alias for $1;  
  magic_object_id__object_id              acs_objects.object_id%TYPE;
begin
    select object_id
    into magic_object_id__object_id
    from acs_magic_objects
    where name = magic_object_id__name;

    return magic_object_id__object_id;
   
end;$_$;


--
-- Name: acs__remove_user(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs__remove_user(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  remove_user__user_id                alias for $1;  
  v_rec           record;
begin
    delete
    from acs_permissions
    where grantee_id = remove_user__user_id;

    for v_rec in select rel_id
                 from acs_rels
                 where object_id_two = remove_user__user_id
    loop
        perform acs_rel__delete(v_rec.rel_id);
    end loop;

    perform acs_user__delete(remove_user__user_id);

    return 0; 
end;$_$;


--
-- Name: acs_activity__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_activity__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       delete__activity_id	alias for $1;
begin

       -- Cascade will cause delete from acs_activities 
       -- and acs_activity_object_map

       PERFORM acs_object__delete(delete__activity_id); 

       return 0;

end;$_$;


--
-- Name: acs_activity__edit(integer, character varying, text, boolean, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_activity__edit(integer, character varying, text, boolean, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       edit__activity_id   alias for $1;
       edit__name          alias for $2; -- default null,
       edit__description   alias for $3; -- default null,
       edit__html_p        alias for $4; -- default null
       edit__status_summary alias for $5; -- default null
begin

       update acs_activities
       set    name        = coalesce(edit__name, name),
              description = coalesce(edit__description, description),
              html_p      = coalesce(edit__html_p, html_p),
              status_summary = coalesce(edit__status_summary, status_summary)
       where activity_id  = edit__activity_id;

       return 0;

end;$_$;


--
-- Name: acs_activity__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_activity__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$	-- acs_activities.name%TYPE
declare 
       name__activity_id	alias for $1; 
       v_activity_name		acs_activities.name%TYPE;
begin
       select  name
       into    v_activity_name
       from    acs_activities
       where   activity_id = name__activity_id;

       return  v_activity_name;

end;$_$;


--
-- Name: acs_activity__new(integer, character varying, text, boolean, text, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_activity__new(integer, character varying, text, boolean, text, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$		 -- return acs_activities.activity_id%TYPE
declare       
       new__activity_id         alias for $1; -- default null, 
       new__name                alias for $2;
       new__description         alias for $3; -- default null,
       new__html_p              alias for $4; -- default 'f',
       new__status_summary      alias for $5; -- default null,
       new__object_type         alias for $6; -- default 'acs_activity'
       new__creation_date       alias for $7; -- default now(), 
       new__creation_user       alias for $8; -- default null, 
       new__creation_ip         alias for $9; -- default null, 
       new__context_id          alias for $10; -- default null 
       v_activity_id		  acs_activities.activity_id%TYPE;
begin
       v_activity_id := acs_object__new(
            new__activity_id,	   -- object_id
            new__object_type,	   -- object_type
            new__creation_date,    -- creation_date  
            new__creation_user,    -- creation_user
            new__creation_ip,	   -- creation_ip
            new__context_id	   -- context_id
	    );

       insert into acs_activities
            (activity_id, name, description, html_p, status_summary)
       values
            (v_activity_id, new__name, new__description, new__html_p, new__status_summary);

       return v_activity_id;

end;$_$;


--
-- Name: acs_activity__object_map(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_activity__object_map(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       object_map__activity_id		alias for $1; 
       object_map__object_id		alias for $2;
begin
       insert into acs_activity_object_map
            (activity_id, object_id)
       values
            (object_map__activity_id, object_map__object_id);

       return 0;

end;$_$;


--
-- Name: acs_activity__object_unmap(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_activity__object_unmap(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       object_unmap__activity_id	alias for $1; 
       object_unmap__object_id		alias for $2;
begin

       delete from acs_activity_object_map
       where  activity_id = object_unmap__activity_id
       and    object_id   = object_unmap__object_id;

       return 0;

end;$_$;


--
-- Name: acs_attribute__add_description(character varying, character varying, character varying, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_attribute__add_description(character varying, character varying, character varying, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_description__object_type            alias for $1;  
  add_description__attribute_name         alias for $2;  
  add_description__description_key        alias for $3;  
  add_description__description            alias for $4;  
begin
    insert into acs_attribute_descriptions
     (object_type, attribute_name, description_key, description)
    values
     (add_description__object_type, add_description__attribute_name,
      add_description__description_key, add_description__description);

    return 0; 
end;$_$;


--
-- Name: acs_attribute__create_attribute(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_attribute__create_attribute(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_attribute__object_type            alias for $1;  
  create_attribute__attribute_name         alias for $2;  
  create_attribute__datatype               alias for $3;  
  create_attribute__pretty_name            alias for $4;  
  create_attribute__pretty_plural          alias for $5;  -- default null
  create_attribute__table_name             alias for $6;  -- default null
  create_attribute__column_name            alias for $7;  -- default null
  create_attribute__default_value          alias for $8;  -- default null
  create_attribute__min_n_values           alias for $9;  -- default 1
  create_attribute__max_n_values           alias for $10; -- default 1
  create_attribute__sort_order             alias for $11; -- default null
  create_attribute__storage                alias for $12; -- default 'type_specific'
  create_attribute__static_p               alias for $13; -- default 'f'

  v_sort_order           acs_attributes.sort_order%TYPE;
  v_attribute_id         acs_attributes.attribute_id%TYPE;
begin
    if create_attribute__sort_order is null then
      select coalesce(max(sort_order), 1) into v_sort_order
      from acs_attributes
      where object_type = create_attribute__object_type
      and attribute_name = create_attribute__attribute_name;
    else
      v_sort_order := create_attribute__sort_order;
    end if;

    select acs_attribute_id_seq.nextval into v_attribute_id;

    insert into acs_attributes
      (attribute_id, object_type, table_name, column_name, attribute_name,
       pretty_name, pretty_plural, sort_order, datatype, default_value,
       min_n_values, max_n_values, storage, static_p)
    values
      (v_attribute_id, create_attribute__object_type, 
       create_attribute__table_name, create_attribute__column_name, 
       create_attribute__attribute_name, create_attribute__pretty_name,
       create_attribute__pretty_plural, v_sort_order, 
       create_attribute__datatype, create_attribute__default_value,
       create_attribute__min_n_values, create_attribute__max_n_values, 
       create_attribute__storage, create_attribute__static_p);

    return v_attribute_id;
   
end;$_$;


--
-- Name: acs_attribute__drop_attribute(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_attribute__drop_attribute(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_attribute__object_type            alias for $1;  
  drop_attribute__attribute_name         alias for $2;  
begin
    -- first remove possible values for the enumeration
    delete from acs_enum_values
      where attribute_id in (select a.attribute_id 
                               from acs_attributes a 
                              where a.object_type = drop_attribute__object_type
                                and a.attribute_name = drop_attribute__attribute_name);

    delete from acs_attributes
     where object_type = drop_attribute__object_type
       and attribute_name = drop_attribute__attribute_name;

    return 0; 
end;$_$;


--
-- Name: acs_attribute__drop_description(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_attribute__drop_description(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_description__object_type            alias for $1;  
  drop_description__attribute_name         alias for $2;  
  drop_description__description_key        alias for $3;  
begin
    delete from acs_attribute_descriptions
    where object_type = drop_description__object_type
    and attribute_name = drop_description__attribute_name
    and description_key = drop_description__description_key;

    return 0; 
end;$_$;


--
-- Name: acs_content__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_content__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__content_id             alias for $1;  
begin
	delete from acs_contents 
	where content_id = delete__content_id;

        return 0; 
end;$_$;


--
-- Name: acs_content__new(integer, character varying, character varying, character, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_content__new(integer, character varying, character varying, character, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__content_id             alias for $1;  
  new__mime_type              alias for $2;  
  new__nls_language           alias for $3;  
  new__searchable_p           alias for $4;  
  new__content                alias for $5;  
begin
	insert into acs_contents (
	    content_id,
	    mime_type,
	    nls_language,
	    searchable_p,
	    content
	) values (
	    new__content_id,
	    new__mime_type,
	    new__nls_language,
	    new__searchable_p,
	    new__content
	);

        return 0; 
end;$_$;


--
-- Name: acs_content__update_mime_type(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_content__update_mime_type(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  update_mime_type__content_id             alias for $1;  
  update_mime_type__mime_type              alias for $2;  
begin
	update acs_contents
	set mime_type = update_mime_type__mime_type
	where content_id = update_mime_type__content_id;

        return 0; 
end;$_$;


--
-- Name: acs_content__update_nls_languag(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_content__update_nls_languag(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  update_nls_language__content_id             alias for $1;  
  update_nls_language__nls_language           alias for $2;  
begin
	update acs_contents
	set nls_language = update_nls_language__nls_language
	where content_id = update_nls_language__content_id;

        return 0; 
end;$_$;


--
-- Name: acs_content__update_searchable_(integer, character); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_content__update_searchable_(integer, character) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  update_searchable_p__content_id             alias for $1;  
  update_searchable_p__searchable_p           alias for $2;  
begin
	update acs_contents
	set searchable_p = update_searchable_p__searchable_p
	where content_id = update_searchable_p__content_id;

        return 0; 
end;$_$;


--
-- Name: acs_event__activity_set(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__activity_set(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        activity_set__event_id        alias for $1;
        activity_set__activity_id     alias for $2;
begin
        update acs_events
        set    activity_id = activity_set__activity_id
        where  event_id    = activity_set__event_id;

	return 0;

end;$_$;


--
-- Name: acs_event__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       delete__event_id	alias for $1;
       v_recurrence_id		acs_events.recurrence_id%TYPE;
begin
       select recurrence_id into v_recurrence_id
       from   acs_events
       where  event_id = delete__event_id;

       -- acs_events and acs_event_party_map deleted via on delete cascade
       PERFORM acs_object__delete(delete__event_id); 

       -- Check for no more instances and delete recurrence if exists
       if not acs_event__instances_exist_p(v_recurrence_id) then 
            PERFORM recurrence__delete(v_recurrence_id);
       end if;

       return 0;

end;$_$;


--
-- Name: acs_event__delete_all(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__delete_all(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       delete_all__event_id	alias for $1;
       v_recurrence_id		acs_events.recurrence_id%TYPE;
begin

       select recurrence_id into v_recurrence_id
       from   acs_events
       where  event_id = delete_all__event_id;

       PERFORM acs_event__delete_all_recurrences(v_recurrence_id);

       return 0;

end;$_$;


--
-- Name: acs_event__delete_all_recurrences(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__delete_all_recurrences(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       delete_all_recurrences__recurrence_id	alias for $1; -- default null
       rec_event				record;
begin
       if delete_all_recurrences__recurrence_id is not null then
            for rec_event in 
	      select event_id 
	      from acs_events 
	      where  recurrence_id = delete_all_recurrences__recurrence_id
	    loop
                PERFORM acs_event__delete(rec_event.event_id);
            end loop;
       end if;
	
       return 0;

end;$_$;


--
-- Name: acs_event__get_description(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__get_description(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$	-- acs_events.description%TYPE
declare
       get_description__event_id   alias for $1;
       v_description		    acs_events.description%TYPE; 
begin

       select coalesce(e.description, a.description) into v_description
       from   acs_events e
       left join acs_activities a
       on  (e.activity_id = a.activity_id)
       where  e.event_id = get_description__event_id;

       return v_description;

end;$_$;


--
-- Name: acs_event__get_html_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__get_html_p(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$	-- acs_events.html_p%TYPE
declare
       get_html_p__event_id    alias for $1; -- in acs_events.event_id%TYPE 
       v_html_p		acs_events.html_p%TYPE; 
begin
       select coalesce(e.html_p, a.html_p) into v_html_p
       from  acs_events e
       left join acs_activities a
       on (e.activity_id = a.activity_id)
       where e.event_id = get_html_p__event_id;

       return v_html_p;

end;$_$;


--
-- Name: acs_event__get_name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__get_name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$	-- acs_events.name%TYPE
declare    
       get_name__event_id alias for $1; 
       v_name acs_events.name%TYPE; 
begin

       select coalesce(e.name, a.name) into v_name
       from   acs_events e 
       left join acs_activities a
       on (e.activity_id = a.activity_id)
       where e.event_id = get_name__event_id;

       return v_name;

end;$_$;


--
-- Name: acs_event__get_status_summary(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__get_status_summary(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       get_status_summary__event_id    alias for $1; -- acs_events.event_id%TYPE 
       v_status_summary		acs_events.status_summary%TYPE; 
begin
       select coalesce(e.status_summary, a.status_summary) into v_status_summary
       from  acs_events e
       left join acs_activities a
       on (e.activity_id = a.activity_id)
       where e.event_id = get_status_summary__event_id;

       return v_status_summary;

end;$_$;


--
-- Name: acs_event__get_value(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__get_value(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$	-- return apm_parameter_values.attr_value%TYPE
declare
       get_value__parameter_name	alias for $1;
       v_package_id			apm_packages.package_id%TYPE;
begin
       select package_id into v_package_id
       from   apm_packages
       where  package_key = 'acs-events';

       return apm__get_value(v_package_id, get_value__parameter_name);

end;$_$;


--
-- Name: acs_event__insert_instances(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__insert_instances(integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       insert_instances__event_id      alias for $1;
       insert_instances__cutoff_date   alias for $2;  -- default null
       event_row		       acs_events%ROWTYPE;
       recurrence_row		       recurrences%ROWTYPE;
       v_event_id		       acs_events.event_id%TYPE;
       v_interval_name		       recurrence_interval_types.interval_name%TYPE;
       v_n_intervals		       recurrences.every_nth_interval%TYPE;
       v_days_of_week		       recurrences.days_of_week%TYPE;
       v_last_date_done		       timestamptz;
       v_stop_date		       timestamptz;
       v_start_date		       timestamptz;
       v_event_date		       timestamptz;
       v_diff			       integer;
       v_current_date		       timestamptz;
       v_last_day		       timestamptz;
       v_week_date		       timestamptz;
       v_instance_count		       integer;
       v_days_length		       integer;
       v_days_index		       integer;
       v_day_num		       integer;
       rec_execute		       record;
begin

	-- Get event parameters
        select * into event_row
        from   acs_events
        where  event_id = insert_instances__event_id;

	-- Get recurrence information
        select * into recurrence_row
        from   recurrences
        where  recurrence_id = event_row.recurrence_id;
        

        -- Set cutoff date to stop populating the DB with recurrences
        -- EventFutureLimit is in years. (a parameter of the service)
        if insert_instances__cutoff_date is null then
           v_stop_date := add_months(now(), 12 * to_number(acs_event__get_value('EventFutureLimit'),'99999'));
        else
           v_stop_date := insert_instances__cutoff_date;
        end if;
        
        -- Events only populated until max(cutoff_date, recur_until)
        -- If recur_until null, then defaults to cutoff_date
        if recurrence_row.recur_until < v_stop_date then
           v_stop_date := recurrence_row.recur_until;
        end if;
        
        -- Figure out the date to start from.
	-- JS: I do not understand why the date must be truncated to the midnight of the event date
        select min(start_date)
        into   v_event_date
        from   acs_events_dates
        where  event_id = insert_instances__event_id;

        if recurrence_row.db_populated_until is null then
           v_start_date := v_event_date;
        else
           v_start_date := recurrence_row.db_populated_until;
        end if;
        
        v_current_date   := v_start_date;
        v_last_date_done := v_start_date;
        v_n_intervals    := recurrence_row.every_nth_interval;
        
        -- Case off of the interval_name to make code easier to read
        select interval_name into v_interval_name
        from   recurrences r, 
               recurrence_interval_types t
        where  recurrence_id   = recurrence_row.recurrence_id
        and    r.interval_type = t.interval_type;
        
        -- Week has to be handled specially.
        -- Start with the beginning of the week containing the start date.
        if v_interval_name = 'week' 
	then
            v_current_date := next_day(v_current_date - to_interval(7,'days'),'SUNDAY');
            v_days_of_week := recurrence_row.days_of_week;
            v_days_length  := char_length(v_days_of_week);
        end if;
        
        -- Check count to prevent runaway in case of error
        v_instance_count := 0;

	-- A feature: we only care about the date when populating the database for reccurrence.
        while v_instance_count < 10000 and (date_trunc('day',v_last_date_done) <= date_trunc('day',v_stop_date))
        loop
            v_instance_count := v_instance_count + 1;
        
            -- Calculate next date based on interval type

	    -- Add next day, skipping every v_n_intervals
	    if v_interval_name = 'day' 
	    then
                v_current_date := v_current_date + to_interval(v_n_intervals,'days');
	    end if;
        
	    -- Add a full month, skipping by v_n_intervals months
            if v_interval_name = 'month_by_date' 
	    then
                v_current_date := add_months(v_current_date, v_n_intervals);
	    end if;

	    -- Add days so that the next date will have the same day of the week,  and week of the month
            if v_interval_name = 'month_by_day' then
                -- Find last day of month before correct month
                v_last_day := add_months(last_day(v_current_date), v_n_intervals - 1);
                -- Find correct week and go to correct day of week
                v_current_date := next_day(v_last_day + 
				              to_interval(7 * (to_number(to_char(v_current_date,'W'),'99') - 1),
							  'days'),
                                            to_char(v_current_date, 'DAY'));
	    end if;

	    -- Add days so that the next date will have the same day of the week on the last week of the month
            if v_interval_name = 'last_of_month' then
                -- Find last day of correct month
                v_last_day := last_day(add_months(v_current_date, v_n_intervals));
                -- Back up one week and find correct day of week
                v_current_date := next_day(v_last_day - to_interval(7,'days'), to_char(v_current_date, 'DAY'));
	    end if;

	    -- Add a full year (12 months)
            If v_interval_name = 'year' then
                v_current_date := add_months(v_current_date, 12 * v_n_intervals);
	    end if;

            -- Deal with custom function
            if v_interval_name = 'custom' then

	        -- JS: Execute a dynamically created query on the fly...
	        FOR rec_execute IN
		EXECUTE 'select ' || recurrence_row.custom_func 
				    || '(' || quote_literal(v_current_date)
				    || ',' || v_n_intervals || ') as current_date'
		LOOP
		     v_current_date := rec_execute.current_date;
		END LOOP;

            end if;
        
            -- Check to make sure we are not going past Trunc because dates are not integral
            exit when date_trunc('day',v_current_date) > date_trunc('day',v_stop_date);
        
            -- Have to handle week specially
            if v_interval_name = 'week' then
                -- loop over days_of_week extracting each day number
                -- add day number and insert
                v_days_index := 1;
                v_week_date  := v_current_date;
                while v_days_index <= v_days_length loop
                    v_day_num   := SUBSTR(v_days_of_week, v_days_index, 1);
                    v_week_date := v_current_date + to_interval(v_day_num,'days');
                    if date_trunc('day',v_week_date) > date_trunc('day',v_start_date) 
		       and date_trunc('day',v_week_date) <= date_trunc('day',v_stop_date) then
                         -- This is where we add the event
                         v_event_id := acs_event__new_instance(
                              insert_instances__event_id,					   -- event_id
                              date_trunc('day',v_week_date) - date_trunc('day',v_event_date)    -- offset
                         );
                         v_last_date_done := v_week_date;

                     else if date_trunc('day',v_week_date) > date_trunc('day',v_stop_date) 
		          then
                             -- Gone too far
                             exit;
			  end if;

                     end if;

                     v_days_index := v_days_index + 2;

                 end loop;

                 -- Now move to next week with repeats.
                v_current_date := v_current_date + to_interval(7 * v_n_intervals,'days');
            else
                -- All other interval types
                -- This is where we add the event
                v_event_id := acs_event__new_instance(
                    insert_instances__event_id,						    -- event_id 
                    date_trunc('day',v_current_date) - date_trunc('day',v_event_date)   -- offset
                );
                v_last_date_done := v_current_date;
            end if;
        end loop;
        
        update recurrences
        set    db_populated_until = v_last_date_done
        where  recurrence_id      = recurrence_row.recurrence_id;

	return 0;
end;$_$;


--
-- Name: acs_event__instances_exist_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__instances_exist_p(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$	
declare
        instances_exist_p__recurrence_id	alias for $1;
        v_result				integer;
begin
        -- Only need to check if any rows exist.
        select count(*) into v_result
        from   dual 
        where exists (select recurrence_id
                      from   acs_events
                      where  recurrence_id = instances_exist_p__recurrence_id);

        if v_result = 0 then
            return false;
        else
            return true;
        end if;

end;$_$;


--
-- Name: acs_event__new(integer, character varying, text, boolean, text, integer, integer, integer, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__new(integer, character varying, text, boolean, text, integer, integer, integer, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin
       return acs_event__new($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,null);
end;$_$;


--
-- Name: acs_event__new(integer, character varying, text, boolean, text, integer, integer, integer, character varying, timestamp with time zone, integer, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__new(integer, character varying, text, boolean, text, integer, integer, integer, character varying, timestamp with time zone, integer, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- acs_events.event_id%TYPE
declare
       new__event_id        alias for $1;  -- default null, 
       new__name            alias for $2;  -- default null,
       new__description     alias for $3;  -- default null,
       new__html_p          alias for $4; -- default null 
       new__status_summary  alias for $5; -- default null 
       new__timespan_id     alias for $6;  -- default null, 
       new__activity_id     alias for $7;  -- default null, 
       new__recurrence_id   alias for $8;  -- default null, 
       new__object_type     alias for $9;  -- default 'acs_event', 
       new__creation_date   alias for $10;  -- default now(),
       new__creation_user   alias for $11;  -- default null, 
       new__creation_ip     alias for $12; -- default null, 
       new__context_id      alias for $13; -- default null 
       new__package_id      alias for $14; -- default null 
       v_event_id	    acs_events.event_id%TYPE;
begin
       v_event_id := acs_object__new(
            new__event_id,	-- object_id
            new__object_type,	-- object_type
            new__creation_date, -- creation_date
            new__creation_user,	-- creation_user
            new__creation_ip,	-- creation_ip
            new__context_id,	-- context_id
            't',		-- security_inherit_p
            new__name,		-- title
            new__package_id	-- package_id
	    );

       insert into acs_events
            (event_id, name, description, html_p, status_summary, activity_id, timespan_id, recurrence_id)
       values
            (v_event_id, new__name, new__description, new__html_p, new__status_summary, new__activity_id, new__timespan_id,
             new__recurrence_id);

       return v_event_id;

end;$_$;


--
-- Name: acs_event__new_instance(integer, interval); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__new_instance(integer, interval) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	      -- acs_events.event_id%TYPE
declare
       new_instance__event_id    alias for $1;
       new_instance__date_offset alias for $2;
       event_row		  acs_events%ROWTYPE;
       object_row		  acs_objects%ROWTYPE;
       v_event_id		  acs_events.event_id%TYPE;
       v_timespan_id		  acs_events.timespan_id%TYPE;
begin

       -- Get event parameters
       select * into event_row
       from   acs_events
       where  event_id = new_instance__event_id;

       -- Get object parameters                
       select * into object_row
       from   acs_objects
       where  object_id = new_instance__event_id;

       -- We allow non-zero offset, so we copy
       v_timespan_id := timespan__copy(event_row.timespan_id, new_instance__date_offset);

       -- Create a new instance
       v_event_id := acs_event__new(
	    null,                     -- event_id (default)
            event_row.name,           -- name
            event_row.description,    -- description
            event_row.html_p,         -- html_p
            event_row.status_summary, -- status_summary
            v_timespan_id,	      -- timespan_id
            event_row.activity_id,    -- activity_id
            event_row.recurrence_id,  -- recurrence_id
	    'acs_event',	      -- object_type (default)
	    now(),		      -- creation_date (default)
            object_row.creation_user, -- creation_user
            object_row.creation_ip,   -- creation_ip
            object_row.context_id,     -- context_id
            object_row.package_id     -- context_id
	    );

      return v_event_id;

end;$_$;


--
-- Name: acs_event__party_map(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__party_map(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       party_map__event_id        alias for $1;
       party_map__party_id        alias for $2;
begin
       insert into acs_event_party_map
            (event_id, party_id)
       values
            (party_map__event_id, party_map__party_id);

       return 0;

end;$_$;


--
-- Name: acs_event__party_unmap(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__party_unmap(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       party_unmap__event_id    alias for $1;
       party_unmap__party_id    alias for $2;
begin
       delete from acs_event_party_map
       where  event_id = party_unmap__event_id
       and    party_id = party_unmap__party_id;

       return 0;

end;$_$;


--
-- Name: acs_event__recurrence_timespan_edit(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__recurrence_timespan_edit(integer, timestamp with time zone, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_event_id                      alias for $1;
        p_start_date                    alias for $2;
        p_end_date                      alias for $3;
        v_timespan                   RECORD;
        v_one_start_date             timestamptz;
        v_one_end_date               timestamptz;
BEGIN
        -- get the initial offsets
        select start_date,
               end_date into v_one_start_date,
               v_one_end_date
        from time_intervals, 
             timespans, 
             acs_events 
        where time_intervals.interval_id = timespans.interval_id
          and timespans.timespan_id = acs_events.timespan_id
          and event_id=p_event_id;

        FOR v_timespan in
            select *
            from time_intervals
            where interval_id in (select interval_id
                                  from timespans 
                                  where timespan_id in (select timespan_id
                                                        from acs_events 
                                                        where recurrence_id = (select recurrence_id 
                                                                               from acs_events where event_id = p_event_id)))
        LOOP
                PERFORM time_interval__edit(v_timespan.interval_id, 
                                            v_timespan.start_date + (p_start_date - v_one_start_date), 
                                            v_timespan.end_date + (p_end_date - v_one_end_date));
        END LOOP;

        return p_event_id;
END;
$_$;


--
-- Name: acs_event__recurs_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__recurs_p(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       recurs_p__event_id    alias for $1;
       v_result	      boolean;
begin
       select (case when recurrence_id is null 
	             then false
                     else true 
                end) into v_result
       from   acs_events
       where  event_id = recurs_p__event_id;

       return v_result;

end;$_$;


--
-- Name: acs_event__shift(integer, interval, interval); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__shift(integer, interval, interval) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       shift__event_id      alias for $1; -- default null,
       shift__start_offset  alias for $2; -- default 0,
       shift__end_offset    alias for $3; -- default 0
       rec_events	    record;
begin

--       update acs_events_dates
--       set    start_date = start_date + shift__start_offset,
--             end_date   = end_date + shift__end_offset
--       where  event_id   = shift__event_id;

	  -- Can not update view, so we do it the hard way 
	  -- (as if we make the rule anyways)
	  for rec_events in
	      select t.*
	      from acs_events e, timespans s, time_intervals t
	      where e.event_id   = shift__event_id
	      and   e.timespan_id = s.timespan_id
	      and   s.interval_id = t.interval_id
          loop
	       update time_intervals
	       set    start_date = start_date + shift__start_offset,
		      end_date   = end_date + shift__end_offset
	       where  interval_id = rec_events.interval_id;
	  end loop;

       return 0;

end;$_$;


--
-- Name: acs_event__shift(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__shift(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       shift__event_id        alias for $1; -- default null,
       shift__start_offset    alias for $2; -- default 0,
       shift__end_offset      alias for $3; -- default 0
begin
	
       return acs_event__shift (
	            shift__event_id,
	            to_interval(shift__start_offset,'days'),
	            to_interval(shift__end_offset,'days')
		    );
				    
end;$_$;


--
-- Name: acs_event__shift_all(integer, interval, interval); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__shift_all(integer, interval, interval) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        shift_all__event_id        alias for $1; -- default null,
        shift_all__start_offset    alias for $2; -- default 0,
        shift_all__end_offset      alias for $3; -- default 0
	rec_events		   record;
begin


--        update acs_events_dates
--        set    start_date    = start_date + shift_all__start_offset,
--              end_date      = end_date + shift_all__end_offset
--        where recurrence_id  = (select recurrence_id
--                                from   acs_events
--                                where  event_id = shift_all__event_id);

	-- Can not update views
	for rec_events in
	    select *
	    from acs_events_dates
	    where recurrence_id  = (select recurrence_id
				    from   acs_events
				    where  event_id = shift_all__event_id)
	loop
	
	    PERFORM acs_event__shift(
			rec_events.event_id,
			shift_all__start_offset,	       
			shift_all__end_offset
			);
	end loop;

	return 0;

end;$_$;


--
-- Name: acs_event__shift_all(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__shift_all(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       shift_all__event_id        alias for $1; -- default null,
       shift_all__start_offset    alias for $2; -- default 0,
       shift_all__end_offset      alias for $3; -- default 0
begin
	
       return acs_event__shift_all (
	            shift_all__event_id,
	            to_interval(shift_all__start_offset,'days'),
	            to_interval(shift_all__end_offset,'days')
		    );
				    
end;$_$;


--
-- Name: acs_event__timespan_set(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_event__timespan_set(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       timespan_set__event_id        alias for $1;
       timespan_set__timespan_id     alias for $2;
begin
       update acs_events
       set    timespan_id = timespan_set__timespan_id
       where  event_id    = timespan_set__event_id;

       return 0;

end;$_$;


--
-- Name: acs_group__check_representation(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_group__check_representation(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  group_id               alias for $1;  
  res                    boolean; 
  comp                   record;
  memb                   record;      
begin
   if group_id is null then 
        --maybe we should just return 'f' instead?
	raise exception 'acs_group__check_representation called with null group_id';
   end if;

   res := 't';
   PERFORM acs_log__notice('acs_group.check_representation',
                  'Running check_representation on group ' || group_id);

   if acs_object__check_representation(group_id) = 'f' then
     res := 'f';
   end if;

   for comp in select c.rel_id
             from acs_rels r, composition_rels c
             where r.rel_id = c.rel_id
             and r.object_id_one = group_id 
   LOOP
     if composition_rel__check_representation(comp.rel_id) = 'f' then
       res := 'f';
     end if;
   end loop;

   for memb in  select m.rel_id
             from acs_rels r, membership_rels m
             where r.rel_id = m.rel_id
             and r.object_id_one = group_id 
   LOOP
     if membership_rel__check_representation(memb.rel_id) = 'f' then
       res := 'f';
     end if;
   end loop;

   PERFORM acs_log__notice('acs_group.check_representation',
                  'Done running check_representation on group ' || group_id);

   return res;
  
end;$_$;


--
-- Name: acs_group__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_group__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__group_id              alias for $1;  
  row                           record;
begin
 
   -- Delete all the relations of any type to this group
   for row in select r.rel_id, t.package_name
                 from acs_rels r, acs_object_types t
                where r.rel_type = t.object_type
                  and (r.object_id_one = delete__group_id
                       or r.object_id_two = delete__group_id) 
   LOOP
      execute 'select ' ||  row.package_name || '__delete(' || row.rel_id || ')';
   end loop;
 
   -- Delete all segments defined for this group
   for row in  select segment_id 
                 from rel_segments 
                where group_id = delete__group_id 
   LOOP
       PERFORM rel_segment__delete(row.segment_id);
   end loop;

   PERFORM party__delete(delete__group_id);

   return 0; 
end;$_$;


--
-- Name: acs_group__member_p(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_group__member_p(integer, integer, boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  p_party_id               alias for $1;  
  p_group_id               alias for $2;
  p_cascade_membership     alias for $3;
begin
  if p_cascade_membership  then
    return count(*) > 0
      from group_member_map
      where group_id = p_group_id and
            member_id = p_party_id;
  else
    return count(*) > 0
      from acs_rels rels, all_object_party_privilege_map perm
    where perm.object_id = rels.rel_id
           and perm.privilege = 'read'
           and rels.rel_type = 'membership_rel'
	   and rels.object_id_one = p_group_id
           and rels.object_id_two = p_party_id;
  end if;
end;$_$;


--
-- Name: acs_group__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_group__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  name__group_id         alias for $1;  
  name__group_name       varchar(200);  
begin
  select group_name
  into name__group_name
  from groups
  where group_id = name__group_id;

  return name__group_name;
  
end;$_$;


--
-- Name: acs_group__new(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_group__new(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        gname   alias for $1;
begin
        return acs_group__new(null,
                              'group',
                              now(),
                              null,
                              null,
                              null,
                              null,
                              gname,
                              null,
                              null);
end;$_$;


--
-- Name: acs_group__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_group__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__group_id              alias for $1;  -- default null  
  new__object_type           alias for $2;  -- default 'group'
  new__creation_date         alias for $3;  -- default now()
  new__creation_user         alias for $4;  -- default null
  new__creation_ip           alias for $5;  -- default null
  new__email                 alias for $6;  -- default null
  new__url                   alias for $7;  -- default null
  new__group_name            alias for $8;  
  new__join_policy           alias for $9;  -- default null
  new__context_id            alias for $10; -- default null
  v_group_id                 groups.group_id%TYPE;
  v_group_type_exists_p      integer;
  v_join_policy              groups.join_policy%TYPE;
begin
  v_group_id :=
   party__new(new__group_id, new__object_type, new__creation_date, 
              new__creation_user, new__creation_ip, new__email, 
              new__url, new__context_id);

  v_join_policy := new__join_policy;

  -- if join policy was not specified, select the default based on group type
  if v_join_policy is null or v_join_policy = '' then
      select count(*) into v_group_type_exists_p
      from group_types
      where group_type = new__object_type;

      if v_group_type_exists_p = 1 then
          select default_join_policy into v_join_policy
          from group_types
          where group_type = new__object_type;
      else
          v_join_policy := 'open';
      end if;
  end if;

  update acs_objects
  set title = new__group_name
  where object_id = v_group_id;

  insert into groups
   (group_id, group_name, join_policy)
  values
   (v_group_id, new__group_name, v_join_policy);

  -- setup the permissible relationship types for this group

  -- DRB: we have to call nextval() directly because the select may
  -- return more than one row.  The sequence hack will only compute
  -- one nextval value causing the insert to fail ("may" in PG, which
  -- is actually broken.  It should ALWAYS return exactly one value for
  -- the view.  In PG it may or may not depending on the optimizer's
  -- mood.  PG group seems uninterested in acknowledging the fact that
  -- this is a bug)

  insert into group_rels
  (group_rel_id, group_id, rel_type)
  select nextval('t_acs_object_id_seq'), v_group_id, g.rel_type
    from group_type_rels g
   where g.group_type = new__object_type;

  return v_group_id;
  
end;$_$;


--
-- Name: acs_log__debug(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_log__debug(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  debug__log_key                alias for $1;  
  debug__message                alias for $2;  
begin
    insert into acs_logs
     (log_id, log_level, log_key, message)
    values
     (acs_log_id_seq.nextval, 'debug', debug__log_key, debug__message);

    return 0; 
end;$_$;


--
-- Name: acs_log__error(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_log__error(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  error__log_key                alias for $1;  
  error__message                alias for $2;  
begin
    insert into acs_logs
     (log_id, log_level, log_key, message)
    values
     (acs_log_id_seq.nextval, 'error', error__log_key, error__message);

    return 0; 
end;$_$;


--
-- Name: acs_log__notice(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_log__notice(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  notice__log_key                alias for $1;  
  notice__message                alias for $2;  
begin
    insert into acs_logs
     (log_id, log_level, log_key, message)
    values
     (acs_log_id_seq.nextval, 'notice', notice__log_key, notice__message);

    return 0; 
end;$_$;


--
-- Name: acs_log__warn(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_log__warn(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  warn__log_key                alias for $1;  
  warn__message                alias for $2;  
begin
    insert into acs_logs
     (log_id, log_level, log_key, message)
    values
     (acs_log_id_seq.nextval, 'warn', warn__log_key, warn__message);

    return 0; 
end;$_$;


--
-- Name: acs_mail_body__body_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_body__body_p(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    p_object_id		alias for $1;
    v_check_body_id integer;
begin
	select count(body_id) into v_check_body_id
	  from acs_mail_bodies where body_id = p_object_id;

     if v_check_body_id <> 0 then
         return 't';
     else
         return 'f';
     end if;
end;
$_$;


--
-- Name: acs_mail_body__clone(integer, integer, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_body__clone(integer, integer, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare 
	p_old_body_id       alias for $1;
	p_body_id           alias for $2;    -- default null
	p_object_type       alias for $3;    -- default acs_mail_body
	p_creation_date     alias for $4;    -- default now()
	p_creation_user     alias for $5;    -- default null
	p_creation_ip       alias for $6;    -- default null
	p_context_id        alias for $7;    -- default null
    v_object_id         integer;
    v_body_reply_to		integer;
    v_body_from         integer;
    v_body_date         timestamptz;
    v_header_message_id varchar;
    v_header_reply_to   varchar;
    v_header_subject    text;
    v_header_from       text;
    v_header_to         text;
    v_content_item_id integer;
begin
     select body_reply_to, body_from, body_date,
            header_reply_to, header_subject, header_from, header_to,
            content_item_id
         into v_body_reply_to, v_body_from, v_body_date,
            v_header_reply_to, v_header_subject, v_header_from, v_header_to,
            v_content_item_id
         from acs_mail_bodies
         where body_id = p_old_body_id;

     v_object_id := acs_mail_body__new (
		p_body_id,				-- body_id 
		v_body_reply_to,		-- body_reply_to 
		v_body_from,			-- body_from 
		v_body_date,			-- body_date 
		v_header_reply_to,		-- header_reply_to 
		v_header_subject,		-- header_subject 
		v_header_from,			-- header_from 
		v_header_to,			-- header_to 
		v_content_item_id,		-- content_item_id 
		p_object_type,			-- object_type 
		p_creation_date,		-- creation_date 
		p_creation_user,		-- creation_user 
		p_creation_ip,			-- creation_ip 
		p_context_id			-- context_id 
     );

     return v_object_id;
end;
$_$;


--
-- Name: acs_mail_body__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_body__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare
	p_body_id		alias for $1;
begin
	perform acs_mail_gc_object__delete( p_body_id );

    return 1;
end;
$_$;


--
-- Name: acs_mail_body__new(integer, integer, integer, timestamp with time zone, character varying, character varying, text, text, text, integer, character varying, date, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_body__new(integer, integer, integer, timestamp with time zone, character varying, character varying, text, text, text, integer, character varying, date, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare
	p_body_id			alias for $1;    -- default null
	p_body_reply_to		alias for $2;    -- default null
	p_body_from			alias for $3;    -- default null
	p_body_date			alias for $4;    -- default null
	p_header_message_id	alias for $5;    -- default null
	p_header_reply_to   alias for $6;    -- default null
	p_header_subject    alias for $7;    -- default null
	p_header_from       alias for $8;    -- default null
	p_header_to         alias for $9;    -- default null
	p_content_item_id   alias for $10;   -- default null
	p_object_type       alias for $11;   -- default acs_mail_body
	p_creation_date     alias for $12;   -- default now()
	p_creation_user     alias for $13;   -- default null
	p_creation_ip       alias for $14;   -- default null
	p_context_id        alias for $15;   -- default null
    v_object_id         integer;
	v_system_url		varchar;
	v_domain_name		varchar;
	v_idx				integer;
	v_header_message_id	acs_mail_bodies.header_message_id%TYPE;
begin

     v_object_id := acs_mail_gc_object__new (
		p_body_id,			-- gc_object_id 
		p_object_type,		-- object_type 
		p_creation_date,	-- creation_date 
		p_creation_user,	-- creation_user 
		p_creation_ip,		-- creation_ip 
		p_context_id		-- context_id 
     );

	-- vinodk: get SystemURL parameter and use it to extract domain name
	select apm__get_value(package_id, 'SystemURL') into v_system_url
		from apm_packages where package_key='acs-kernel';
	v_idx := position('http://' in v_system_url);
	v_domain_name := trim (substr(v_system_url, v_idx + 7));

	v_header_message_id := coalesce (p_header_message_id,
		current_date || '.' || v_object_id || '@' || 
		v_domain_name || '.sddd');

    insert into acs_mail_bodies
        (body_id, body_reply_to, body_from, body_date, 
          header_message_id, header_reply_to, header_subject, header_from,
		 header_to, content_item_id)
    values
         (v_object_id, p_body_reply_to, p_body_from, p_body_date,
          v_header_message_id, p_header_reply_to, p_header_subject, p_header_from,
          p_header_to, p_content_item_id);

     return v_object_id;
end;
$_$;


--
-- Name: acs_mail_body__set_content_object(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_body__set_content_object(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_body_id				alias for $1;
	p_content_item_id		alias for $2;
begin
    update acs_mail_bodies
        set content_item_id = p_content_item_id
        where body_id = p_body_id;

    return 1;
end;
$_$;


--
-- Name: acs_mail_gc_object__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_gc_object__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_gc_object_id	alias for $1;
begin
    delete from acs_mail_gc_objects
		where gc_object_id = p_gc_object_id;

	perform acs_object__delete( p_gc_object_id );

    return 1;
end;
$_$;


--
-- Name: acs_mail_gc_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_gc_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_gc_object_id  alias for $1;    -- default null
    p_object_type   alias for $2;    -- default acs_mail_gc_object
    p_creation_date alias for $3;    -- default now
    p_creation_user alias for $4;    -- default null
    p_creation_ip   alias for $5;    -- default null
    p_context_id    alias for $6;    -- default null
    v_object_id   integer;
begin
    v_object_id := acs_object__new (
		p_gc_object_id,		-- object_id 
		p_object_type,		-- object_type 
		p_creation_date,	-- creation_date 
		p_creation_user,	-- creation_user 
		p_creation_ip,		-- creation_ip 
		p_context_id		-- context_id 
    );

    insert into acs_mail_gc_objects values ( v_object_id );

    return v_object_id;
end;
$_$;


--
-- Name: acs_mail_link__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_link__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_mail_link_id			alias for $1;
begin
	perform acs_object__delete( p_mail_link_id );

    return 1;
end;
$_$;


--
-- Name: acs_mail_link__link_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_link__link_p(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
	p_object_id				alias for $1;
    v_check_link_id			integer;
begin
    select count(mail_link_id) into v_check_link_id
      from acs_mail_links
      where mail_link_id = p_object_id;

    if v_check_link_id <> 0 then
        return 't';
    else
        return 'f';
    end if;
end;
$_$;


--
-- Name: acs_mail_link__new(integer, integer, integer, timestamp with time zone, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_link__new(integer, integer, integer, timestamp with time zone, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_mail_link_id			alias for $1;    -- default null
	p_body_id				alias for $2;
	p_context_id			alias for $3;    -- default null
	p_creation_date			alias for $4;    -- default now()
	p_creation_user			alias for $5;    -- default null
	p_creation_ip			alias for $6;    -- default null
	p_object_type			alias for $7;    -- default acs_mail_link
    v_mail_link_id			acs_mail_links.mail_link_id%TYPE;
begin
    v_mail_link_id := acs_object__new (
		p_mail_link_id,		-- object_id 
		p_object_type,		-- object_type 
		p_creation_date,	-- creation_date 
		p_creation_user,	-- creation_user 
		p_creation_ip,		-- creation_ip 
		p_context_id		-- context_id 
    );

    insert into acs_mail_links 
	 ( mail_link_id, body_id )
	values 
	 ( v_mail_link_id, p_body_id );

    return v_mail_link_id;
end;
$_$;


--
-- Name: acs_mail_multipart__add_content(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_multipart__add_content(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare
	p_multipart_id			alias for $1;
    p_content_item_id		alias for $2;
    v_multipart_id			integer;
    v_max_num				integer;
begin
    -- get a row lock on the multipart item
    select multipart_id into v_multipart_id from acs_mail_multiparts
        where multipart_id = p_multipart_id for update;

    select coalesce(max(sequence_number),0) into v_max_num
        from acs_mail_multipart_parts
        where multipart_id = p_multipart_id;

    insert into acs_mail_multipart_parts
        (multipart_id, sequence_number, content_item_id)
    values
        (p_multipart_id, v_max_num + 1, p_content_item_id);

	return v_max_num + 1;
end;
$_$;


--
-- Name: acs_mail_multipart__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_multipart__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_multipart_id		alias for $1;
begin
	perform acs_mail_gc_object__delete( p_multipart_id );

    return 1;
end;
$_$;


--
-- Name: acs_mail_multipart__multipart_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_multipart__multipart_p(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
	p_object_id				alias for $1;
    v_check_multipart_id    integer;
begin
	select count(multipart_id) into v_check_multipart_id
      from acs_mail_multiparts
	  where multipart_id = p_object_id;

    if v_check_multipart_id <> 0 then
        return 't';
    else
        return 'f';
    end if;
end;
$_$;


--
-- Name: acs_mail_multipart__new(integer, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_multipart__new(integer, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_multipart_id		alias for $1;    -- default null,
	p_multipart_kind	alias for $2;
    p_object_type		alias for $3;    -- default acs_mail_multipart
    p_creation_date		alias for $4;    -- default now()
    p_creation_user		alias for $5;    -- default null
    p_creation_ip		alias for $6;    -- default null
    p_context_id		alias for $7;    -- default null
    v_object_id			integer;
begin
    v_object_id := acs_mail_gc_object__new (
		p_multipart_id,		-- gc_object_id 
		p_object_type,		-- object_type 
		p_creation_date,	-- creation_date 
		p_creation_user,	-- creation_user 
		p_creation_ip,		-- creation_ip 
		p_context_id		-- context_id 
    );
	
	insert into acs_mail_multiparts 
	 (multipart_id, multipart_kind)
	values 
	 (v_object_id, p_multipart_kind);

    return v_object_id;
end;
$_$;


--
-- Name: acs_mail_nt__cancel_request(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_nt__cancel_request(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_message_id		alias for $1;
begin
	perform acs_mail_queue_message__delete ( p_message_id );
	return 0;
end;$_$;


--
-- Name: acs_mail_nt__expand_requests(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_nt__expand_requests() RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	raise EXCEPTION '-20000: Procedure no longer supported.';
	return 0;
end;$$;


--
-- Name: acs_mail_nt__post_request(integer, integer, boolean, character varying, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_nt__post_request(integer, integer, boolean, character varying, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_party_from		alias for $1;
	p_party_to			alias for $2;
	p_expand_group		alias for $3;	-- default 'f'
	p_subject			alias for $4;
	p_message			alias for $5;
	p_max_retries		alias for $6;	-- default 0
	v_header_from		acs_mail_bodies.header_from%TYPE;
	v_header_to			acs_mail_bodies.header_to%TYPE;
	v_body_id			acs_mail_bodies.body_id%TYPE;
	v_item_id			cr_items.item_id%TYPE;
	v_revision_id		cr_revisions.revision_id%TYPE;
	v_message_id		acs_mail_queue_messages.message_id%TYPE;
	v_header_to_rec		record;
	v_creation_user		acs_objects.creation_user%TYPE;
begin
	if p_max_retries <> 0 then
	   raise EXCEPTION ' -20000: max_retries parameter not implemented.';
	end if;

	-- get the sender email address
	select max(email) into v_header_from from parties where party_id = p_party_from;

	-- if sender address is null, then use site default OutgoingSender
	if v_header_from is null then
	   	select apm__get_value(package_id, 'OutgoingSender') into v_header_from
		from apm_packages where package_key='acs-kernel';
	end if;

	-- make sure that this party is in users table. If not, let creation_user
	-- be null to prevent integrity constraint violations on acs_objects
	select max(user_id) into v_creation_user 
      from users where user_id = p_party_from;

	-- get the recipient email address
	select max(email) into v_header_to from parties where party_id = p_party_to;

	-- do not let any of these addresses be null
	if v_header_from is null or v_header_to is null then
	   raise EXCEPTION ' -20000: acs_mail_nt: cannot sent email to blank address or from blank address.';
	end if;

	-- create a mail body with empty content

	select acs_mail_body__new (
		null,				   -- p_body_id
		null,				   -- p_body_reply_to
		p_party_from,		   -- p_body_from
		now(),				   -- p_body_date
		null,				   -- p_header_message_id
		null,				   -- p_header_reply_to
		p_subject,			   -- p_header_subject
		null,				   -- p_header_from
		null,				   -- p_header_to
		null,				   -- p_content_item_id
		'acs_mail_body',	   -- p_object_type
		now(),				   -- p_creation_date
		v_creation_user,	   -- p_creation_user
		null,				   -- p_creation_ip
		null				   -- p_context_id
	) into v_body_id;

	-- create a CR item to stick p_message into

	select content_item__new(
        'acs-mail message' || v_body_id,	-- new__name
        null,					-- new__parent_id
        p_subject,				-- new__title
        null,					-- new__description
        p_message				-- new__text
	) into v_item_id;

	-- content_item__new makes a CR revision. We need to get that revision
	-- and make it live

	select content_item__get_latest_revision (v_item_id) into v_revision_id ;
	perform content_item__set_live_revision ( v_revision_id );

	-- set the content of the message
	perform acs_mail_body__set_content_object( v_body_id, v_item_id );

	-- queue the message

	select acs_mail_queue_message__new (
		null,					-- p_mail_link_id
		v_body_id,				-- p_body_id
		null,					-- p_context_id
		now(),					-- p_creation_date
		v_creation_user,		-- p_creation_user
		null,					-- p_creation_ip
		'acs_mail_link'		-- p_object_type
	) into v_message_id;

	-- now put the message into the outgoing queue
	-- i know this seems redundant, but that's the way it was built
	-- the idea is that you put a generic message into the main queue
	-- without from or to address, and then insert a copy of the message
	-- into the outgoing_queue with the specific from and to address

    if p_expand_group = 'f' then
		insert into acs_mail_queue_outgoing
		( message_id, envelope_from, envelope_to )
		values
		( v_message_id, v_header_from, v_header_to );

	else
		-- expand the group
		-- FIXME: need to check if this is a group and if there are members
		--        if not, do we need to notify sender?

		for v_header_to_rec in 
			select email from parties p 
			where party_id in (select member_id from group_approved_member_map 
								where group_id = p_party_to) loop

			insert into acs_mail_queue_outgoing
			( message_id, envelope_from, envelope_to )
			values
			( v_message_id, v_header_from, v_header_to_rec.email );
		end loop;

    end if;

	return v_message_id;
end;$_$;


--
-- Name: acs_mail_nt__post_request(integer, integer, character varying, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_nt__post_request(integer, integer, character varying, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_party_from		alias for $1;
	p_party_to			alias for $2;
	p_subject			alias for $3;
	p_message			alias for $4;
begin
	return acs_mail_nt__post_request(
		p_party_from,		-- p_party_from
		p_party_to,			-- p_party_to
		'f',				-- p_expand_group
		p_subject,			-- p_subject
		p_message,			-- p_message
		0					-- p_max_retries
	);
end;$_$;


--
-- Name: acs_mail_nt__process_queue(character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_nt__process_queue(character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_host		alias for $1;
	p_port		alias for $2;	-- default 25
begin
	raise EXCEPTION '-20000: Procedure no longer supported - see packages/acs-mail/sql/postgresql/acs-mail-nt-create.sql.';

	return 0;
end;$_$;


--
-- Name: acs_mail_nt__schedule_process(numeric, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_nt__schedule_process(numeric, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_interval	alias for $1;
	p_host		alias for $2;
	p_port		alias for $3;	-- default 25
begin
	raise EXCEPTION '-20000: Procedure no longer supported - see packages/acs-mail/sql/postgresql/acs-mail-nt-create.sql. ';
	return 0;
end;$_$;


--
-- Name: acs_mail_nt__update_requests(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_nt__update_requests() RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	raise EXCEPTION '-20000: Procedure no longer supported.';
	return 0;
end;$$;


--
-- Name: acs_mail_queue_message__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_queue_message__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_message_id		alias for $1;
begin
	perform acs_mail_link__delete( p_message_id );

    return 1;
end;$_$;


--
-- Name: acs_mail_queue_message__new(integer, integer, integer, timestamp with time zone, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_mail_queue_message__new(integer, integer, integer, timestamp with time zone, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_mail_link_id			alias for $1;    -- default null
	p_body_id				alias for $2;
	p_context_id			alias for $3;    -- default null
	p_creation_date			alias for $4;    -- default now()
	p_creation_user			alias for $5;    -- default null
	p_creation_ip			alias for $6;    -- default null
	p_object_type			alias for $7;    -- default acs_mail_link
    v_mail_link_id			acs_mail_links.mail_link_id%TYPE;
begin
    v_mail_link_id := acs_mail_link__new (
		p_mail_link_id,			-- mail_link_id 
		p_body_id,				-- body_id 
		p_context_id,			-- context_id 
		p_creation_date,		-- creation_date 
		p_creation_user,		-- creation_user 
		p_creation_ip,			-- creation_ip 
		p_object_type			-- object_type 
    );

    insert into acs_mail_queue_messages 
	 ( message_id )
    values 
	 ( v_mail_link_id );

    return v_mail_link_id;
end;$_$;


--
-- Name: acs_message__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id    alias for $1;
begin
    delete from acs_messages where message_id = p_message_id;
    perform content_item__delete(p_message_id);
    return 1;
end;$_$;


--
-- Name: acs_message__delete_extlink(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__delete_extlink(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_extlink_id    alias for $1;
begin
    perform content_extlink__delete(p_extlink_id);

	return 0;
end;$_$;


--
-- Name: acs_message__delete_file(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__delete_file(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_file_id  alias for $1;
begin
    perform content_item__delete(p_file_id);       
    return 1;
end;$_$;


--
-- Name: acs_message__delete_image(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__delete_image(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_image_id  alias for $1;
begin
    perform image__delete(p_image_id);

    return 1;
end;$_$;


--
-- Name: acs_message__edit(integer, character varying, character varying, character varying, text, integer, timestamp with time zone, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__edit(integer, character varying, character varying, character varying, text, integer, timestamp with time zone, integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id    alias for $1;
    p_title         alias for $2;    -- default null
    p_description   alias for $3;    -- default null
    p_mime_type     alias for $4;    -- default 'text/plain'
    p_text          alias for $5;    -- default null
    p_data          alias for $6;    -- default null
    p_creation_date alias for $7;    -- default sysdate
    p_creation_user alias for $8;    -- default null
    p_creation_ip   alias for $9;    -- default null
    p_is_live       alias for $10;   -- default 't'
    v_revision_id cr_revisions.revision_id%TYPE;
begin
    -- create a new revision using whichever call is appropriate
    if p_data is not null then
		-- need to take care of blob?
        v_revision_id := content_revision__new (
            p_message_id,			-- item_id        
            p_title,				-- title          
            p_description,			-- description    
            p_data,					-- data           
            p_mime_type,			-- mime_type      
            p_creation_date,		-- creation_date  
            p_creation_user,		-- creation_user  
            p_creation_ip			-- creation_ip    
        );
    else if p_title is not null or p_text is not null then
        v_revision_id := content_revision__new (
            p_title,				-- title          
            p_description,			-- description    
			now(),					-- publish_date
            p_mime_type,			-- mime_type      
			null,					-- nls_language
            p_text,					-- text           
            p_message_id,			-- item_id        
			null,					-- revision_id
            p_creation_date,		-- creation_date  
            p_creation_user,		-- creation_user  
            p_creation_ip			-- creation_ip    
        );      
    end if;
	end if;

    -- test for auto approval of revision   
    if p_is_live then 
        perform content_item__set_live_revision(v_revision_id);
    end if;

    return v_revision_id;
end;$_$;


--
-- Name: acs_message__edit_extlink(integer, character varying, character varying, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__edit_extlink(integer, character varying, character varying, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_extlink_id   alias for $1;
    p_url          alias for $2;
    p_label        alias for $3;    -- default null
    p_description  alias for $4;    --  default null
    v_is_extlink   boolean;
begin
    v_is_extlink := content_extlink__is_extlink(p_extlink_id);
    if v_is_extlink = 't' then
        update cr_extlinks
        set url = p_url,
            label = p_label,
            description = p_description
        where extlink_id = p_extlink_id;
    end if;
    return 0;
end;$_$;


--
-- Name: acs_message__edit_file(integer, character varying, text, character varying, integer, timestamp with time zone, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__edit_file(integer, character varying, text, character varying, integer, timestamp with time zone, integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_file_id       alias for $1;
    p_title         alias for $2;    -- default null
    p_description   alias for $3;    -- default null
    p_mime_type     alias for $4;    -- default 'text/plain'
    p_data          alias for $5;    -- default null
    p_creation_date alias for $6;    -- default sysdate
    p_creation_user alias for $7;    -- default null
    p_creation_ip   alias for $8;    -- default null
    p_is_live       alias for $9;    -- default 't'
    v_revision_id  cr_revisions.revision_id%TYPE;
begin
    v_revision_id := content_revision__new (
        p_title,				-- title         
        p_description,
        current_timestamp,
        p_mime_type,			-- mime_type     
        NULL,
        p_data,				-- data          
        p_file_id,				-- item_id       
        NULL,
        p_creation_date,		-- creation_date 
        p_creation_user,		-- creation_user 
        p_creation_ip			-- creation_ip   
    );

    -- test for auto approval of revision
    if p_is_live then 
        perform content_item__set_live_revision(v_revision_id);
    end if;

    return v_revision_id;
end;$_$;


--
-- Name: acs_message__edit_image(integer, character varying, text, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__edit_image(integer, character varying, text, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_image_id       alias for $1;
    p_title          alias for $2;    -- default null
    p_description    alias for $3;    -- default null
    p_mime_type      alias for $4;    -- default 'text/plain'
    p_data           alias for $5;    -- default null
    p_width          alias for $6;    -- default null
    p_height         alias for $7;    -- default null
    p_creation_date  alias for $8;    -- default sysdate
    p_creation_user  alias for $9;    -- default null
    p_creation_ip    alias for $10;   -- default null
    p_is_live        alias for $11;   -- default 't'
    v_revision_id  cr_revisions.revision_id%TYPE;
begin
		-- not sure which __new to use
    v_revision_id := content_revision__new (
         p_title,             -- title         
         NULL,                -- description
         current_timestamp,   -- publish_date
         p_mime_type,         -- mime_type     
         NULL,                -- nls_language
         p_data,              -- data          
         p_image_id,          -- item_id       
         NULL,                -- revision_id
         p_creation_date,     -- creation_date 
         p_creation_user,     -- creation_user 
         p_creation_ip        -- creation_ip   
    );      

    -- insert new width and height values
    -- XXX fix after image.new exists
    insert into images
        (image_id, width, height)
    values
        (v_revision_id, p_width, p_height);

    -- test for auto approval of revision   
    if p_is_live then 
        perform content_item__set_live_revision(v_revision_id);
    end if;

    return v_revision_id;
end;$_$;


--
-- Name: acs_message__first_ancestor(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__first_ancestor(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id alias for $1;
    v_message_id acs_messages.message_id%TYPE;
    v_ancestor_sk varbit;
begin
    select tree_ancestor_key(tree_sortkey, 1) into v_ancestor_sk
      from acs_messages
     where message_id = p_message_id;

    select message_id into v_message_id
      from acs_messages
     where tree_sortkey = v_ancestor_sk;

    return v_message_id;
end;$_$;


--
-- Name: acs_message__message_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__message_p(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id          alias for $1;
    v_check_message_id  integer;
begin
    select count(message_id) into v_check_message_id
        from acs_messages where message_id = p_message_id;

    if v_check_message_id <> 0 then
        return 't';
    else
        return 'f';
    end if;
end;$_$;


--
-- Name: acs_message__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id   alias for $1;
    v_message_name   cr_revisions.title%TYPE;
begin
    select title into v_message_name
        from acs_messages_all
        where message_id = p_message_id;
    return v_message_name;
end;$_$;


--
-- Name: acs_message__new(integer, integer, timestamp with time zone, integer, character varying, character varying, character varying, character varying, text, integer, integer, integer, integer, character varying, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__new(integer, integer, timestamp with time zone, integer, character varying, character varying, character varying, character varying, text, integer, integer, integer, integer, character varying, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_message_id    alias for $1;  --default null,
        p_reply_to      alias for $2;  --default null,
        p_sent_date     alias for $3;  --default sysdate,
        p_sender        alias for $4;  --default null,
        p_rfc822_id     alias for $5;  --default null,
        p_title         alias for $6;  --default null,
        p_description   alias for $7;  --default null,
        p_mime_type     alias for $8;  --default 'text/plain',
        p_text          alias for $9;  --default null,
        p_data          alias for $10; --default null,
        p_parent_id     alias for $11; --default 0,
        p_context_id    alias for $12;
        p_creation_date timestamptz := current_timestamp;  -- alias for $13 --default sysdate,
        p_creation_user alias for $13; --default null,
        p_creation_ip   alias for $14; --default null,
        p_object_type   alias for $15; --default 'acs_message',
        p_is_live       alias for $16; --default 't'
        v_message_id   acs_messages.message_id%TYPE;
        v_rfc822_id    acs_messages.rfc822_id%TYPE;
        v_revision_id  cr_revisions.revision_id%TYPE;
		v_system_url   varchar;
		v_domain_name  varchar;
		v_idx		   integer;
    begin
        -- generate a message id now so we can get an rfc822 message-id
        if p_message_id is null then
            select acs_object_id_seq.nextval into v_message_id;
        else
            v_message_id := p_message_id;
        end if;

        -- need to make this mandatory also - jg
        -- this needs to be fixed up, but Oracle doesn't give us a way
        -- to get the FQDN

	-- vk: get SystemURL parameter and use it to extract domain name
         select apm__get_value(package_id, 'SystemURL') into v_system_url
          from apm_packages where package_key='acs-kernel';
		v_idx := position('http://' in v_system_url);
		v_domain_name := trim (substr(v_system_url, v_idx + 7));

        if p_rfc822_id is null then
           v_rfc822_id := current_date || '.' || v_message_id || '@' ||
               v_domain_name || '.hate';
        else
            v_rfc822_id := p_rfc822_id;
        end if;

        v_message_id := content_item__new (
            v_rfc822_id,				  -- name           
            p_parent_id,				  -- parent_id      
            p_message_id,				  -- item_id        
            null,						  -- locale
            p_creation_date,			  -- creation_date  
            p_creation_user,			  -- creation_user  
            p_context_id,				  -- context_id     
            p_creation_ip,				  -- creation_ip    
            p_object_type,				  -- item_subtype   
            'acs_message_revision',	  -- content_type   
            null,						  -- title
            null,						  -- description
            'text/plain',				  -- mime_type
            null,						  -- nls_language
            null,						  -- text
            'text'					  -- storage_type
        );

        insert into acs_messages 
            (message_id, reply_to, sent_date, sender, rfc822_id)
        values 
            (v_message_id, p_reply_to, p_sent_date, p_sender, v_rfc822_id);

        -- create an initial revision for the new message
        v_revision_id := acs_message__edit (
            v_message_id,				   -- message_id     
            p_title,					   -- title          
            p_description,				   -- description    
            p_mime_type,				   -- mime_type      
            p_text,						   -- text           
            p_data,						   -- data           
            p_creation_date,			   -- creation_date  
            p_creation_user,			   -- creation_user  
            p_creation_ip,				   -- creation_ip    
            p_is_live					   -- is_live        
        );

        return v_message_id;
end;$_$;


--
-- Name: acs_message__new_extlink(character varying, integer, character varying, character varying, text, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__new_extlink(character varying, integer, character varying, character varying, text, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_name           alias for $1;    -- default null
    p_extlink_id     alias for $2;    -- default null
    p_url            alias for $3;   
    p_label          alias for $4;    -- default null
    p_description    alias for $5;    -- default null
    p_parent_id      alias for $6;
    p_creation_date  alias for $7;    -- default sysdate
    p_creation_user  alias for $8;    -- default null
    p_creation_ip    alias for $9;    -- default null
    v_extlink_id  cr_extlinks.extlink_id%TYPE;
begin
    v_extlink_id := content_extlink__new (
         p_name,				-- name          
         p_url,					-- url           
         p_label,				-- label         
         p_description,			-- description   
         p_parent_id,			-- parent_id     
         p_extlink_id,			-- extlink_id    
         p_creation_date,		-- creation_date 
         p_creation_user,		-- creation_user 
         p_creation_ip			-- creation_ip   
    );

	return v_extlink_id;
end;$_$;


--
-- Name: acs_message__new_file(integer, integer, character varying, character varying, text, character varying, integer, timestamp with time zone, integer, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__new_file(integer, integer, character varying, character varying, text, character varying, integer, timestamp with time zone, integer, character varying, boolean, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id    alias for $1;
    p_file_id       alias for $2;    -- default null
    p_file_name     alias for $3;
    p_title         alias for $4;    -- default null
    p_description   alias for $5;    -- default null
    p_mime_type     alias for $6;    -- default 'text/plain'
    p_data          alias for $7;    -- default null
    p_creation_date alias for $8;    -- default sysdate
    p_creation_user alias for $9;    -- default null
    p_creation_ip   alias for $10;   -- default null
    p_is_live       alias for $11;   -- default 't'
    p_storage_type  alias for $12;   -- default 'file'
    v_file_id      cr_items.item_id%TYPE;
    v_revision_id  cr_revisions.revision_id%TYPE;
begin
    v_file_id := content_item__new (
        p_file_name,			   -- name           
        p_message_id,			   -- parent_id      
        p_file_id,				   -- item_id        
        null,					   -- locale
        p_creation_date,		   -- creation_date  
        p_creation_user,		   -- creation_user  
        null,					   -- context_id
        p_creation_ip,			   -- creation_ip    
        'content_item',		   -- item_subtype
        'content_revision',		   -- content_type
        null,					   -- title
        null,					   -- description
        'text/plain',			   -- mime_type
        null,					   -- nls_language
        null,					   -- text
	p_storage_type				   -- storage_type
    );

    -- create an initial revision for the new attachment
    v_revision_id := acs_message__edit_file (
         v_file_id,				-- file_id        
         p_title,				-- title          
         p_description,			-- description    
         p_mime_type,			-- mime_type      
         p_data,				-- data        
         p_creation_date,		-- creation_date  
         p_creation_user,		-- creation_user  
         p_creation_ip,			-- creation_ip    
         p_is_live				-- is_live        
    );

    return v_file_id;
end;$_$;


--
-- Name: acs_message__new_image(integer, integer, character varying, character varying, text, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__new_image(integer, integer, character varying, character varying, text, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id     alias for $1;
    p_image_id       alias for $2;    -- default null
    p_file_name      alias for $3;
    p_title          alias for $4;    -- default null
    p_description    alias for $5;    -- default null
    p_mime_type      alias for $6;    -- default 'text/plain'
    p_data           alias for $7;    -- default null
    p_width          alias for $8;    -- default null
    p_height         alias for $9;    -- default null
    p_creation_date  alias for $10;   -- default sysdate
    p_creation_user  alias for $11;   -- default null
    p_creation_ip    alias for $12;   -- default null
    p_is_live        alias for $13;   -- default 't'
    p_storage_type   alias for $14;   -- default 'file'
    v_image_id     cr_items.item_id%TYPE;
    v_revision_id  cr_revisions.revision_id%TYPE;
begin
    v_image_id := content_item__new (
         p_file_name,				-- name          
         p_message_id,				-- parent_id     
         p_image_id,				-- item_id       
         null,						-- locale
         p_creation_date,			-- creation_date 
         p_creation_user,			-- creation_user 
         null,						-- context_id
         p_creation_ip,				-- creation_ip
		 'content_item',			-- item_subtype
		 'content_revision',		-- content_type
		 null,						-- title
		 null,						-- description
		 'text/plain',			-- mime_type
		 null,						-- nls_language
		 null,						-- text
		 'file'					-- storage_type   
    );

    -- create an initial revision for the new attachment
    v_revision_id := acs_message__edit_image (
         v_image_id,				-- image_id      
         p_title,					-- title         
         p_description,				-- description   
         p_mime_type,				-- mime_type     
         p_data,					-- data       
         p_width,					-- width         
         p_height,					-- height        
         p_creation_date,			-- creation_date 
         p_creation_user,			-- creation_user 
         p_creation_ip,				-- creation_ip   
         p_is_live					-- is_live       
    );

    return v_image_id;
end;$_$;


--
-- Name: acs_message__send(integer, character varying, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__send(integer, character varying, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id    alias for $1;
    p_to_address    alias for $2;
    p_grouping_id   alias for $3;    -- default null
    p_wait_until    alias for $4;    -- default sysdate
    v_wait_until timestamptz;
begin
    v_wait_until := coalesce(p_wait_until, current_timestamp);
    insert into acs_messages_outgoing
        (message_id, to_address, grouping_id, wait_until)
    values
        (p_message_id, p_to_address, p_grouping_id, v_wait_until);
    return 1;
end;$_$;


--
-- Name: acs_message__send(integer, integer, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message__send(integer, integer, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id    alias for $1;
    p_recipient_id  alias for $2;
    p_grouping_id   alias for $3;    -- default null
    p_wait_until    alias for $4;    -- default sysdate
    v_wait_until timestamptz;
begin
    v_wait_until := coalesce (p_wait_until, current_timestamp);
    insert into acs_messages_outgoing
        (message_id, to_address, grouping_id, wait_until)
    select p_message_id, p.email, p_grouping_id, v_wait_until
        from parties p
        where p.party_id = p_recipient_id;
    return 1;
end;$_$;


--
-- Name: acs_message_get_tree_sortkey(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message_get_tree_sortkey(integer) RETURNS bit varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_message_id    alias for $1;
begin
  return tree_sortkey from acs_messages where message_id = p_message_id;
end;$_$;


--
-- Name: acs_message_insert_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk     varbit  default null;
        v_max_value     integer;
begin
	if new.reply_to is null then
	    select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
              from acs_messages
             where reply_to is null;
        else
	    select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
              from acs_messages
             where reply_to = new.reply_to;

            select tree_sortkey into v_parent_sk 
              from acs_messages
             where message_id = new.reply_to;
        end if;

        new.tree_sortkey := tree_next_key(v_parent_sk, v_max_value);

        return new;

end;$$;


--
-- Name: acs_message_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_message_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk     varbit default null;
        v_max_value     integer;
        v_rec           record;
        clr_keys_p      boolean default 't';
begin
        if new.message_id = old.message_id and 
           ((new.reply_to = old.reply_to) or 
            (new.reply_to is null and old.reply_to is null)) then

           return new;

        end if;

        for v_rec in select message_id, reply_to
                     from acs_messages
                     where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey)
                     order by tree_sortkey
        LOOP
            if clr_keys_p then
               update acs_messages set tree_sortkey = null
               where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);
               clr_keys_p := 'f';
            end if;
            
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
              from acs_messages
              where reply_to = v_rec.reply_to;

            select tree_sortkey into v_parent_sk 
              from acs_messages 
             where message_id = v_rec.reply_to;

            update acs_messages
               set tree_sortkey = tree_next_key(v_parent_sk, v_max_value)
             where message_id = v_rec.message_id;

        end LOOP;

        return new;

end;$$;


--
-- Name: acs_object__check_context_index(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__check_context_index(integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  check_context_index__object_id              alias for $1;  
  check_context_index__ancestor_id            alias for $2;  
  check_context_index__n_generations          alias for $3;  
  n_rows                                      integer;       
  n_gens                                      integer;       
begin
   -- Verify that this row exists in the index.
   if check_context_index__object_id is null or check_context_index__ancestor_id is null then
	raise exception 'object_id or ancestor_id is null in acs_object__check_context_index';
   end if;	
   select case when count(*) = 0 then 0 else 1 end into n_rows
   from acs_object_context_index
   where object_id = check_context_index__object_id
   and ancestor_id = check_context_index__ancestor_id;

   if n_rows = 1 then
     -- Verify that the count is correct.
     select n_generations into n_gens
     from acs_object_context_index
     where object_id = check_context_index__object_id
     and ancestor_id = check_context_index__ancestor_id;

     if n_gens != check_context_index__n_generations then
       PERFORM acs_log__error('acs_object.check_representation', 
                              'Ancestor ' ||
                     check_context_index__ancestor_id || ' of object ' || 
                     check_context_index__object_id ||
		     ' reports being generation ' || n_gens ||
		     ' when it is actually generation ' || 
                     check_context_index__n_generations ||
		     '.');
       return 'f';
     else
       return 't';
     end if;
   else
     PERFORM acs_log__error('acs_object.check_representation', 
                            'Ancestor ' ||
                            check_context_index__ancestor_id || 
                            ' of object ' || check_context_index__object_id 
                            || ' is missing an entry in acs_object_context_index.');
     return 'f';
   end if;
  
end;$_$;


--
-- Name: acs_object__check_object_ancestors(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__check_object_ancestors(integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  check_object_ancestors__object_id              alias for $1;  
  check_object_ancestors__ancestor_id            alias for $2;  
  check_object_ancestors__n_generations          alias for $3;  
  check_object_ancestors__context_id             acs_objects.context_id%TYPE;
  check_object_ancestors__security_inherit_p     acs_objects.security_inherit_p%TYPE;
  n_rows                                         integer;       
  n_gens                                         integer;       
  result                                         boolean;       
begin
   -- OBJECT_ID is the object we are verifying
   -- ANCESTOR_ID is the current ancestor we are tracking
   -- N_GENERATIONS is how far ancestor_id is from object_id

   -- Note that this function is only supposed to verify that the
   -- index contains each ancestor for OBJECT_ID. It doesn''t
   -- guarantee that there aren''t extraneous rows or that
   -- OBJECT_ID''s children are contained in the index. That is
   -- verified by seperate functions.

   result := 't';

   -- Grab the context and security_inherit_p flag of the current
   -- ancestor''s parent.
   select context_id, security_inherit_p 
   into check_object_ancestors__context_id, 
        check_object_ancestors__security_inherit_p
   from acs_objects
   where object_id = check_object_ancestors__ancestor_id;

   if check_object_ancestors__ancestor_id = 0 then
     if check_object_ancestors__context_id is null then
       result := 't';
     else
       -- This can be a constraint, can''t it?
       PERFORM acs_log__error('acs_object.check_representation',
                     'Object 0 doesn''t have a null context_id');
       result := 'f';
     end if;
   else
     if check_object_ancestors__context_id is null or 
        check_object_ancestors__security_inherit_p = 'f' 
     THEN
       check_object_ancestors__context_id := 0;
     end if;

     if acs_object__check_context_index(check_object_ancestors__object_id, 
                                        check_object_ancestors__ancestor_id, 
                                        check_object_ancestors__n_generations) = 'f' then
       result := 'f';
     end if;

     if acs_object__check_object_ancestors(check_object_ancestors__object_id, 
                                           check_object_ancestors__context_id,
	                      check_object_ancestors__n_generations + 1) = 'f' then
       result := 'f';
     end if;
   end if;

   return result;
  
end;$_$;


--
-- Name: acs_object__check_object_descendants(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__check_object_descendants(integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  object_id              alias for $1;  
  descendant_id          alias for $2;  
  n_generations          alias for $3;  
  result                 boolean;     
  obj                    record;  
begin
   -- OBJECT_ID is the object we are verifying.
   -- DESCENDANT_ID is the current descendant we are tracking.
   -- N_GENERATIONS is how far the current DESCENDANT_ID is from
   -- OBJECT_ID.

   -- This function will verfy that each actualy descendant of
   -- OBJECT_ID has a row in the index table. It does not check that
   -- there aren't extraneous rows or that the ancestors of OBJECT_ID
   -- are maintained correctly.

   result := 't';

   -- First verify that OBJECT_ID and DESCENDANT_ID are actually in
   -- the index.
   if acs_object__check_context_index(descendant_id, object_id, n_generations) = 'f' then
     result := 'f';
   end if;

   -- For every child that reports inheriting from OBJECT_ID we need to call
   -- ourselves recursively.
   for obj in  select *
	       from acs_objects
	       where context_id = descendant_id
	       and security_inherit_p = 't' loop
     if acs_object__check_object_descendants(object_id, obj.object_id,
       n_generations + 1) = 'f' then
       result := 'f';
     end if;
   end loop;

   return result;
  
end;$_$;


--
-- Name: acs_object__check_path(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__check_path(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  check_path__object_id              alias for $1;  
  check_path__ancestor_id            alias for $2;  
  check_path__context_id             acs_objects.context_id%TYPE;
  check_path__security_inherit_p     acs_objects.security_inherit_p%TYPE;
begin
   if check_path__object_id is null or check_path__ancestor_id then 
	raise exception 'acs_object__check_path called with null object_id or ancestor_id';
   end if;
   if check_path__object_id = check_path__ancestor_id then
     return 't';
   end if;

   select context_id, security_inherit_p 
   into check_path__context_id, check_path__security_inherit_p
   from acs_objects
   where object_id = check_path__object_id;

   -- we should be able to handle the case where check_path fails 
   -- should we not?

   if check_path__object_id = 0 and check_path__context_id is null then 
      return 'f';
   end if;

   if check_path__context_id is null or check_path__security_inherit_p = 'f' 
   then
     check_path__context_id := 0;
   end if;

   return acs_object__check_path(check_path__context_id, 
                                 check_path__ancestor_id);
  
end;$_$;


--
-- Name: acs_object__check_representation(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__check_representation(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  check_representation__object_id              alias for $1;  
  result                                       boolean;       
  check_representation__object_type            acs_objects.object_type%TYPE;
  n_rows                                       integer;    
  v_rec                                        record;  
  row                                          record; 
begin
   if check_representation__object_id is null then 
	raise exception 'acs_object__check_representation called for null object_id';
   end if;

   result := 't';
   PERFORM acs_log__notice('acs_object.check_representation',
                  'Running acs_object.check_representation on object_id = ' 
                  || check_representation__object_id || '.');

   select object_type into check_representation__object_type
   from acs_objects
   where object_id = check_representation__object_id;

   PERFORM acs_log__notice('acs_object.check_representation',
                  'OBJECT STORAGE INTEGRITY TEST');

   for v_rec in  select t.object_type, t.table_name, t.id_column
             from acs_object_type_supertype_map m, acs_object_types t
	     where m.ancestor_type = t.object_type
	     and m.object_type = check_representation__object_type
	     union
	     select object_type, table_name, id_column
	     from acs_object_types
	     where object_type = check_representation__object_type 
     LOOP

        for row in execute 'select case when count(*) = 0 then 0 else 1 end as n_rows from ' || quote_ident(v_rec.table_name) || ' where ' || quote_ident(v_rec.id_column) || ' = ' || check_representation__object_id
        LOOP
            n_rows := row.n_rows;
            exit;
        end LOOP;

        if n_rows = 0 then
           result := 'f';
           PERFORM acs_log__error('acs_object.check_representation',
                     'Table ' || v_rec.table_name || 
                     ' (primary storage for ' ||
		     v_rec.object_type || 
                     ') doesn''t have a row for object ' ||
		     check_representation__object_id || ' of type ' || 
                     check_representation__object_type || '.');
        end if;

   end loop;

   PERFORM acs_log__notice('acs_object.check_representation',
                  'OBJECT CONTEXT INTEGRITY TEST');

   if acs_object__check_object_ancestors(check_representation__object_id, 
                                         check_representation__object_id, 0) = 'f' then
     result := 'f';
   end if;

   if acs_object__check_object_descendants(check_representation__object_id, 
                                           check_representation__object_id, 0) = 'f' then
     result := 'f';
   end if;
   for row in  select object_id, ancestor_id, n_generations
	       from acs_object_context_index
	       where object_id = check_representation__object_id
	       or ancestor_id = check_representation__object_id 
   LOOP
     if acs_object__check_path(row.object_id, row.ancestor_id) = 'f' then
       PERFORM acs_log__error('acs_object.check_representation',
		     'acs_object_context_index contains an extraneous row: '
                     || 'object_id = ' || row.object_id || 
                     ', ancestor_id = ' || row.ancestor_id || 
                     ', n_generations = ' || row.n_generations || '.');
       result := 'f';
     end if;
   end loop;

   PERFORM acs_log__notice('acs_object.check_representation',
		  'Done running acs_object.check_representation ' || 
		  'on object_id = ' || check_representation__object_id || '.');

   return result;
  
end;$_$;


--
-- Name: acs_object__default_name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__default_name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  default_name__object_id   alias for $1;  
  object_type_pretty_name   acs_object_types.pretty_name%TYPE;
begin
  select ot.pretty_name
  into object_type_pretty_name
  from acs_objects o, acs_object_types ot
  where o.object_id = default_name__object_id
  and o.object_type = ot.object_type;

  return object_type_pretty_name || ' ' || default_name__object_id;
  
end;$_$;


--
-- Name: acs_object__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__object_id              alias for $1;  
  obj_type                       record;
begin
  
  -- Delete dynamic/generic attributes
  delete from acs_attribute_values where object_id = delete__object_id;

  -- Delete direct permissions records.
  delete from acs_permissions where object_id = delete__object_id;

  -- select table_name, id_column
  --  from acs_object_types
  --  start with object_type = (select object_type
  --                              from acs_objects o
  --                             where o.object_id = delete__object_id)
  --  connect by object_type = prior supertype

  -- There was a gratuitous join against the objects table here,
  -- probably a leftover from when this was a join, and not a subquery.
  -- Functionally, this was working, but time taken was O(n) where n is the 
  -- number of objects. OUCH. Fixed. (ben)
  for obj_type
  in select o2.table_name, o2.id_column
        from acs_object_types o1, acs_object_types o2
       where o1.object_type = (select object_type
                               from acs_objects o
                               where o.object_id = delete__object_id)
         and o1.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey)
    order by o2.tree_sortkey desc
  loop
    -- Delete from the table.

    -- DRB: I removed the quote_ident calls that DanW originally included
    -- because the table names appear to be stored in upper case.  Quoting
    -- causes them to not match the actual lower or potentially mixed-case
    -- table names.  We will just forbid squirrely names that include quotes.
-- daveB
-- ETP is creating a new object, but not a table, although it does specify a
-- table name, so we need to check if the table exists. Wp-slim does this too

    if table_exists(obj_type.table_name) then
      execute 'delete from ' || obj_type.table_name ||
          ' where ' || obj_type.id_column || ' =  ' || delete__object_id;
    end if;
  end loop;

  return 0; 
end;$_$;


--
-- Name: acs_object__get_attr_storage_column(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__get_attr_storage_column(text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
        v_vals  alias for $1;
        v_idx   integer;
begin
        v_idx := strpos(v_vals,',');
        if v_idx = 0 or v_vals is null then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_column %',v_vals;
        end if;

        return substr(v_vals,1,v_idx - 1);

end;$_$;


--
-- Name: acs_object__get_attr_storage_sql(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__get_attr_storage_sql(text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
        v_vals  alias for $1;
        v_idx   integer;
        v_tmp   varchar;
begin
        v_idx := strpos(v_vals, ',');

        if v_idx = 0 or v_vals is null then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_sql %',v_vals;
        end if;

        v_tmp := substr(v_vals, v_idx + 1);
        v_idx := strpos(v_tmp, ',');
        if v_idx = 0 then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_sql %',v_vals;
        end if;

        return substr(v_tmp, v_idx + 1);

end;$_$;


--
-- Name: acs_object__get_attr_storage_table(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__get_attr_storage_table(text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
        v_vals  alias for $1;
        v_idx   integer;
        v_tmp   varchar;
begin
        v_idx := strpos(v_vals,',');

        if v_idx = 0 or v_vals is null then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_table %',v_vals;
        end if;

        v_tmp := substr(v_vals,v_idx + 1);
        v_idx := strpos(v_tmp,',');
        if v_idx = 0 then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_table %',v_vals;
        end if;

        return substr(v_tmp,1,v_idx - 1);

end;$_$;


--
-- Name: acs_object__get_attribute(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__get_attribute(integer, character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
  object_id_in           alias for $1;  
  attribute_name_in      alias for $2;  
  v_table_name           varchar(200);  
  v_column               varchar(200);  
  v_key_sql              text; 
  v_return               text; 
  v_storage              text;
  v_rec                  record;
begin

   v_storage := acs_object__get_attribute_storage(object_id_in, attribute_name_in);

   v_column     := acs_object__get_attr_storage_column(v_storage);
   v_table_name := acs_object__get_attr_storage_table(v_storage);
   v_key_sql    := acs_object__get_attr_storage_sql(v_storage);

   for v_rec in execute 'select ' || quote_ident(v_column) || '::text as return from ' || quote_ident(v_table_name) || ' where ' || v_key_sql
      LOOP
        v_return := v_rec.return;
        exit;
   end loop;
   if not FOUND then 
       return null;
   end if;

   return v_return;

end;$_$;


--
-- Name: acs_object__get_attribute_storage(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__get_attribute_storage(integer, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
declare
  object_id_in           alias for $1;  
  attribute_name_in      alias for $2;  

--  these three are the out variables
  v_column               varchar;  
  v_table_name           varchar;  
  v_key_sql              text;
  
  v_object_type          acs_attributes.object_type%TYPE;
  v_static               acs_attributes.static_p%TYPE;
  v_attr_id              acs_attributes.attribute_id%TYPE;
  v_storage              acs_attributes.storage%TYPE;
  v_attr_name            acs_attributes.attribute_name%TYPE;
  v_id_column            varchar(200);   
  v_sql                  text;  
  v_return               text;  
  v_rec                  record;
begin
   --   select 
   --     object_type, id_column
   --   from
   --     acs_object_types
   --   connect by
   --     object_type = prior supertype
   --   start with
   --     object_type = (select object_type from acs_objects 
   --                    where object_id = object_id_in)

   -- Determine the attribute parameters
   select
     a.attribute_id, a.static_p, a.storage, a.table_name, a.attribute_name,
     a.object_type, a.column_name, t.id_column 
   into 
     v_attr_id, v_static, v_storage, v_table_name, v_attr_name, 
     v_object_type, v_column, v_id_column
   from 
     acs_attributes a,
     (select o2.object_type, o2.id_column
       from acs_object_types o1, acs_object_types o2
      where o1.object_type = (select object_type
                                from acs_objects o
                               where o.object_id = object_id_in)
        and o1.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey)
     ) t
   where   
     a.attribute_name = attribute_name_in
   and
     a.object_type = t.object_type;

   if NOT FOUND then 
      raise EXCEPTION '-20000: No such attribute % for object % in acs_object.get_attribute_storage.', attribute_name_in, object_id_in;
   end if;

   -- This should really be done in a trigger on acs_attributes,
   -- instead of generating it each time in this function

   -- If there is no specific table name for this attribute,
   -- figure it out based on the object type
   if v_table_name is null or v_table_name = '' then

     -- Determine the appropriate table name
     if v_storage = 'generic' then
       -- Generic attribute: table name/column are hardcoded

       v_column := 'attr_value';

       if v_static = 'f' then
         v_table_name := 'acs_attribute_values';
         v_key_sql := '(object_id = ' || object_id_in || ' and ' ||
                      'attribute_id = ' || v_attr_id || ')';
       else
         v_table_name := 'acs_static_attr_values';
         v_key_sql := '(object_type = ''' || v_object_type || ''' and ' ||
                      'attribute_id = ' || v_attr_id || ')';
       end if;

     else
       -- Specific attribute: table name/column need to be retreived
 
       if v_static = 'f' then
         select 
           table_name, id_column 
         into 
           v_table_name, v_id_column
         from 
           acs_object_types 
         where 
           object_type = v_object_type;
         if NOT FOUND then 
            raise EXCEPTION '-20000: No data found for attribute %::% object_id % in acs_object.get_attribute_storage', v_object_type, attribute_name_in, object_id_in;
         end if;
       else
         raise EXCEPTION '-20000: No table name specified for storage specific static attribute %::% object_id % in acs_object.get_attribute_storage.',v_object_type, attribute_name_in, object_id_in;
       end if;
  
     end if;
   else 
     -- There is a custom table name for this attribute.
     -- Get the id column out of the acs_object_tables
     -- Raise an error if not found
     select id_column into v_id_column from acs_object_type_tables
       where object_type = v_object_type 
       and table_name = v_table_name;
       if NOT FOUND then 
          raise EXCEPTION '-20000: No data found for attribute %::% object_id % in acs_object.get_attribute_storage', v_object_type, attribute_name_in, object_id_in;
       end if;
   end if;

   if v_column is null or v_column = '' then

     if v_storage = 'generic' then
       v_column := 'attr_value';
     else
       v_column := v_attr_name;
     end if;

   end if;

   if v_key_sql is null or v_key_sql = '' then
     if v_static = 'f' then   
       v_key_sql := v_id_column || ' = ' || object_id_in ; 
     else
       v_key_sql := v_id_column || ' = ''' || v_object_type || '''';
     end if;
   end if;

   return v_column || ',' || v_table_name || ',' || v_key_sql; 

end;$_$;


--
-- Name: acs_object__initialize_attributes(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__initialize_attributes(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  initialize_attributes__object_id              alias for $1;  
  v_object_type                                 acs_objects.object_type%TYPE;
begin
   if  initialize_attributes__object_id is null then 
	raise exception 'acs_object__initialize_attributes called with null object_id';
   end if;

   -- Initialize dynamic attributes
   insert into acs_attribute_values
    (object_id, attribute_id, attr_value)
   select
    initialize_attributes__object_id, a.attribute_id, a.default_value
   from acs_attributes a, acs_objects o
   where a.object_type = o.object_type
   and o.object_id = initialize_attributes__object_id
   and a.storage = 'generic'
   and a.static_p = 'f';

   -- Retrieve type for static attributes
   select object_type into v_object_type from acs_objects
     where object_id = initialize_attributes__object_id;

   -- Initialize static attributes
   -- begin
     insert into acs_static_attr_values
      (object_type, attribute_id, attr_value)
     select
      v_object_type, a.attribute_id, a.default_value
     from acs_attributes a, acs_objects o
     where a.object_type = o.object_type
       and o.object_id = initialize_attributes__object_id
       and a.storage = 'generic'
       and a.static_p = 't'
       and not exists (select 1 from acs_static_attr_values
                       where object_type = a.object_type);
   -- exception when no_data_found then null;

   return 0; 
end;$_$;


--
-- Name: acs_object__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__name(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  name__object_id        alias for $1;  
  object_name            varchar;  
  v_object_id            integer;
  obj_type               record;  
  obj                    record;      
begin
  -- Find the name function for this object, which is stored in the
  -- name_method column of acs_object_types. Starting with this
  -- object's actual type, traverse the type hierarchy upwards until
  -- a non-null name_method value is found.
  --
  -- select name_method
  --  from acs_object_types
  -- start with object_type = (select object_type
  --                             from acs_objects o
  --                            where o.object_id = name__object_id)
  -- connect by object_type = prior supertype

  select title into object_name
  from acs_objects
  where object_id = name__object_id;

  if (object_name is not null) then
    return object_name;
  end if;

  for obj_type
  in select o2.name_method
        from acs_object_types o1, acs_object_types o2
       where o1.object_type = (select object_type
                                 from acs_objects o
                                where o.object_id = name__object_id)
         and o1.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey)
    order by o2.tree_sortkey desc
  loop
   if obj_type.name_method != '' and obj_type.name_method is NOT null then

    -- Execute the first name_method we find (since we're traversing
    -- up the type hierarchy from the object's exact type) using
    -- Native Dynamic SQL, to ascertain the name of this object.
    --
    --execute 'select ' || object_type.name_method || '(:1) from dual'

    for obj in execute 'select ' || obj_type.name_method || '(' || name__object_id || ')::varchar as object_name' loop
        object_name := obj.object_name;
        exit;
    end loop;

    exit;
   end if;
  end loop;

  return object_name;
  
end;$_$;


--
-- Name: acs_object__new(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__new(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        object_id       alias for $1; -- default null
        object_type     alias for $2; -- default 'acs_object'
begin
        return acs_object__new(object_id,object_type,now(),null,null,null);
end;$_$;


--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, boolean, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__object_id              alias for $1;  -- default null
  new__object_type            alias for $2;  -- default 'acs_object'
  new__creation_date          alias for $3;  -- default now()
  new__creation_user          alias for $4;  -- default null
  new__creation_ip            alias for $5;  -- default null
  new__context_id             alias for $6;  -- default null
  new__security_inherit_p     alias for $7;  -- default 't'
  new__title                  alias for $8;  -- default null
  new__package_id             alias for $9;  -- default null
  v_object_id                 acs_objects.object_id%TYPE;
  v_creation_date	      timestamptz;
  v_title                     acs_objects.title%TYPE;
  v_object_type_pretty_name   acs_object_types.pretty_name%TYPE;
begin
  if new__object_id is null then
   select acs_object_id_seq.nextval
   into v_object_id from dual;
  else
    v_object_id := new__object_id;
  end if;

  if new__object_id is null then
   select pretty_name
   into v_object_type_pretty_name
   from acs_object_types
   where object_type = new__object_type;

    v_title := v_object_type_pretty_name || ' ' || v_object_id;
  else
    v_title := new__title;
  end if;

  if new__creation_date is null then
   v_creation_date:= now();
  else
   v_creation_date := new__creation_date;
  end if;

  insert into acs_objects
   (object_id, object_type, title, package_id, context_id,
    creation_date, creation_user, creation_ip, security_inherit_p)
  values
   (v_object_id, new__object_type, v_title, new__package_id, new__context_id,
    v_creation_date, new__creation_user, new__creation_ip, 
    new__security_inherit_p);

  PERFORM acs_object__initialize_attributes(v_object_id);

  return v_object_id;
  
end;$_$;


--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__object_id              alias for $1;  -- default null
  new__object_type            alias for $2;  -- default 'acs_object'
  new__creation_date          alias for $3;  -- default now()
  new__creation_user          alias for $4;  -- default null
  new__creation_ip            alias for $5;  -- default null
  new__context_id             alias for $6;  -- default null
  v_object_id                 acs_objects.object_id%TYPE;
  v_creation_date	      timestamptz;
begin
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         't', null, null);
end;$_$;


--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__object_id              alias for $1;  -- default null
  new__object_type            alias for $2;  -- default 'acs_object'
  new__creation_date          alias for $3;  -- default now()
  new__creation_user          alias for $4;  -- default null
  new__creation_ip            alias for $5;  -- default null
  new__context_id             alias for $6;  -- default null
  new__security_inherit_p     alias for $7;  -- default 't'
begin
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         new__security_inherit_p, null, null);
end;$_$;


--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, boolean, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, boolean, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__object_id              alias for $1;  -- default null
  new__object_type            alias for $2;  -- default 'acs_object'
  new__creation_date          alias for $3;  -- default now()
  new__creation_user          alias for $4;  -- default null
  new__creation_ip            alias for $5;  -- default null
  new__context_id             alias for $6;  -- default null
  new__security_inherit_p     alias for $7;  -- default 't'
  new__title                  alias for $8;  -- default null
begin
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         new__security_inherit_p, new__title, null);
end;$_$;


--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__object_id              alias for $1;  -- default null
  new__object_type            alias for $2;  -- default 'acs_object'
  new__creation_date          alias for $3;  -- default now()
  new__creation_user          alias for $4;  -- default null
  new__creation_ip            alias for $5;  -- default null
  new__context_id             alias for $6;  -- default null
  new__title                  alias for $7;  -- default null
  new__package_id             alias for $8;  -- default null
begin
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         't', new__title, new__package_id);
end;$_$;


--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__object_id              alias for $1;  -- default null
  new__object_type            alias for $2;  -- default 'acs_object'
  new__creation_date          alias for $3;  -- default now()
  new__creation_user          alias for $4;  -- default null
  new__creation_ip            alias for $5;  -- default null
  new__context_id             alias for $6;  -- default null
  new__title                  alias for $7;  -- default null
begin
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         't', new__title, null);
end;$_$;


--
-- Name: acs_object__package_id(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__package_id(integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  p_object_id  alias for $1;
  v_package_id acs_objects.package_id%TYPE;
begin
  if p_object_id is null then
    return null;
  end if;

  select package_id into v_package_id
  from acs_objects
  where object_id = p_object_id;

  return v_package_id;
end;$_$;


--
-- Name: acs_object__set_attribute(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__set_attribute(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  object_id_in           alias for $1;  
  attribute_name_in      alias for $2;  
  value_in               alias for $3;  
  v_table_name           varchar;  
  v_column               varchar;  
  v_key_sql              text; 
  v_return               text; 
  v_storage              text;
begin
   if value_in is null then
	-- this will fail more cryptically in the execute so catch now. 
	raise exception 'acs_object__set_attribute: attempt to set % to null for object_id %',attribute_name_in, object_id_in;
   end if;

   v_storage := acs_object__get_attribute_storage(object_id_in, attribute_name_in);

   v_column     := acs_object__get_attr_storage_column(v_storage);
   v_table_name := acs_object__get_attr_storage_table(v_storage);
   v_key_sql    := acs_object__get_attr_storage_sql(v_storage);

   execute 'update ' || v_table_name || ' set ' || quote_ident(v_column) || ' = ' || quote_literal(value_in) || ' where ' || v_key_sql;

   return 0; 
end;$_$;


--
-- Name: acs_object__update_last_modified(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__update_last_modified(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
 declare
     acs_object__update_last_modified__object_id     alias for $1;
 begin
     return acs_object__update_last_modified(acs_object__update_last_modified__object_id, now());
 end;$_$;


--
-- Name: acs_object__update_last_modified(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__update_last_modified(integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
 declare
     acs_object__update_last_modified__object_id     alias for $1;
     acs_object__update_last_modified__last_modified alias for $2; -- default now()
     v_parent_id                                     integer;
     v_last_modified                                 timestamptz;
 begin
     if acs_object__update_last_modified__last_modified is null then
         v_last_modified := now();
     else
         v_last_modified := acs_object__update_last_modified__last_modified;
     end if;

     update acs_objects
     set last_modified = v_last_modified
     where object_id = acs_object__update_last_modified__object_id;

     select context_id
     into v_parent_id
     from acs_objects
     where object_id = acs_object__update_last_modified__object_id;

     if v_parent_id is not null and v_parent_id != 0 then
         perform acs_object__update_last_modified(v_parent_id, v_last_modified);
     end if;

     return acs_object__update_last_modified__object_id;
 end;$_$;


--
-- Name: acs_object__update_last_modified(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__update_last_modified(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    acs_object__update_last_modified__object_id          alias for $1;
    acs_object__update_last_modified__modifying_user     alias for $2;
    acs_object__update_last_modified__modifying_ip       alias for $3;
begin
    return acs_object__update_last_modified(acs_object__update_last_modified__object_id, acs_object__update_last_modified__modifying_user, acs_object__update_last_modified__modifying_ip, now());
end;$_$;


--
-- Name: acs_object__update_last_modified(integer, integer, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__update_last_modified(integer, integer, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    acs_object__update_last_modified__object_id          alias for $1;
    acs_object__update_last_modified__modifying_user     alias for $2;
    acs_object__update_last_modified__modifying_ip       alias for $3;
    acs_object__update_last_modified__last_modified      alias for $4; -- default now()
    v_parent_id                                          integer;
    v_last_modified                                      timestamptz;
begin
    if acs_object__update_last_modified__last_modified is null then
        v_last_modified := now();
    else
        v_last_modified := acs_object__update_last_modified__last_modified;
    end if;

    update acs_objects
    set last_modified = v_last_modified,
        modifying_user = acs_object__update_last_modified__modifying_user,
        modifying_ip = acs_object__update_last_modified__modifying_ip
    where object_id = acs_object__update_last_modified__object_id;

    select context_id
    into v_parent_id
    from acs_objects
    where object_id = acs_object__update_last_modified__object_id;

    if v_parent_id is not null and v_parent_id != 0 then
        perform acs_object__update_last_modified(v_parent_id, acs_object__update_last_modified__modifying_user, acs_object__update_last_modified__modifying_ip, v_last_modified);
    end if;
        
    return acs_object__update_last_modified__object_id;
end;$_$;


--
-- Name: acs_object__update_last_modified(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__update_last_modified(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    acs_object__update_last_modified__object_id          alias for $1;
    acs_object__update_last_modified__modifying_user     alias for $2;
    acs_object__update_last_modified__modifying_ip       alias for $3;
begin
    return acs_object__update_last_modified(acs_object__update_last_modified__object_id, acs_object__update_last_modified__modifying_user, acs_object__update_last_modified__modifying_ip, now());
end;$_$;


--
-- Name: acs_object__update_last_modified(integer, integer, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object__update_last_modified(integer, integer, character varying, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    acs_object__update_last_modified__object_id          alias for $1; 
    acs_object__update_last_modified__modifying_user     alias for $2;
    acs_object__update_last_modified__modifying_ip       alias for $3;
    acs_object__update_last_modified__last_modified      alias for $4; -- default now()
    v_parent_id                                          integer;
    v_last_modified                                      timestamptz;
begin
    if acs_object__update_last_modified__last_modified is null then
        v_last_modified := now();
    else
        v_last_modified := acs_object__update_last_modified__last_modified;
    end if;

    update acs_objects
    set last_modified = v_last_modified,
        modifying_user = acs_object__update_last_modified__modifying_user,
        modifying_ip = acs_object__update_last_modified__modifying_ip
    where object_id = acs_object__update_last_modified__object_id;

    select context_id
    into v_parent_id
    from acs_objects
    where object_id = acs_object__update_last_modified__object_id;

    if v_parent_id is not null and v_parent_id != 0 then
        perform acs_object__update_last_modified(v_parent_id, acs_object__update_last_modified__modifying_user, acs_object__update_last_modified__modifying_ip, v_last_modified);
    end if;

    return acs_object__update_last_modified__object_id;
end;$_$;


--
-- Name: acs_object_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, boolean, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, boolean, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_type__object_type            alias for $1;  
  create_type__pretty_name            alias for $2;  
  create_type__pretty_plural          alias for $3;  
  create_type__supertype              alias for $4;  
  create_type__table_name             alias for $5;  
  create_type__id_column              alias for $6;  -- default 'XXX'
  create_type__package_name           alias for $7;  -- default null
  create_type__abstract_p             alias for $8;  -- default 'f'
  create_type__type_extension_table   alias for $9;  -- default null
  create_type__name_method            alias for $10; -- default null
  v_package_name acs_object_types.package_name%TYPE;
  v_supertype						  acs_object_types.supertype%TYPE;
  v_name_method                       varchar;
  v_idx                               integer;
begin
    v_idx := position('.' in create_type__name_method);
    if v_idx <> 0 then
         v_name_method := substr(create_type__name_method,1,v_idx - 1) || 
                       '__' || substr(create_type__name_method, v_idx + 1);
    else 
         v_name_method := create_type__name_method;
    end if;

    if create_type__package_name is null or create_type__package_name = '' then
      v_package_name := create_type__object_type;
    else
      v_package_name := create_type__package_name;
    end if;

	if create_type__supertype is null or create_type__supertype = '' then
	  v_supertype := 'acs_object';
	else
	  v_supertype := create_type__supertype;
	end if;

    insert into acs_object_types
      (object_type, pretty_name, pretty_plural, supertype, table_name,
       id_column, abstract_p, type_extension_table, package_name,
       name_method)
    values
      (create_type__object_type, create_type__pretty_name, 
       create_type__pretty_plural, v_supertype, 
       create_type__table_name, create_type__id_column, 
       create_type__abstract_p, create_type__type_extension_table, 
       v_package_name, v_name_method);

    return 0; 
end;$_$;


--
-- Name: acs_object_type__drop_type(character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_type__drop_type(character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_type__object_type            alias for $1;  
  drop_type__cascade_p              alias for $2;  -- default 'f'
  row                               record;
begin

    -- drop all the attributes associated with this type
    for row in select attribute_name 
                 from acs_attributes 
                where object_type = drop_type__object_type 
    loop
       PERFORM acs_attribute__drop_attribute (drop_type__object_type, 
                                              row.attribute_name);
    end loop;

    delete from acs_attributes
    where object_type = drop_type__object_type;

    delete from acs_object_types
    where object_type = drop_type__object_type;

    return 0; 
end;$_$;


--
-- Name: acs_object_type__is_subtype_p(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_type__is_subtype_p(character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_subtype_p__object_type_1          alias for $1;  
  is_subtype_p__object_type_2          alias for $2;  
  v_result                             integer;       
begin
    -- select count(*) into v_result
    --  where exists (select 1 
    --                 from acs_object_types t 
    --                where t.object_type	= is_subtype_p__object_type_2
    --              connect by prior t.object_type = t.supertype
    --                start with t.supertype = is_subtype_p__object_type_1);

    select count(*) into v_result
     where exists (select 1 
                     from acs_object_types t, acs_object_types t2
                    where t.object_type = is_subtype_p__object_type_2
                      and t2.object_type = is_subtype_p__object_type_1
                      and t.tree_sortkey between t2.tree_sortkey and tree_right(t2.tree_sortkey));

    if v_result > 0 then
       return 't';
    end if;

    return 'f';
   
end;$_$;


--
-- Name: acs_object_type__pretty_name(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_type__pretty_name(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  pretty_name__object_type            alias for $1;  
  v_pretty_name                       acs_object_types.pretty_name%TYPE;
begin
    select t.pretty_name into v_pretty_name
      from acs_object_types t
     where t.object_type = pretty_name__object_type;

    return v_pretty_name;
   
end;$_$;


--
-- Name: acs_object_type_get_tree_sortkey(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_type_get_tree_sortkey(character varying) RETURNS bit varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_object_type    alias for $1;
begin
  return tree_sortkey from acs_object_types where object_type = p_object_type;
end;$_$;


--
-- Name: acs_object_type_insert_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_type_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk     varbit default null;
        v_max_value     integer;
begin
        select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
          from acs_object_types 
         where supertype = new.supertype;

        select tree_sortkey into v_parent_sk 
          from acs_object_types 
         where object_type = new.supertype;

        new.tree_sortkey := tree_next_key(v_parent_sk ,v_max_value);

        return new;

end;$$;


--
-- Name: acs_object_type_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_type_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk     varbit default null;
        v_max_value     integer;
        v_rec           record;
        clr_keys_p      boolean default 't';
begin
        if new.object_type = old.object_type and 
           ((new.supertype = old.supertype) or 
            (new.supertype is null and old.supertype is null)) then

           return new;

        end if;

        for v_rec in select object_type, supertype
                       from acs_object_types 
                      where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey)
                   order by tree_sortkey
        LOOP
            if clr_keys_p then
               update acs_object_types set tree_sortkey = null
               where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);
               clr_keys_p := 'f';
            end if;
            
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
              from acs_object_types 
              where supertype = v_rec.supertype;

            select tree_sortkey into v_parent_sk 
              from acs_object_types 
             where object_type = v_rec.supertype;

            update acs_object_types 
               set tree_sortkey = tree_next_key(v_parent_sk, v_max_value)
             where object_type = v_rec.object_type;

        end LOOP;

        return new;

end;$$;


--
-- Name: acs_object_util__get_object_type(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_util__get_object_type(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    p_object_id         alias for $1;
    v_object_type       varchar(100);
begin
    select object_type into v_object_type
    from acs_objects
    where object_id = p_object_id;

    if not found then
        raise exception 'acs_object_util__get_object_type: Invalid Object id: % ', p_object_id;
    end if;

    return v_object_type;

end;$_$;


--
-- Name: acs_object_util__object_ancestor_type_p(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_util__object_ancestor_type_p(integer, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id         alias for $1;
    p_object_type       alias for $2;
    v_exist_p           boolean := 'f';
    v_object_type       varchar(100);
begin
    v_object_type := acs_object_util__get_object_type (p_object_id);

    v_exist_p := acs_object_util__type_ancestor_type_p (v_object_type, p_object_type);
    return v_exist_p;
end;$_$;


--
-- Name: acs_object_util__object_type_exist_p(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_util__object_type_exist_p(character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_type       alias for $1;
    v_exist_p           boolean := 't';
begin


    select (case when count(*)=1 then 't' else 'f' end) into v_exist_p
    from   acs_object_types 
    where  object_type = p_object_type;
 
    return v_exist_p;
end;$_$;


--
-- Name: acs_object_util__object_type_p(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_util__object_type_p(integer, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id         alias for $1;
    p_object_type       alias for $2;
    v_exist_p           boolean := 'f';
begin
    v_exist_p := acs_object_util__object_ancestor_type_p(p_object_id, p_object_type);
    return v_exist_p;
end;$_$;


--
-- Name: acs_object_util__type_ancestor_type_p(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_object_util__type_ancestor_type_p(character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_type1      alias for $1;
    p_object_type2      alias for $2;
begin

    if not acs_object_util__object_type_exist_p(p_object_type1) then
        raise exception 'Object type % does not exist', p_object_type1;
    end if;

    if not acs_object_util__object_type_exist_p(p_object_type2) then
        raise exception 'Object type % does not exist', p_object_type2;
    end if;
        
    return exists (select 1
                   from acs_object_types o1, acs_object_types o2
                   where p_object_type2 = o2.object_type
                     and o1.object_type = p_object_type1
                     and o1.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey));
end;$_$;


--
-- Name: acs_objects_context_id_del_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_objects_context_id_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  delete from acs_object_context_index
  where object_id = old.object_id;

  return old;

end;$$;


--
-- Name: acs_objects_context_id_in_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_objects_context_id_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        security_context_root integer;
begin
  insert into acs_object_context_index
   (object_id, ancestor_id, n_generations)
  values
   (new.object_id, new.object_id, 0);

  if new.context_id is not null and new.security_inherit_p = 't' then
    insert into acs_object_context_index
     (object_id, ancestor_id, n_generations)
    select
     new.object_id as object_id, ancestor_id,
     n_generations + 1 as n_generations
    from acs_object_context_index
    where object_id = new.context_id;
  else
    security_context_root = acs__magic_object_id('security_context_root');
    if new.object_id != security_context_root then
      insert into acs_object_context_index
        (object_id, ancestor_id, n_generations)
      values
        (new.object_id, security_context_root, 1);
    end if;
  end if;

  return new;

end;$$;


--
-- Name: acs_objects_context_id_up_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_objects_context_id_up_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        pair    record;
        outer record;
        inner record;
        security_context_root integer;
begin
  if new.object_id = old.object_id
     and ((new.context_id = old.context_id)
	  or (new.context_id is null and old.context_id is null))
     and new.security_inherit_p = old.security_inherit_p then
    return new;
  end if;

  -- Remove my old ancestors from my descendants.
  for outer in select object_id from acs_object_context_index where 
               ancestor_id = old.object_id and object_id <> old.object_id loop
    for inner in select ancestor_id from acs_object_context_index where
                 object_id = old.object_id and ancestor_id <> old.object_id loop
      delete from acs_object_context_index
      where object_id = outer.object_id
        and ancestor_id = inner.ancestor_id;
    end loop;
  end loop;

  -- Kill all my old ancestors.
  delete from acs_object_context_index
  where object_id = old.object_id;

  insert into acs_object_context_index
   (object_id, ancestor_id, n_generations)
  values
   (new.object_id, new.object_id, 0);

  if new.context_id is not null and new.security_inherit_p = 't' then
     -- Now insert my new ancestors for my descendants.
    for pair in select *
		 from acs_object_context_index
		 where ancestor_id = new.object_id 
    LOOP
      insert into acs_object_context_index
       (object_id, ancestor_id, n_generations)
      select
       pair.object_id, ancestor_id,
       n_generations + pair.n_generations + 1 as n_generations
      from acs_object_context_index
      where object_id = new.context_id;
    end loop;
  else
    security_context_root = acs__magic_object_id('security_context_root');
    if new.object_id != security_context_root then
    -- We need to make sure that new.OBJECT_ID and all of its
    -- children have security_context_root as an ancestor.
    for pair in  select *
		 from acs_object_context_index
		 where ancestor_id = new.object_id 
      LOOP
        insert into acs_object_context_index
         (object_id, ancestor_id, n_generations)
        values
         (pair.object_id, security_context_root, pair.n_generations + 1);
      end loop;
    end if;
  end if;

  return new;

end;$$;


--
-- Name: acs_objects_get_tree_sortkey(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_objects_get_tree_sortkey(integer) RETURNS bit varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  p_object_id    alias for $1;
begin
  return tree_sortkey from acs_objects where object_id = p_object_id;
end;$_$;


--
-- Name: acs_objects_insert_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_objects_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk             varbit default null;
        v_max_child_sortkey     varbit;
begin
        if new.context_id is null then
            new.tree_sortkey := int_to_tree_key(new.object_id+1000);
        else
            SELECT tree_sortkey, tree_increment_key(max_child_sortkey)
            INTO v_parent_sk, v_max_child_sortkey
            FROM acs_objects
            WHERE object_id = new.context_id
            FOR UPDATE;

            UPDATE acs_objects
            SET max_child_sortkey = v_max_child_sortkey
            WHERE object_id = new.context_id;

            new.tree_sortkey := v_parent_sk || v_max_child_sortkey;
        end if;

        new.max_child_sortkey := null;
        return new;
end;$$;


--
-- Name: acs_objects_last_mod_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_objects_last_mod_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  if new.last_modified is null then
     new.last_modified := old.last_modified;
  elsif new.last_modified = old.last_modified then
     new.last_modified := now();
  end if;
  return new;
end;$$;


--
-- Name: acs_objects_mod_ip_insert_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_objects_mod_ip_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  new.modifying_ip := new.creation_ip;

  return new;

end;$$;


--
-- Name: acs_objects_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_objects_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk     varbit default null;
        v_max_child_sortkey	varbit;
        v_old_parent_length	integer;
begin
        if new.object_id = old.object_id and ( new.context_id = old.context_id
            or (new.context_id is null and old.context_id is null) ) then
           return new;
        end if;

	-- the tree sortkey is going to change so get the new one and update it and all its
	-- children to have the new prefix...
	v_old_parent_length := length(new.tree_sortkey) + 1;

	if new.context_id is null then
            v_parent_sk := int_to_tree_key(new.object_id+1000);
        else
	    SELECT tree_sortkey, tree_increment_key(max_child_sortkey)
	    INTO v_parent_sk, v_max_child_sortkey
            FROM acs_objects
            WHERE object_id = new.context_id
            FOR UPDATE;

	    UPDATE acs_objects
            SET max_child_sortkey = v_max_child_sortkey
  	    WHERE object_id = new.context_id;

  	    v_parent_sk := v_parent_sk || v_max_child_sortkey;
	end if;

	UPDATE acs_objects
	SET tree_sortkey = v_parent_sk || substring(tree_sortkey, v_old_parent_length)
        WHERE tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);

        return new;
end;$$;


--
-- Name: acs_permission__grant_permission(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_permission__grant_permission(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    grant_permission__object_id         alias for $1;
    grant_permission__grantee_id        alias for $2;
    grant_permission__privilege         alias for $3;
    exists_p                            boolean;
begin
    lock table acs_permissions_lock;

    select count(*) > 0 into exists_p
      from acs_permissions
     where object_id = grant_permission__object_id
       and grantee_id = grant_permission__grantee_id
       and privilege = grant_permission__privilege;

    if not exists_p then

        insert into acs_permissions
          (object_id, grantee_id, privilege)
          values
          (grant_permission__object_id, grant_permission__grantee_id, 
          grant_permission__privilege);

    end if;

    -- exception
    --  when dup_val_on_index then
    --    return;

    return 0; 
end;$_$;


--
-- Name: acs_permission__permission_p(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_permission__permission_p(integer, integer, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
    permission_p__object_id           alias for $1;
    permission_p__party_id            alias for $2;
    permission_p__privilege           alias for $3;
    exists_p                          boolean;
begin
  return exists (select 1
                 from acs_permissions p, party_approved_member_map m,
                   acs_object_context_index c, acs_privilege_descendant_map h
                 where p.object_id = c.ancestor_id
                   and h.descendant = permission_p__privilege
                   and c.object_id = permission_p__object_id
                   and m.member_id = permission_p__party_id
                   and p.privilege = h.privilege
                   and p.grantee_id = m.party_id);
end;$_$;


--
-- Name: acs_permission__revoke_permission(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_permission__revoke_permission(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    revoke_permission__object_id         alias for $1;
    revoke_permission__grantee_id        alias for $2;
    revoke_permission__privilege         alias for $3;
begin
    lock table acs_permissions_lock;

    delete from acs_permissions
    where object_id = revoke_permission__object_id
    and grantee_id = revoke_permission__grantee_id
    and privilege = revoke_permission__privilege;

    return 0; 
end;$_$;


--
-- Name: acs_permissions_lock_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_permissions_lock_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        raise EXCEPTION 'FOR LOCKING ONLY, NO DML STATEMENTS ALLOWED';
        return null;
end;$$;


--
-- Name: acs_priv_del_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_priv_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

  delete from acs_privilege_descendant_map
  where privilege = old.privilege;

  return old;

end;$$;


--
-- Name: acs_priv_hier_ins_del_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_priv_hier_ins_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        new_value       integer;
        new_key         varbit default null;
        v_rec           record;
        deleted_p       boolean;
begin

        -- if more than one node was deleted the second trigger call
        -- will error out.  This check avoids that problem.

        if TG_OP = 'DELETE' then 
            select count(*) = 0 into deleted_p
              from acs_privilege_hierarchy_index 
             where old.privilege = privilege
               and old.child_privilege = child_privilege;     
       
            if deleted_p then

                return new;

            end if;
        end if;

        -- recalculate the table from scratch.

        delete from acs_privilege_hierarchy_index;

        -- first find the top nodes of the tree

        for v_rec in select privilege, child_privilege
                       from acs_privilege_hierarchy
                      where privilege 
                            NOT in (select distinct child_privilege
                                      from acs_privilege_hierarchy)
                                           
        LOOP

            -- top level node, so find the next key at this level.

            select max(tree_leaf_key_to_int(tree_sortkey)) into new_value 
              from acs_privilege_hierarchy_index
             where tree_level(tree_sortkey) = 1;

             -- insert the new node

            insert into acs_privilege_hierarchy_index 
                        (privilege, child_privilege, tree_sortkey)
                        values
                        (v_rec.privilege, v_rec.child_privilege, tree_next_key(null, new_value));

            -- now recurse down from this node

            PERFORM priv_recurse_subtree(tree_next_key(null, new_value), v_rec.child_privilege);

        end LOOP;

        -- materialize the map view to speed up queries
        -- DanW (dcwickstrom@earthlink.net) 30 Jan, 2003
        delete from acs_privilege_descendant_map;

        insert into acs_privilege_descendant_map (privilege, descendant) 
        select privilege, descendant from acs_privilege_descendant_map_view;

        return new;

end;$$;


--
-- Name: acs_privilege__add_child(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_privilege__add_child(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_child__privilege              alias for $1;  
  add_child__child_privilege        alias for $2;  
begin
    insert into acs_privilege_hierarchy
     (privilege, child_privilege)
    values
     (add_child__privilege, add_child__child_privilege);

    return 0; 
end;$_$;


--
-- Name: acs_privilege__create_privilege(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_privilege__create_privilege(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_privilege__privilege              alias for $1;  
  create_privilege__pretty_name            alias for $2;  -- default null  
  create_privilege__pretty_plural          alias for $3;  -- default null
begin
    insert into acs_privileges
     (privilege, pretty_name, pretty_plural)
    values
     (create_privilege__privilege, 
      create_privilege__pretty_name, 
      create_privilege__pretty_plural);
      
    return 0; 
end;$_$;


--
-- Name: acs_privilege__create_privilege(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_privilege__create_privilege(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_privilege__privilege              alias for $1;
begin
    return acs_privilege__create_privilege(create_privilege__privilege, null, null);
end;$_$;


--
-- Name: acs_privilege__drop_privilege(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_privilege__drop_privilege(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_privilege__privilege     alias for $1;  
begin
    delete from acs_privileges
    where privilege = drop_privilege__privilege;

    return 0; 
end;$_$;


--
-- Name: acs_privilege__remove_child(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_privilege__remove_child(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  remove_child__privilege              alias for $1;  
  remove_child__child_privilege        alias for $2;  
begin
    delete from acs_privilege_hierarchy
    where privilege = remove_child__privilege
    and child_privilege = remove_child__child_privilege;

    return 0; 
end;$_$;


--
-- Name: acs_reference__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_reference__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_repository_id alias for $1;
    v_maintainer_id		acs_objects.object_id%TYPE;
begin
    select maintainer_id into v_maintainer_id
    from   acs_reference_repositories
    where  repository_id = p_repository_id;

    delete from acs_reference_repositories
    where repository_id = p_repository_id;

    perform acs_object__delete(p_repository_id);
    return 0;
end;
$_$;


--
-- Name: acs_reference__is_expired_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_reference__is_expired_p(integer) RETURNS character
    LANGUAGE plpgsql
    AS $_$
declare
    repository_id alias for $1;
begin
    select expiry_date into v_expiry_date
    from   acs_reference_repositories
    where  repository_id = is_expired_p.repository_id;

    if coalesce(v_expiry_date,now()+1) < now() then
        return 't';
    else
        return 'f';
    end if;
end;
$_$;


--
-- Name: acs_reference__new(integer, character varying, boolean, character varying, timestamp with time zone, character varying, character varying, timestamp with time zone, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_reference__new(integer, character varying, boolean, character varying, timestamp with time zone, character varying, character varying, timestamp with time zone, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_repository_id   alias for $1; -- default null
    p_table_name      alias for $2; -- 
    p_internal_data_p alias for $3; -- default "f"
    p_package_name    alias for $4; -- default null
    p_last_update     alias for $5; -- default sysdate
    p_source          alias for $6; -- default null
    p_source_url      alias for $7; -- default null
    p_effective_date  alias for $8; -- default sysdate
    p_expiry_date     alias for $9; -- default null
    p_maintainer_id   alias for $10; -- default null
    p_notes           alias for $11; -- default null (not Oracle empty_blob())
-- I really see no need for these as parameters
--    creation_date   alias for $12; -- default sysdate
    p_first_names     alias for $12; -- default null
    p_last_name      alias for $13; -- default null
    p_creation_ip     alias for $14; -- default null
    p_object_type     alias for $15; -- default "acs_reference_repository"
    p_creation_user   alias for $16; -- default null
    v_repository_id acs_reference_repositories.repository_id%TYPE;
    v_object_type   acs_objects.object_type%TYPE;
    v_maintainer_id persons.person_id%TYPE;
begin
    if p_object_type is null then
        v_object_type := 'acs_reference_repository';
    else
        v_object_type := p_object_type;
    end if;

    v_repository_id := acs_object__new (
         p_repository_id,    
         v_object_type,
         now(),
         p_creation_user,
         p_creation_ip,
         null
    );

    -- This logic is not correct as the maintainer could already exist
    -- The way around this is a little clunky as you can search persons
    -- then pick an existing person or add a new one, to many screens!
    -- I really doubt the need for person anyway.
    --
    -- It probably needs to just be a UI function and pass
    -- in the value for maintainer.
    --
    -- IN OTHER WORDS
    -- Guaranteed to probably break in the future if you depend on
    -- first_names and last_name to still exist as a param
    -- This needs to be updated in the Oracle version also
    -- NEEDS TO BE FIXED - jag

    if p_first_names is not null and p_last_name is not null and p_maintainer_id is null then
        v_maintainer_id := person__new (null, 'person', now(), null, null, null, null,
	                                p_first_names, p_last_name, null);
	else if p_maintainer_id is not null then
           v_maintainer_id := p_maintainer_id;
        else 
	    v_maintainer_id := null;
	end if;
    end if;

    insert into acs_reference_repositories
        (repository_id,table_name,internal_data_p,
         last_update,package_name,source, 
         source_url,effective_date,expiry_date,
         maintainer_id,lob)
    values 
        (v_repository_id, p_table_name, p_internal_data_p,
         p_last_update, p_package_name, p_source, p_source_url,
         p_effective_date, p_expiry_date, v_maintainer_id, p_notes);

    return v_repository_id;    
end;
$_$;


--
-- Name: acs_reference__new(character varying, timestamp with time zone, character varying, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_reference__new(character varying, timestamp with time zone, character varying, character varying, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_table_name      alias for $1; -- 
    p_last_update     alias for $2; -- default sysdate
    p_source          alias for $3; -- default null
    p_source_url      alias for $4; -- default null
    p_effective_date  alias for $5; -- default sysdate
    v_repository_id acs_reference_repositories.repository_id%TYPE;
begin
    return acs_reference__new(null, p_table_name, 'f', null, null, p_source, p_source_url,
                              p_effective_date, null, null, null, null, null, null,
                              'acs_reference_repository', null);
end;
$_$;


--
-- Name: acs_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  rel_id                 alias for $1;  
begin
    PERFORM acs_object__delete(rel_id);

    return 0; 
end;$_$;


--
-- Name: acs_rel__new(integer, character varying, integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel__new(integer, character varying, integer, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__rel_id            alias for $1;  -- default null  
  new__rel_type          alias for $2;  -- default 'relationship'
  new__object_id_one     alias for $3;  
  new__object_id_two     alias for $4;  
  context_id             alias for $5;  -- default null
  creation_user          alias for $6;  -- default null
  creation_ip            alias for $7;  -- default null
  v_rel_id               acs_rels.rel_id%TYPE;
begin
    -- XXX This should check that object_id_one and object_id_two are
    -- of the appropriate types.
    v_rel_id := acs_object__new (
      new__rel_id,
      new__rel_type,
      now(),
      creation_user,
      creation_ip,
      context_id,
      't',
      new__rel_type || ': ' || new__object_id_one || ' - ' || new__object_id_two,
      null
    );

    insert into acs_rels
     (rel_id, rel_type, object_id_one, object_id_two)
    values
     (v_rel_id, new__rel_type, new__object_id_one, new__object_id_two);

    return v_rel_id;
   
end;$_$;


--
-- Name: acs_rel_type__create_role(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel_type__create_role(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_role__role                   alias for $1;  
  create_role__pretty_name            alias for $2;  -- default null  
  create_role__pretty_plural          alias for $3;  -- default null
begin
    insert into acs_rel_roles
     (role, pretty_name, pretty_plural)
    values
     (create_role__role, coalesce(create_role__pretty_name,create_role__role), coalesce(create_role__pretty_plural,create_role__role));

    return 0; 
end;$_$;


--
-- Name: acs_rel_type__create_role(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel_type__create_role(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_role__role                   alias for $1;  
begin
    perform acs_rel_type__create_role(create_role__role, NULL, NULL);
    return 0; 
end;$_$;


--
-- Name: acs_rel_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_type__rel_type               alias for $1;  
  create_type__pretty_name            alias for $2;  
  create_type__pretty_plural          alias for $3;  
  create_type__supertype              alias for $4;  -- default 'relationship'
  create_type__table_name             alias for $5;  
  create_type__id_column              alias for $6;  
  create_type__package_name           alias for $7;  
  create_type__object_type_one        alias for $8; 
  create_type__role_one               alias for $9;  -- default null 
  create_type__min_n_rels_one         alias for $10; 
  create_type__max_n_rels_one         alias for $11; 
  create_type__object_type_two        alias for $12; 
  create_type__role_two               alias for $13; -- default null
  create_type__min_n_rels_two         alias for $14; 
  create_type__max_n_rels_two         alias for $15; 

  type_extension_table acs_object_types.type_extension_table%TYPE default null;
  abstract_p   acs_object_types.abstract_p%TYPE      default 'f';
  name_method  acs_object_types.name_method%TYPE     default null;     
begin
    PERFORM acs_object_type__create_type(
      create_type__rel_type,
      create_type__pretty_name,
      create_type__pretty_plural,
      create_type__supertype,
      create_type__table_name,
      create_type__id_column,
      create_type__package_name,
      abstract_p,
      type_extension_table,
      name_method
    );

    insert into acs_rel_types
     (rel_type,
      object_type_one, role_one,
      min_n_rels_one, max_n_rels_one,
      object_type_two, role_two,
      min_n_rels_two, max_n_rels_two)
    values
     (create_type__rel_type,
      create_type__object_type_one, create_type__role_one,
      create_type__min_n_rels_one, create_type__max_n_rels_one,
      create_type__object_type_two, create_type__role_two,
      create_type__min_n_rels_two, create_type__max_n_rels_two);

    return 0; 
end;$_$;


--
-- Name: acs_rel_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_type__rel_type               alias for $1;  
  create_type__pretty_name            alias for $2;  
  create_type__pretty_plural          alias for $3;  
  create_type__supertype              alias for $4;  -- default 'relationship'  
  create_type__table_name             alias for $5;  
  create_type__id_column              alias for $6;  
  create_type__package_name           alias for $7;  
  create_type__type_extension_table   alias for $8;  -- default null
  create_type__object_type_one        alias for $9; 
  create_type__min_n_rels_one         alias for $10; 
  create_type__max_n_rels_one         alias for $11; 
  create_type__object_type_two        alias for $12; 
  create_type__min_n_rels_two         alias for $13; 
  create_type__max_n_rels_two         alias for $14; 

  abstract_p   acs_object_types.abstract_p%TYPE      default 'f';
  name_method  acs_object_types.name_method%TYPE     default null;     
  create_type__role_one  acs_rel_types.role_one%TYPE default null;           
  create_type__role_two  acs_rel_types.role_two%TYPE default null;
begin

    PERFORM acs_object_type__create_type(
      create_type__rel_type,
      create_type__pretty_name,
      create_type__pretty_plural,
      create_type__supertype,
      create_type__table_name,
      create_type__id_column,
      create_type__package_name,
      abstract_p,
      create_type__type_extension_table,
      name_method
    );

    insert into acs_rel_types
     (rel_type,
      object_type_one, role_one,
      min_n_rels_one, max_n_rels_one,
      object_type_two, role_two,
      min_n_rels_two, max_n_rels_two)
    values
     (create_type__rel_type,
      create_type__object_type_one, create_type__role_one,
      create_type__min_n_rels_one, create_type__max_n_rels_one,
      create_type__object_type_two, create_type__role_two,
      create_type__min_n_rels_two, create_type__max_n_rels_two);

    return 0; 
end;$_$;


--
-- Name: acs_rel_type__drop_role(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel_type__drop_role(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_role__role                   alias for $1;  
begin
    delete from acs_rel_roles
    where role = drop_role__role;

    return 0; 
end;$_$;


--
-- Name: acs_rel_type__drop_type(character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel_type__drop_type(character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_type__rel_type               alias for $1;  
  drop_type__cascade_p              alias for $2;  -- default 'f'  
  v_cascade                         boolean;
begin
    -- XXX do cascade_p.
    -- JCD: cascade_p seems to be ignored in acs_o_type__drop_type anyway...
    if drop_type__cascade_p is null then 
	v_cascade_p := 'f';
    else 
	v_cascade_p := drop_type__cascade_p;
    end if;

    delete from acs_rel_types
	  where rel_type = drop_type__rel_type;

    PERFORM acs_object_type__drop_type(drop_type__rel_type, 
                                       v_cascade_p);

    return 0; 
end;$_$;


--
-- Name: acs_rel_type__role_pretty_name(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel_type__role_pretty_name(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  role_pretty_name__role        alias for $1;  
  v_pretty_name                 acs_rel_roles.pretty_name%TYPE;
begin
    select r.pretty_name into v_pretty_name
      from acs_rel_roles r
     where r.role = role_pretty_name__role;

    return v_pretty_name;
   
end;$_$;


--
-- Name: acs_rel_type__role_pretty_plural(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rel_type__role_pretty_plural(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  role_pretty_plural__role      alias for $1;  
  v_pretty_plural               acs_rel_roles.pretty_plural%TYPE;
begin
    select r.pretty_plural into v_pretty_plural
      from acs_rel_roles r
     where r.role = role_pretty_plural__role;

    return v_pretty_plural;
   
end;$_$;


--
-- Name: acs_rels_in_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_rels_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  dummy integer;
  target_object_type_one acs_object_types.object_type%TYPE;
  target_object_type_two acs_object_types.object_type%TYPE;
  actual_object_type_one acs_object_types.object_type%TYPE;
  actual_object_type_two acs_object_types.object_type%TYPE;
begin

    -- DRB: The obvious rewrite to use Dan's port of this to use tree_ancestor_keys kills
    -- Postgres!!!  Argh!!!  This is fast, to, so there ...

    -- Get all the object type info from the relationship.

    select rt.object_type_one, rt.object_type_two,
           o1.object_type, o2.object_type
    into target_object_type_one, target_object_type_two,
         actual_object_type_one, actual_object_type_two
    from acs_rel_types rt, acs_objects o1, acs_objects o2
    where rt.rel_type = new.rel_type
      and o1.object_id = new.object_id_one
      and o2.object_id = new.object_id_two;

    if not exists (select 1
                    from 
                    (select tree_ancestor_keys(acs_object_type_get_tree_sortkey(actual_object_type_one))
                      as tree_sortkey) parents1,
                    (select tree_ancestor_keys(acs_object_type_get_tree_sortkey(actual_object_type_two))
                      as tree_sortkey) parents2,
                    (select tree_sortkey from acs_object_types where object_type = target_object_type_one)
                      root1,
                    (select tree_sortkey from acs_object_types where object_type = target_object_type_two)
                      root2
                   where root1.tree_sortkey = parents1.tree_sortkey
                     and root2.tree_sortkey = parents2.tree_sortkey) then

      raise EXCEPTION '-20001: %  violation: Invalid object types. Object % (%) must be of type % Object % (%) must be of type %', new.rel_type, 
                                         new.object_id_one,
                                         actual_object_type_one,
                                         target_object_type_one,
                                         new.object_id_two,
                                         actual_object_type_two,
                                         target_object_type_two;

    end if;

    return new;

end;$$;


--
-- Name: acs_sc_binding__delete(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_binding__delete(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_id		alias for $1;
    p_impl_id			alias for $2;
begin

    delete from acs_sc_bindings
    where contract_id = p_contract_id
    and impl_id = p_impl_id;

    return 0;
end;$_$;


--
-- Name: acs_sc_binding__delete(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_binding__delete(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_name		alias for $1;
    p_impl_name			alias for $2;
    v_contract_id		integer;
    v_impl_id			integer;
begin

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    v_impl_id := acs_sc_impl__get_id(p_contract_name,p_impl_name);

    perform acs_sc_binding__delete(v_contract_id,v_impl_id);

    return 0;

end;$_$;


--
-- Name: acs_sc_binding__exists_p(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_binding__exists_p(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_name		alias for $1;
    p_impl_name			alias for $2;
    v_contract_id		integer;
    v_impl_id			integer;
    v_exists_p			integer;
begin

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    v_impl_id := acs_sc_impl__get_id(p_contract_name,p_impl_name);

    select case when count(*)=0 then 0 else 1 end into v_exists_p
    from acs_sc_bindings
    where contract_id = v_contract_id
    and impl_id = v_impl_id;

    return v_exists_p;

end;$_$;


--
-- Name: acs_sc_binding__new(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_binding__new(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_id		alias for $1;
    p_impl_id			alias for $2;
    v_contract_name		varchar;
    v_impl_name			varchar;
    v_count			integer;
begin

    v_contract_name := acs_sc_contract__get_name(p_contract_id);
    v_impl_name := acs_sc_impl__get_name(p_impl_id);

    select count(*) into v_count
    from acs_sc_operations
    where contract_id = p_contract_id
    and operation_name not in (select impl_operation_name
		       	       from acs_sc_impl_aliases
			       where impl_contract_name = v_contract_name
			       and impl_id = p_impl_id);

    if v_count > 0 then
        raise exception 'Binding of % to % failed since certain operations are not implemented.', v_contract_name, v_impl_name;
    end if;

    insert into acs_sc_bindings (
        contract_id,
	impl_id
    ) values (
        p_contract_id,
	p_impl_id
    );

    return 0;

end;$_$;


--
-- Name: acs_sc_binding__new(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_binding__new(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_name		alias for $1;
    p_impl_name			alias for $2;
    v_contract_id		integer;
    v_impl_id			integer;
    v_count			integer;
begin

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    v_impl_id := acs_sc_impl__get_id(p_contract_name,p_impl_name);

    if v_contract_id is null or v_impl_id is null then
        raise exception 'Binding of % to % failed.', p_contract_name, p_impl_name;
    else
        perform acs_sc_binding__new(v_contract_id,v_impl_id);
    end if;

    return 0;

end;$_$;


--
-- Name: acs_sc_contract__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_contract__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_id		alias for $1;
begin

    delete from acs_sc_contracts
    where contract_id = p_contract_id;

    return 0;

end;$_$;


--
-- Name: acs_sc_contract__delete(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_contract__delete(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_name		alias for $1;
    v_contract_id		integer;
begin

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    perform acs_sc_contract__delete(v_contract_id);

    return 0;

end;$_$;


--
-- Name: acs_sc_contract__get_id(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_contract__get_id(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_name             alias for $1;
    v_contract_id               integer;
begin

    select contract_id into v_contract_id
    from acs_sc_contracts
    where contract_name = p_contract_name;

    return v_contract_id;

end;$_$;


--
-- Name: acs_sc_contract__get_name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_contract__get_name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_id		alias for $1;
    v_contract_name		varchar;
begin

    select contract_name into v_contract_name
    from acs_sc_contracts
    where contract_id = p_contract_id;

    return v_contract_name;

end;$_$;


--
-- Name: acs_sc_contract__new(character varying, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_contract__new(character varying, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_name		alias for $1;
    p_contract_desc		alias for $2;
    v_contract_id		integer;
begin

    v_contract_id := acs_object__new(
                null,
                'acs_sc_contract',
                now(),
                null,
                null,
                null
            );

    insert into acs_sc_contracts (
        contract_id,
        contract_name,
        contract_desc
    ) values (
        v_contract_id,
        p_contract_name,
        p_contract_desc
    );

    return v_contract_id;

end;$_$;


--
-- Name: acs_sc_impl__delete(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_impl__delete(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_impl_contract_name	alias for $1;
    p_impl_name			alias for $2;
begin

    delete from acs_sc_impls
    where impl_contract_name = p_impl_contract_name
    and impl_name = p_impl_name;

    return 0;

end;$_$;


--
-- Name: acs_sc_impl__get_id(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_impl__get_id(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_impl_contract_name	alias for $1;
    p_impl_name			alias for $2;
    v_impl_id			integer;
begin

    select impl_id into v_impl_id
    from acs_sc_impls
    where impl_name = p_impl_name
    and impl_contract_name = p_impl_contract_name;

    return v_impl_id;

end;$_$;


--
-- Name: acs_sc_impl__get_name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_impl__get_name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_impl_id			alias for $1;
    v_impl_name			varchar;
begin

    select impl_name into v_impl_name
    from acs_sc_impls
    where impl_id = p_impl_id;

    return v_impl_name;

end;$_$;


--
-- Name: acs_sc_impl__new(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_impl__new(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_impl_contract_name	alias for $1;
    p_impl_name			alias for $2;
    p_impl_owner_name		alias for $3;
    v_impl_id			integer;
begin

    v_impl_id := acs_object__new(
                null,
                'acs_sc_implementation',
                now(),
                null,
                null,
                null
            );

    insert into acs_sc_impls (
        impl_id,
	impl_name,
        impl_owner_name,
	impl_contract_name
    ) values (
        v_impl_id,
	p_impl_name,
	p_impl_owner_name,
	p_impl_contract_name
    );

    return v_impl_id;

end;$_$;


--
-- Name: acs_sc_impl__new(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_impl__new(character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_impl_contract_name        alias for $1;
    p_impl_name                 alias for $2;
    p_impl_pretty_name          alias for $3;
    p_impl_owner_name           alias for $4;
    v_impl_id                   integer;
begin

    v_impl_id := acs_object__new(
                null,
                'acs_sc_implementation',
                now(),
                null,
                null,
                null
            );

    insert into acs_sc_impls (
        impl_id,
        impl_name,
        impl_pretty_name,
        impl_owner_name,
        impl_contract_name
    ) values (
        v_impl_id,
        p_impl_name,
        p_impl_pretty_name,
        p_impl_owner_name,
        p_impl_contract_name
    );

    return v_impl_id;

end;$_$;


--
-- Name: acs_sc_impl_alias__delete(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_impl_alias__delete(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_impl_contract_name	alias for $1;
    p_impl_name			alias for $2;
    p_impl_operation_name	alias for $3;
    v_impl_id			integer;
begin

    v_impl_id := acs_sc_impl__get_id(p_impl_contract_name, p_impl_name);

    delete from acs_sc_impl_aliases 
    where impl_contract_name = p_impl_contract_name 
    and impl_name = p_impl_name
    and impl_operation_name = p_impl_operation_name;

    return v_impl_id;

end;$_$;


--
-- Name: acs_sc_impl_alias__new(character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_impl_alias__new(character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_impl_contract_name	alias for $1;
    p_impl_name			alias for $2;
    p_impl_operation_name	alias for $3;
    p_impl_alias		alias for $4;
    p_impl_pl			alias for $5;
    v_impl_id			integer;
begin

    v_impl_id := acs_sc_impl__get_id(p_impl_contract_name,p_impl_name);

    insert into acs_sc_impl_aliases (
        impl_id,
	impl_name,
	impl_contract_name,
	impl_operation_name,
	impl_alias,
	impl_pl
    ) values (
        v_impl_id,
	p_impl_name,
	p_impl_contract_name,
	p_impl_operation_name,
	p_impl_alias,
	p_impl_pl
    );

    return v_impl_id;

end;$_$;


--
-- Name: acs_sc_msg_type__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_msg_type__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_msg_type_id		alias for $1;
begin

    delete from acs_sc_msg_types
    where msg_type_id = p_msg_type_id;

    return 0;

end;$_$;


--
-- Name: acs_sc_msg_type__delete(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_msg_type__delete(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_msg_type_name		alias for $1;
    v_msg_type_id		integer;
begin

    v_msg_type_id := acs_sc_msg_type__get_id(p_msg_type_name);

    perform acs_sc_msg_type__delete(v_msg_type_id);

    return v_msg_type_id;

end;$_$;


--
-- Name: acs_sc_msg_type__get_id(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_msg_type__get_id(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_msg_type_name		alias for $1;
    v_msg_type_id		integer;
begin

    select msg_type_id into v_msg_type_id
    from acs_sc_msg_types
    where msg_type_name = p_msg_type_name;
   
    return v_msg_type_id;

end;$_$;


--
-- Name: acs_sc_msg_type__get_name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_msg_type__get_name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_msg_type_id		alias for $1;
    v_msg_type_name		varchar;
begin

    select msg_type_name into v_msg_type_name
    from acs_sc_msg_types
    where msg_type_id = p_msg_type_id;
   
    return v_msg_type_name;

end;$_$;


--
-- Name: acs_sc_msg_type__new(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_msg_type__new(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_msg_type_name             alias for $1;
    p_msg_type_spec		alias for $2;
    v_msg_type_id               integer;
begin

    v_msg_type_id := acs_object__new(
                null,
                'acs_sc_msg_type',
                now(),
                null,
                null,
                null
            );

    insert into acs_sc_msg_types (
        msg_type_id,
        msg_type_name
   ) values (
        v_msg_type_id,
        p_msg_type_name
    );

    perform acs_sc_msg_type__parse_spec(p_msg_type_name,p_msg_type_spec);

    return v_msg_type_id;

end;$_$;


--
-- Name: acs_sc_msg_type__new_element(character varying, character varying, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_msg_type__new_element(character varying, character varying, character varying, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_msg_type_name		alias for $1;
    p_element_name		alias for $2;
    p_element_msg_type_name	alias for $3;
    p_element_msg_type_isset_p	alias for $4;
    p_element_pos		alias for $5;
    v_msg_type_id		integer;
    v_element_msg_type_id	integer;
begin

    v_msg_type_id := acs_sc_msg_type__get_id(p_msg_type_name);

    if v_msg_type_id is null then
        raise exception 'Unknown Message Type: %', p_msg_type_name;
    end if;

    v_element_msg_type_id := acs_sc_msg_type__get_id(p_element_msg_type_name);

    if v_element_msg_type_id is null then
        raise exception 'Unknown Message Type: %', p_element_msg_type_name;
    end if;

    insert into acs_sc_msg_type_elements (
        msg_type_id,
	element_name,
	element_msg_type_id,
	element_msg_type_isset_p,
	element_pos
    ) values (
        v_msg_type_id,
	p_element_name,
	v_element_msg_type_id,
	p_element_msg_type_isset_p,
	p_element_pos
    );

    return v_msg_type_id;

end;$_$;


--
-- Name: acs_sc_msg_type__parse_spec(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_msg_type__parse_spec(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_msg_type_name		alias for $1;
    p_msg_type_spec		alias for $2;
    v_element			varchar;
    v_element_type		varchar;
    v_str_pos			integer;
    v_element_name		varchar;
    v_element_msg_type_name	varchar;
    v_element_msg_type_isset_p	boolean;
    v_element_pos		integer;
begin

    v_element_pos := 1;
    v_element := split(p_msg_type_spec, ',', v_element_pos);

    while v_element is not null loop

        v_str_pos = instr(v_element, ':', 1, 1);

	if v_str_pos > 0 then
	    v_element_name := trim(substr(v_element, 1, v_str_pos-1));
	    v_element_type := trim(substr(v_element, v_str_pos+1, length(v_element) - v_str_pos));
	    if (instr(v_element_type, '[',1,1) = length(v_element_type)-1) and 
	       (instr(v_element_type, ']',1,1) = length(v_element_type)) then
	        v_element_msg_type_isset_p := 't';
	        v_element_msg_type_name := trim(substr(v_element_type,1,length(v_element_type)-2));
		if v_element_msg_type_name = '' then
		    raise exception 'Wrong Format: Message Type Specification';
		end if;
	    else
	        v_element_msg_type_isset_p := 'f';
	        v_element_msg_type_name := v_element_type;
	    end if;
        else
	    raise exception 'Wrong Format: Message Type Specification';
        end if;

        perform acs_sc_msg_type__new_element(
                   p_msg_type_name,				-- msg_type_id
		   v_element_name,				-- element_name
		   v_element_msg_type_name,			-- element_msg_type_id
		   v_element_msg_type_isset_p,			-- element_msg_type_isset_p
		   v_element_pos				-- element_pos
        );

        v_element_pos := v_element_pos + 1;
	v_element := split(p_msg_type_spec, ',', v_element_pos);

    end loop;

    return v_element_pos-1;

end;$_$;


--
-- Name: acs_sc_operation__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_operation__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_operation_id		alias for $1;
begin

    delete from acs_sc_operations
    where operation_id = p_operation_id;

    return 0;

end;$_$;


--
-- Name: acs_sc_operation__delete(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_operation__delete(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_name		alias for $1;
    p_operation_name		alias for $2;
    v_operation_id		integer;
begin

    v_operation_id := acs_sc_operation__get_id(
		          p_contract_name,
			  p_operation_name
		      );

    perform acs_sc_operation__delete(v_operation_id);

    return v_operation_id;

end;$_$;


--
-- Name: acs_sc_operation__get_id(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_operation__get_id(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_name		alias for $1;
    p_operation_name            alias for $2;
    v_operation_id               integer;
begin

    select operation_id into v_operation_id
    from acs_sc_operations
    where contract_name = p_contract_name 
    and operation_name = p_operation_name;

    return v_operation_id;

end;$_$;


--
-- Name: acs_sc_operation__new(character varying, character varying, text, boolean, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_sc_operation__new(character varying, character varying, text, boolean, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_contract_name		alias for $1;
    p_operation_name            alias for $2;
    p_operation_desc		alias for $3;
    p_operation_iscachable_p	alias for $4;
    p_operation_nargs		alias for $5;
    p_operation_inputtype	alias for $6;
    p_operation_outputtype	alias for $7;
    v_contract_id               integer;
    v_operation_id		integer;
    v_operation_inputtype_id	integer;
    v_operation_outputtype_id	integer;
begin

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    v_operation_id := acs_object__new(
                         null,
                         'acs_sc_operation',
                         now(),
                         null,
                         null,
                         null
                     );

     v_operation_inputtype_id := acs_sc_msg_type__get_id(p_operation_inputtype);

     v_operation_outputtype_id := acs_sc_msg_type__get_id(p_operation_outputtype);

    insert into acs_sc_operations (
        contract_id,
        operation_id,
	contract_name,
	operation_name,
	operation_desc,
	operation_iscachable_p,
	operation_nargs,
	operation_inputtype_id,
	operation_outputtype_id
    ) values (
        v_contract_id,
        v_operation_id,
	p_contract_name,
	p_operation_name,
	p_operation_desc,
	p_operation_iscachable_p,
	p_operation_nargs,
	v_operation_inputtype_id,
	v_operation_outputtype_id
    );

    return v_operation_id;

end;$_$;


--
-- Name: acs_user__approve_email(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_user__approve_email(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  approve_email__user_id        alias for $1;  
begin
    update users
    set email_verified_p = 't'
    where user_id = approve_email__user_id;

    return 0; 
end;$_$;


--
-- Name: acs_user__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_user__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__user_id       alias for $1;  
begin
  delete from user_preferences
  where user_id = delete__user_id;

  delete from users
  where user_id = delete__user_id;

  PERFORM person__delete(delete__user_id);

  return 0; 
end;$_$;


--
-- Name: acs_user__new(character varying, character varying, character varying, character, character); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_user__new(character varying, character varying, character varying, character, character) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        email   alias for $1;
        fname   alias for $2;
        lname   alias for $3;
        pword   alias for $4;
        salt    alias for $5;
begin
        return acs_user__new(null,
                             'user',
                             now(),
                             null,
                             null,                
                             email,
                             null,
                             fname,
                             lname,
                             pword,
                             salt,
                             null,
                             null,
                             null,
                             't',
                             null
                             );

end;$_$;


--
-- Name: acs_user__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character, character, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_user__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character, character, character varying, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_user_id                  alias for $1;  -- default null  
    p_object_type              alias for $2;  -- default 'user'
    p_creation_date            alias for $3;  -- default now()
    p_creation_user            alias for $4;  -- default null
    p_creation_ip              alias for $5;  -- default null
    p_authority_id             alias for $6;  -- defaults to local authority
    p_username                 alias for $7;  --
    p_email                    alias for $8;  
    p_url                      alias for $9;  -- default null
    p_first_names              alias for $10;  
    p_last_name                alias for $11;  
    p_password                 alias for $12; 
    p_salt                     alias for $13; 
    p_screen_name              alias for $14; -- default null
    p_email_verified_p         alias for $15; -- default 't'
    p_context_id               alias for $16; -- default null
    v_user_id                  users.user_id%TYPE;
    v_authority_id             auth_authorities.authority_id%TYPE;
    v_person_exists            varchar;			
begin
    v_user_id := p_user_id;

    select case when count(*) = 0 then 'f' else 't' end into v_person_exists
    from persons where person_id = v_user_id;

    if v_person_exists = 'f' then
        v_user_id := person__new(
            v_user_id, 
            p_object_type,
            p_creation_date, 
            p_creation_user, 
            p_creation_ip,
            p_email, 
            p_url, 
            p_first_names, 
            p_last_name, 
            p_context_id
        );
    else
     update acs_objects set object_type = 'user' where object_id = v_user_id;
    end if;

    -- default to local authority
    if p_authority_id is null then
        select authority_id
        into   v_authority_id
        from   auth_authorities
        where  short_name = 'local';
    else
        v_authority_id := p_authority_id;
    end if;

    insert into users
       (user_id, authority_id, username, password, salt, screen_name, email_verified_p)
    values
       (v_user_id, v_authority_id, p_username, p_password, p_salt, p_screen_name, p_email_verified_p);

    insert into user_preferences
      (user_id)
      values
      (v_user_id);

    return v_user_id;
  
end;$_$;


--
-- Name: acs_user__receives_alerts_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_user__receives_alerts_p(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  receives_alerts_p__user_id                alias for $1;  
  counter                                   boolean;       
begin
  select case when count(*) = 0 then 'f' else 't' end into counter
   from users
   where no_alerts_until >= now()
   and user_id = receives_alerts_p__user_id;

  return counter;
  
end;$_$;


--
-- Name: acs_user__unapprove_email(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_user__unapprove_email(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unapprove_email__user_id      alias for $1;  
begin
    update users
    set email_verified_p = 'f'
    where user_id = unapprove_email__user_id;

    return 0; 
end;$_$;


--
-- Name: acs_util__boolean_query(character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_util__boolean_query(character varying, boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  query_in		alias for $1;
  not_flag_in		alias for $2;
  v_sql_query		varchar;
  v_row_count		integer;
begin
  v_sql_query := 'select 1 where ';

  if not_flag_in then
    v_sql_query := v_sql_query || 'not ';
  end if;

  execute v_sql_query || 'exists (' || query_in || ')';

  get diagnostics v_row_count = ROW_COUNT;

  if v_row_count = 1 then
    return 't';
  else
    return 'f';
  end if;

end;$_$;


--
-- Name: acs_util__has_children(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_util__has_children(character varying, character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  item_id_in		alias for $1;
  table_name_in		alias for $2;
  parent_column_in	alias for $3;
  v_row_count		integer;
begin
  execute 'select 1 where exists (select 1 from '
	    || quote_ident(table_name_in)
	    || ' where '
	    || quote_ident(parent_column_in)
	    || ' = '
	    || quote_literal(item_id_in)
	    || ')';
  get diagnostics v_row_count = ROW_COUNT;
  if v_row_count = 1 then
     return 't';
  else
     return 'f';
  end if;
end;$_$;


--
-- Name: acs_util__sql_to_tcl_string(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION acs_util__sql_to_tcl_string(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  string_in	alias for $1;
begin
  if instr(string_in, ' ') <> 0 then
    return '{' || string_in || '}';
  else
    return string_in;
  end if;
end;$_$;


--
-- Name: add_months(timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION add_months(timestamp with time zone, integer) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
declare
       add_months__somedate	alias for $1;
       add_months__n_months	alias for $2;
begin

	-- Date math magic
	return add_months__somedate + to_interval(add_months__n_months,'months');

end;$_$;


--
-- Name: admin_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION admin_rel__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  rel_id                 alias for $1;  
begin
    PERFORM membership_rel__delete(rel_id);

    return 0; 
end;$_$;


--
-- Name: admin_rel__new(integer, character varying, integer, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION admin_rel__new(integer, character varying, integer, integer, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_rel_id               alias for $1;  -- default null  
  p_rel_type             alias for $2;  -- default 'admin_rel'
  p_object_id_one        alias for $3;  
  p_object_id_two        alias for $4;  
  p_member_state      alias for $5;  -- default 'approved'
  p_creation_user        alias for $6;  -- default null
  p_creation_ip          alias for $7;  -- default null
  v_rel_id               integer;       
begin
    v_rel_id := membership_rel__new (
      p_rel_id,           -- rel_id
      p_rel_type,         -- rel_type
      p_object_id_one,    -- object_id_one
      p_object_id_two,    -- object_id_two
      p_member_state,     -- member_state
      p_creation_user,    -- creation_usre
      p_creation_ip       -- creation_ip
    );

    insert into admin_rels
     (rel_id)
    values
     (v_rel_id);

    return v_rel_id;
   
end;$_$;


--
-- Name: admin_rel__new(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION admin_rel__new(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  object_id_one          alias for $1;  
  object_id_two          alias for $2;  
begin
    return membership_rel__new(
        null,                  -- rel_id
        'admin_rel',         -- rel_type
        object_id_one,         -- object_id_one
        object_id_two,         -- object_id_two
        'approved',          -- member_state
        null,                  -- creation_user
        null                   -- creation_ip
    );
end;$_$;


--
-- Name: apm__get_value(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__get_value(integer, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  get_value__parameter_id           alias for $1;  
  get_value__package_id             alias for $2;  
  value                             apm_parameter_values.attr_value%TYPE;
begin
    select attr_value into value from apm_parameter_values v
    where v.package_id = get_value__package_id
    and parameter_id = get_value__parameter_id;

    return value;
   
end;$_$;


--
-- Name: apm__get_value(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__get_value(integer, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  get_value__package_id             alias for $1;  
  get_value__parameter_name         alias for $2;  
  v_parameter_id                    apm_parameter_values.parameter_id%TYPE;
begin
    select parameter_id into v_parameter_id 
    from apm_parameters 
    where parameter_name = get_value__parameter_name
    and package_key = (select package_key  from apm_packages
			where package_id = get_value__package_id);
    return apm__get_value(
	v_parameter_id,
	get_value__package_id
    );	
   
end;$_$;


--
-- Name: apm__id_for_name(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__id_for_name(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  id_for_name__parameter_name         alias for $1;  
  id_for_name__package_key            alias for $2;  
  a_parameter_id                      apm_parameters.parameter_id%TYPE;
begin
    select parameter_id into a_parameter_id
    from apm_parameters p
    where p.parameter_name = id_for_name__parameter_name and
          p.package_key = id_for_name__package_key;

    return a_parameter_id;
   
end;$_$;


--
-- Name: apm__parameter_p(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__parameter_p(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  parameter_p__package_key            alias for $1;  
  parameter_p__parameter_name         alias for $2;  
  v_parameter_p                       integer;       
begin
    select case when count(*) = 0 then 0 else 1 end into v_parameter_p 
    from apm_parameters
    where package_key = parameter_p__package_key
    and parameter_name = parameter_p__parameter_name;

    return v_parameter_p;
   
end;$_$;


--
-- Name: apm__register_application(character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__register_application(character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  package_key            alias for $1;  
  pretty_name            alias for $2;  
  pretty_plural          alias for $3;  
  package_uri            alias for $4;  
  initial_install_p      alias for $5;  -- default 'f' 
  singleton_p            alias for $6;  -- default 'f' 
  spec_file_path         alias for $7;  -- default null
  spec_file_mtime        alias for $8;  -- default null
begin
   PERFORM apm__register_package(
	package_key,
	pretty_name,
	pretty_plural,
	package_uri,
	'apm_application',
	initial_install_p,
	singleton_p,
	spec_file_path,
	spec_file_mtime
   ); 

   return 0; 
end;$_$;


--
-- Name: apm__register_p(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__register_p(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  register_p__package_key            alias for $1;  
  v_register_p                       integer;       
begin
    select case when count(*) = 0 then 0 else 1 end into v_register_p 
    from apm_package_types 
    where package_key = register_p__package_key;

    return v_register_p;
   
end;$_$;


--
-- Name: apm__register_package(character varying, character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__register_package(character varying, character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  package_key            alias for $1;  
  pretty_name            alias for $2;  
  pretty_plural          alias for $3;  
  package_uri            alias for $4;  
  package_type           alias for $5;  
  initial_install_p      alias for $6;  -- default 'f'  
  singleton_p            alias for $7;  -- default 'f'  
  spec_file_path         alias for $8;  -- default null
  spec_file_mtime        alias for $9;  -- default null
begin
    PERFORM apm_package_type__create_type(
    	package_key,
	pretty_name,
	pretty_plural,
	package_uri,
	package_type,
	initial_install_p,
	singleton_p,
	spec_file_path,
	spec_file_mtime
    );

    return 0; 
end;$_$;


--
-- Name: apm__register_parameter(integer, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__register_parameter(integer, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  register_parameter__parameter_id           alias for $1;  -- default null  
  register_parameter__package_key            alias for $2;  
  register_parameter__parameter_name         alias for $3;  
  register_parameter__description            alias for $4;  -- default null  
  register_parameter__datatype               alias for $5;  -- default 'string'  
  register_parameter__default_value          alias for $6;  -- default null  
  register_parameter__section_name           alias for $7;  -- default null 
  register_parameter__min_n_values           alias for $8;  -- default 1
  register_parameter__max_n_values           alias for $9;  -- default 1

  v_parameter_id         apm_parameters.parameter_id%TYPE;
  cur_val                record;
begin
    -- Create the new parameter.    
    v_parameter_id := acs_object__new(
       register_parameter__parameter_id,
       'apm_parameter',
       now(),
       null,
       null,
       null,
       't',
       register_parameter__package_key || ': Parameter ' || register_parameter__parameter_name,
       null
    );
    
    insert into apm_parameters 
    (parameter_id, parameter_name, description, package_key, datatype, 
    default_value, section_name, min_n_values, max_n_values)
    values
    (v_parameter_id, register_parameter__parameter_name, 
     register_parameter__description, register_parameter__package_key, 
     register_parameter__datatype, register_parameter__default_value, 
     register_parameter__section_name, register_parameter__min_n_values, 
     register_parameter__max_n_values);

    -- Propagate parameter to new instances.	
    for cur_val in select ap.package_id, p.parameter_id, p.default_value 
       from apm_parameters p left outer join apm_parameter_values v 
             using (parameter_id), apm_packages ap
      where p.package_key = ap.package_key
        and v.attr_value is null
        and p.package_key = register_parameter__package_key
      loop
      	PERFORM apm__set_value(
	    cur_val.parameter_id, 
	    cur_val.package_id,
	    cur_val.default_value
	    ); 	
      end loop;	
	
    return v_parameter_id;
   
end;$_$;


--
-- Name: apm__register_service(character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__register_service(character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  package_key            alias for $1;  
  pretty_name            alias for $2;  
  pretty_plural          alias for $3;  
  package_uri            alias for $4;  
  initial_install_p      alias for $5;  -- default 'f'  
  singleton_p            alias for $6;  -- default 'f'  
  spec_file_path         alias for $7;  -- default null
  spec_file_mtime        alias for $8;  -- default null
begin
   PERFORM apm__register_package(
	package_key,
	pretty_name,
	pretty_plural,
	package_uri,
	'apm_service',
	initial_install_p,
	singleton_p,
	spec_file_path,
	spec_file_mtime
   );  
 
   return 0; 
end;$_$;


--
-- Name: apm__set_value(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__set_value(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_value__parameter_id           alias for $1;  
  set_value__package_id             alias for $2;  
  set_value__attr_value             alias for $3;  
  v_value_id                        apm_parameter_values.value_id%TYPE;
begin
    -- Determine if the value exists
    select value_id into v_value_id from apm_parameter_values 
     where parameter_id = set_value__parameter_id 
     and package_id = set_value__package_id;
    update apm_parameter_values set attr_value = set_value__attr_value
     where parameter_id = set_value__parameter_id 
     and package_id = set_value__package_id;    
   --  exception 
     if NOT FOUND
       then
         v_value_id := apm_parameter_value__new(
            null,
            set_value__package_id,
            set_value__parameter_id,
            set_value__attr_value
         );
     end if;

     return 0; 
end;$_$;


--
-- Name: apm__set_value(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__set_value(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_value__package_id             alias for $1;  
  set_value__parameter_name         alias for $2;  
  set_value__attr_value             alias for $3;  
  v_parameter_id                    apm_parameter_values.parameter_id%TYPE;
begin
    select parameter_id into v_parameter_id 
    from apm_parameters 
    where parameter_name = set_value__parameter_name
    and package_key = (select package_key  from apm_packages
			where package_id = set_value__package_id);

    if NOT FOUND
      then
      	raise EXCEPTION '-20000: The specified package % AND/OR parameter % do not exist in the system', set_value__package_id, set_value__parameter_name;
    end if;

    PERFORM apm__set_value(
	v_parameter_id,
	set_value__package_id,
	set_value__attr_value
    );

    return 0; 
end;$_$;


--
-- Name: apm__unregister_application(character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__unregister_application(character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  package_key            alias for $1;  
  p_cascade_p              alias for $2;  -- default 'f'  
  v_cascade_p            boolean;
begin
   if p_cascade_p is null then 
	v_cascade_p := 'f';
   else 
       v_cascade_p := p_cascade_p;
   end if;

   PERFORM apm__unregister_package (
        package_key,
        v_cascade_p
   );

   return 0; 
end;$_$;


--
-- Name: apm__unregister_package(character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__unregister_package(character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  package_key            alias for $1;  
  p_cascade_p            alias for $2;  -- default 't'  
  v_cascade_p            boolean;
begin
   if cascade_p is null then 
	v_cascade_p := 't';
   else 
       v_cascade_p := p_cascade_p;
   end if;

   PERFORM apm_package_type__drop_type(
	package_key,
	v_cascade_p
   );

   return 0; 
end;$_$;


--
-- Name: apm__unregister_parameter(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__unregister_parameter(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unregister_parameter__parameter_id           alias for $1;  -- default null
begin
    delete from apm_parameter_values 
    where parameter_id = unregister_parameter__parameter_id;
    delete from apm_parameters 
    where parameter_id = unregister_parameter__parameter_id;
    PERFORM acs_object__delete(unregister_parameter__parameter_id);

    return 0; 
end;$_$;


--
-- Name: apm__unregister_service(character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__unregister_service(character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  package_key           alias for $1;  
  p_cascade_p           alias for $2;  -- default 'f'  
  v_cascade_p           boolean;
begin
   if p_cascade_p is null then 
	v_cascade_p := 'f';
   else 
	v_cascade_p := p_cascade_p;
   end if;

   PERFORM apm__unregister_package (
	package_key,
	v_cascade_p
   );

   return 0; 
end;$_$;


--
-- Name: apm__update_package(character varying, character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__update_package(character varying, character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  package_key            alias for $1;  
  pretty_name            alias for $2;  -- default null
  pretty_plural          alias for $3;  -- default null  
  package_uri            alias for $4;  -- default null  
  package_type           alias for $5;  -- default null  
  initial_install_p      alias for $6;  -- default null  
  singleton_p            alias for $7;  -- default null  
  spec_file_path         alias for $8;  -- default null  
  spec_file_mtime        alias for $9;  -- default null  
begin
 
    return apm_package_type__update_type(
    	package_key,
	pretty_name,
	pretty_plural,
	package_uri,
	package_type,
	initial_install_p,
	singleton_p,
	spec_file_path,
	spec_file_mtime
    );
   
end;$_$;


--
-- Name: apm__update_parameter(integer, character varying, character varying, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm__update_parameter(integer, character varying, character varying, character varying, character varying, character varying, integer, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  update_parameter__parameter_id           alias for $1;  
  update_parameter__parameter_name         alias for $2;  -- default null  
  update_parameter__description            alias for $3;  -- default null
  update_parameter__datatype               alias for $4;  -- default 'string'
  update_parameter__default_value          alias for $5;  -- default null
  update_parameter__section_name           alias for $6;  -- default null
  update_parameter__min_n_values           alias for $7;  -- default 1
  update_parameter__max_n_values           alias for $8;  -- default 1
begin
    update apm_parameters 
	set parameter_name = coalesce(update_parameter__parameter_name, parameter_name),
            default_value  = coalesce(update_parameter__default_value, default_value),
            datatype       = coalesce(update_parameter__datatype, datatype), 
	    description	   = coalesce(update_parameter__description, description),
	    section_name   = coalesce(update_parameter__section_name, section_name),
            min_n_values   = coalesce(update_parameter__min_n_values, min_n_values),
            max_n_values   = coalesce(update_parameter__max_n_values, max_n_values)
      where parameter_id = update_parameter__parameter_id;

    update acs_objects
       set title = (select package_key || ': Parameter ' || parameter_name
                    from apm_parameters
                    where parameter_id = update_parameter__parameter_id)
     where object_id = update_parameter__parameter_id;

    return parameter_id;
     
end;$_$;


--
-- Name: apm_application__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_application__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__application_id         alias for $1;  
begin
    delete from apm_applications
    where application_id = delete__application_id;
    PERFORM apm_package__delete(
        delete__application_id
    );

    return 0; 
end;$_$;


--
-- Name: apm_application__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_application__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  application_id         alias for $1;  -- default null  
  instance_name          alias for $2;  -- default null
  package_key            alias for $3;  
  object_type            alias for $4;  -- default 'apm_application'
  creation_date          alias for $5;  -- default now()
  creation_user          alias for $6;  -- default null
  creation_ip            alias for $7;  -- default null
  context_id             alias for $8;  -- default null
  v_application_id       integer;       
begin
    v_application_id := apm_package__new (
      application_id,
      instance_name,
      package_key,
      object_type,
      creation_date,
      creation_user,
      creation_ip,
      context_id
    );

    return v_application_id;
   
end;$_$;


--
-- Name: apm_package__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
   delete__package_id   alias for $1;
   cur_val              record;
begin
    -- Delete all parameters.
    for cur_val in select value_id from apm_parameter_values
	where package_id = delete__package_id loop
    	PERFORM apm_parameter_value__delete(cur_val.value_id);
    end loop;    

    delete from apm_applications where application_id = delete__package_id;
    delete from apm_services where service_id = delete__package_id;
    delete from apm_packages where package_id = delete__package_id;
    -- Delete the site nodes for the objects.
    for cur_val in select node_id from site_nodes
	where object_id = delete__package_id loop
    	PERFORM site_node__delete(cur_val.node_id);
    end loop;
    -- Delete the object.
    PERFORM acs_object__delete (
       delete__package_id
    );   

    return 0;
end;$_$;


--
-- Name: apm_package__highest_version(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package__highest_version(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
     highest_version__package_key    alias for $1;
     v_version_id                    apm_package_versions.version_id%TYPE;
begin
     select version_id into v_version_id
	from apm_package_version_info i 
	where apm_package_version__sortable_version_name(version_name) = 
             (select max(apm_package_version__sortable_version_name(v.version_name))
	             from apm_package_version_info v where v.package_key = highest_version__package_key)
	and package_key = highest_version__package_key;
      if NOT FOUND then 
         return 0;
      else
         return v_version_id;
      end if;
end;$_$;


--
-- Name: apm_package__initial_install_p(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package__initial_install_p(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	initial_install_p__package_key  alias for $1;
        v_initial_install_p             integer;
begin
        select 1 into v_initial_install_p
	from apm_package_types
	where package_key = initial_install_p__package_key
        and initial_install_p = 't';
	
        if NOT FOUND then 
           return 0;
        else
           return v_initial_install_p;
        end if;
end;$_$;


--
-- Name: apm_package__initialize_parameters(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package__initialize_parameters(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  ip__package_id             alias for $1;  
  ip__package_key            alias for $2;  
  v_value_id                 apm_parameter_values.value_id%TYPE;
  cur_val                    record;
begin
    -- need to initialize all params for this type
    for cur_val in select parameter_id, default_value
       from apm_parameters
       where package_key = ip__package_key
      loop
        v_value_id := apm_parameter_value__new(
          null,
          ip__package_id,
          cur_val.parameter_id,
          cur_val.default_value
        ); 
      end loop;   

      return 0; 
end;$_$;


--
-- Name: apm_package__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    name__package_id       alias for $1;
    v_result               apm_packages.instance_name%TYPE;
begin
    select instance_name into v_result
    from apm_packages
    where package_id = name__package_id;

    return v_result;

end;$_$;


--
-- Name: apm_package__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__package_id             alias for $1;  -- default null  
  new__instance_name          alias for $2;  -- default null
  new__package_key            alias for $3;  
  new__object_type            alias for $4;  -- default 'apm_package'
  new__creation_date          alias for $5;  -- default now()
  new__creation_user          alias for $6;  -- default null
  new__creation_ip            alias for $7;  -- default null
  new__context_id             alias for $8;  -- default null
  v_singleton_p               integer;       
  v_package_type              apm_package_types.package_type%TYPE;
  v_num_instances             integer;       
  v_package_id                apm_packages.package_id%TYPE;
  v_instance_name             apm_packages.instance_name%TYPE;
begin
   v_singleton_p := apm_package__singleton_p(
			new__package_key
		    );
   v_num_instances := apm_package__num_instances(
			new__package_key
		    );
  
   if v_singleton_p = 1 and v_num_instances >= 1 then
       select package_id into v_package_id 
       from apm_packages
       where package_key = new__package_key;

       return v_package_id;
   else
       v_package_id := acs_object__new(
          new__package_id,
          new__object_type,
          new__creation_date,
          new__creation_user,
	  new__creation_ip,
	  new__context_id
	 );
       if new__instance_name is null or new__instance_name = '' then 
	 v_instance_name := new__package_key || ' ' || v_package_id;
       else
	 v_instance_name := new__instance_name;
       end if;

       select package_type into v_package_type
       from apm_package_types
       where package_key = new__package_key;

       insert into apm_packages
       (package_id, package_key, instance_name)
       values
       (v_package_id, new__package_key, v_instance_name);

       update acs_objects
       set title = v_instance_name,
           package_id = v_package_id
       where object_id = v_package_id;

       if v_package_type = 'apm_application' then
	   insert into apm_applications
	   (application_id)
	   values
	   (v_package_id);
       else
	   insert into apm_services
	   (service_id)
	   values
	   (v_package_id);
       end if;

       PERFORM apm_package__initialize_parameters(
	   v_package_id,
	   new__package_key
       );

       return v_package_id;

  end if;
end;$_$;


--
-- Name: apm_package__num_instances(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package__num_instances(character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
declare
        num_instances__package_key     alias for $1;
        v_num_instances                integer;
begin
        select count(*) into v_num_instances
	from apm_packages
	where package_key = num_instances__package_key;

        return v_num_instances;

end;$_$;


--
-- Name: apm_package__parent_id(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package__parent_id(integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
    apm_package__parent_id__package_id alias for $1;
    v_package_id apm_packages.package_id%TYPE;
begin
    select sn1.object_id
    into v_package_id
    from site_nodes sn1
    where sn1.node_id = (select sn2.parent_id
                         from site_nodes sn2
                         where sn2.object_id = apm_package__parent_id__package_id);

    return v_package_id;

end;$_$;


--
-- Name: apm_package__singleton_p(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package__singleton_p(character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
declare
	singleton_p__package_key        alias for $1;
        v_singleton_p                   integer;
begin
        select count(*) into v_singleton_p
	from apm_package_types
	where package_key = singleton_p__package_key
        and singleton_p = 't';

        return v_singleton_p;
end;$_$;


--
-- Name: apm_package_type__create_type(character varying, character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_type__create_type(character varying, character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_type__package_key            alias for $1;  
  create_type__pretty_name            alias for $2;  
  create_type__pretty_plural          alias for $3;  
  create_type__package_uri            alias for $4;  
  create_type__package_type           alias for $5;  
  create_type__initial_install_p      alias for $6;  
  create_type__singleton_p            alias for $7;  
  create_type__spec_file_path         alias for $8;  -- default null  
  create_type__spec_file_mtime        alias for $9;  -- default null
begin
   insert into apm_package_types
    (package_key, pretty_name, pretty_plural, package_uri, package_type,
    spec_file_path, spec_file_mtime, initial_install_p, singleton_p)
   values
    (create_type__package_key, create_type__pretty_name, create_type__pretty_plural,
     create_type__package_uri, create_type__package_type, create_type__spec_file_path, 
     create_type__spec_file_mtime, create_type__initial_install_p, create_type__singleton_p);

   return 0; 
end;$_$;


--
-- Name: apm_package_type__drop_type(character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_type__drop_type(character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_type__package_key            alias for $1;  
  drop_type__cascade_p              alias for $2;  -- default 'f'
  cur_val                           record; 
begin
    if drop_type__cascade_p = 't' then
        for cur_val in select package_id
       from apm_packages
       where package_key = drop_type__package_key
        loop
            PERFORM apm_package__delete(
	        cur_val.package_id
	    );
        end loop;
	-- Unregister all parameters.
        for cur_val in select parameter_id from apm_parameters
       where package_key = drop_type__package_key
	loop
	    PERFORM apm__unregister_parameter(cur_val.parameter_id);
	end loop;
  
        -- Unregister all versions
	for cur_val in select version_id from apm_package_versions
       where package_key = drop_type__package_key
	loop
	    PERFORM apm_package_version__delete(cur_val.version_id);
        end loop;
    end if;
    delete from apm_package_types
    where package_key = drop_type__package_key;

    return 0; 
end;$_$;


--
-- Name: apm_package_type__num_parameters(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_type__num_parameters(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  num_parameters__package_key            alias for $1;  
  v_count                                integer;       
begin
    select count(*) into v_count
    from apm_parameters
    where package_key = num_parameters__package_key;

    return v_count;
   
end;$_$;


--
-- Name: apm_package_type__update_type(character varying, character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_type__update_type(character varying, character varying, character varying, character varying, character varying, boolean, boolean, character varying, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  update_type__package_key            alias for $1;  
  update_type__pretty_name            alias for $2;  -- default null  
  update_type__pretty_plural          alias for $3;  -- default null
  update_type__package_uri            alias for $4;  -- default null
  update_type__package_type           alias for $5;  -- default null  
  update_type__initial_install_p      alias for $6;  -- default null  
  update_type__singleton_p            alias for $7;  -- default null  
  update_type__spec_file_path         alias for $8;  -- default null  
  update_type__spec_file_mtime        alias for $9;  -- default null  
begin
      UPDATE apm_package_types SET
      	pretty_name = coalesce(update_type__pretty_name, pretty_name),
    	pretty_plural = coalesce(update_type__pretty_plural, pretty_plural),
    	package_uri = coalesce(update_type__package_uri, package_uri),
    	package_type = coalesce(update_type__package_type, package_type),
    	spec_file_path = coalesce(update_type__spec_file_path, spec_file_path),
    	spec_file_mtime = coalesce(update_type__spec_file_mtime, spec_file_mtime),
    	singleton_p = coalesce(update_type__singleton_p, singleton_p),
    	initial_install_p = coalesce(update_type__initial_install_p, initial_install_p)
      where package_key = update_type__package_key;

      return update_type__package_key;
   
end;$_$;


--
-- Name: apm_package_version__add_dependency(integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__add_dependency(integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_dependency__dependency_id          alias for $1;  -- default null  
  add_dependency__version_id             alias for $2;  
  add_dependency__dependency_uri         alias for $3;  
  add_dependency__dependency_version     alias for $4;  
  v_dep_id                            apm_package_dependencies.dependency_id%TYPE;
begin
      if add_dependency__dependency_id is null then
          select acs_object_id_seq.nextval into v_dep_id from dual;
      else
          v_dep_id := add_dependency__dependency_id;
      end if;
  
      insert into apm_package_dependencies
      (dependency_id, version_id, dependency_type, service_uri, service_version)
      values
      (v_dep_id, add_dependency__version_id, 'requires', add_dependency__dependency_uri,
	add_dependency__dependency_version);

      return v_dep_id;
   
end;$_$;


--
-- Name: apm_package_version__add_interface(integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__add_interface(integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_interface__interface_id         alias for $1;  -- default null  
  add_interface__version_id           alias for $2;  
  add_interface__interface_uri        alias for $3;  
  add_interface__interface_version    alias for $4;  
  v_dep_id                            apm_package_dependencies.dependency_id%TYPE;
begin
      if add_interface__interface_id is null then
          select acs_object_id_seq.nextval into v_dep_id from dual;
      else
          v_dep_id := add_interface__interface_id;
      end if;
  
      insert into apm_package_dependencies
      (dependency_id, version_id, dependency_type, service_uri, service_version)
      values
      (v_dep_id, add_interface__version_id, 'provides', add_interface__interface_uri,
	add_interface__interface_version);

      return v_dep_id;
   
end;$_$;


--
-- Name: apm_package_version__copy(integer, integer, character varying, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__copy(integer, integer, character varying, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  copy__version_id             alias for $1;  
  copy__new_version_id         alias for $2;  -- default null  
  copy__new_version_name       alias for $3;  
  copy__new_version_uri        alias for $4;  
  copy__copy_owners_p          alias for $5;
  v_version_id                 integer;       
begin
	v_version_id := acs_object__new(
		copy__new_version_id,
		'apm_package_version',
                now(),
                null,
                null,
                null
        );    

	insert into apm_package_versions(version_id, package_key, version_name,
					version_uri, summary, description_format, description,
					release_date, vendor, vendor_uri, auto_mount)
	    select v_version_id, package_key, copy__new_version_name,
		   copy__new_version_uri, summary, description_format, description,
		   release_date, vendor, vendor_uri, auto_mount
	    from apm_package_versions
	    where version_id = copy__version_id;
    
        update acs_objects
        set title = (select v.package_key || ', Version ' || v.version_name
                     from apm_package_versions v
                     where v.version_id = copy__version_id)
        where object_id = copy__version_id;

	insert into apm_package_dependencies(dependency_id, version_id, dependency_type, service_uri, service_version)
	    select nextval('t_acs_object_id_seq'), v_version_id, dependency_type, service_uri, service_version
	    from apm_package_dependencies
	    where version_id = copy__version_id;
    
        insert into apm_package_callbacks (version_id, type, proc)
                select v_version_id, type, proc
                from apm_package_callbacks
                where version_id = copy__version_id;
    
        if copy__copy_owners_p then
            insert into apm_package_owners(version_id, owner_uri, owner_name, sort_key)
                select v_version_id, owner_uri, owner_name, sort_key
                from apm_package_owners
                where version_id = copy__version_id;
        end if;
    
	return v_version_id;
   
end;$_$;


--
-- Name: apm_package_version__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__version_id             alias for $1;  
begin
      delete from apm_package_owners 
      where version_id = delete__version_id; 

      delete from apm_package_dependencies
      where version_id = delete__version_id;

      delete from apm_package_versions 
	where version_id = delete__version_id;

      PERFORM acs_object__delete(delete__version_id);

      return 0; 
end;$_$;


--
-- Name: apm_package_version__disable(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__disable(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  disable__version_id             alias for $1;  
begin
      update apm_package_versions 
      set enabled_p = 'f'
      where version_id = disable__version_id;	

      return 0; 
end;$_$;


--
-- Name: apm_package_version__edit(integer, integer, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__edit(integer, integer, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  edit__new_version_id         alias for $1;  -- default null  
  edit__version_id             alias for $2;  
  edit__version_name           alias for $3;  -- default null
  edit__version_uri            alias for $4;  
  edit__summary                alias for $5;  
  edit__description_format     alias for $6;  
  edit__description            alias for $7;  
  edit__release_date           alias for $8;  
  edit__vendor                 alias for $9;  
  edit__vendor_uri             alias for $10; 
  edit__installed_p            alias for $11; -- default 'f'
  edit__data_model_loaded_p    alias for $12; -- default 'f'
  v_version_id                 apm_package_versions.version_id%TYPE;
  version_unchanged_p          integer;       
begin
       -- Determine if version has changed.
       select case when count(*) = 0 then 0 else 1 end into version_unchanged_p
       from apm_package_versions
       where version_id = edit__version_id
       and version_name = edit__version_name;
       if version_unchanged_p <> 1 then
         v_version_id := apm_package_version__copy(
			 edit__version_id,
			 edit__new_version_id,
			 edit__version_name,
			 edit__version_uri,
                         'f'
			);
         else 
	   v_version_id := edit__version_id;			
       end if;
       
       update apm_package_versions 
		set version_uri = edit__version_uri,
		summary = edit__summary,
		description_format = edit__description_format,
		description = edit__description,
		release_date = date_trunc('days',now()),
		vendor = edit__vendor,
		vendor_uri = edit__vendor_uri,
		installed_p = edit__installed_p,
		data_model_loaded_p = edit__data_model_loaded_p
	    where version_id = v_version_id;

	return v_version_id;
     
end;$_$;


--
-- Name: apm_package_version__edit(integer, integer, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__edit(integer, integer, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, character varying, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  edit__new_version_id         alias for $1;  -- default null  
  edit__version_id             alias for $2;  
  edit__version_name           alias for $3;  -- default null
  edit__version_uri            alias for $4;  
  edit__summary                alias for $5;  
  edit__description_format     alias for $6;  
  edit__description            alias for $7;  
  edit__release_date           alias for $8;  
  edit__vendor                 alias for $9;  
  edit__vendor_uri             alias for $10; 
  edit__auto_mount             alias for $11;
  edit__installed_p            alias for $12; -- default 'f'
  edit__data_model_loaded_p    alias for $13; -- default 'f'
  v_version_id                 apm_package_versions.version_id%TYPE;
  version_unchanged_p          integer;       
begin
       -- Determine if version has changed.
       select case when count(*) = 0 then 0 else 1 end into version_unchanged_p
       from apm_package_versions
       where version_id = edit__version_id
       and version_name = edit__version_name;
       if version_unchanged_p <> 1 then
         v_version_id := apm_package_version__copy(
			 edit__version_id,
			 edit__new_version_id,
			 edit__version_name,
			 edit__version_uri,
                         'f'
			);
         else 
	   v_version_id := edit__version_id;			
       end if;
       
       update apm_package_versions 
		set version_uri = edit__version_uri,
		summary = edit__summary,
		description_format = edit__description_format,
		description = edit__description,
		release_date = date_trunc('days',now()),
		vendor = edit__vendor,
		vendor_uri = edit__vendor_uri,
                auto_mount = edit__auto_mount,
		installed_p = edit__installed_p,
		data_model_loaded_p = edit__data_model_loaded_p
	    where version_id = v_version_id;

	return v_version_id;
     
end;$_$;


--
-- Name: apm_package_version__enable(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__enable(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  enable__version_id             alias for $1;  
begin
      update apm_package_versions set enabled_p = 't'
      where version_id = enable__version_id;	

      return 0; 
end;$_$;


--
-- Name: apm_package_version__new(integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__new(integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
      apm_pkg_ver__version_id           alias for $1;  -- default null
      apm_pkg_ver__package_key		alias for $2;
      apm_pkg_ver__version_name		alias for $3;  -- default null
      apm_pkg_ver__version_uri		alias for $4;
      apm_pkg_ver__summary              alias for $5;
      apm_pkg_ver__description_format	alias for $6;
      apm_pkg_ver__description		alias for $7;
      apm_pkg_ver__release_date		alias for $8;
      apm_pkg_ver__vendor               alias for $9;
      apm_pkg_ver__vendor_uri		alias for $10;
      apm_pkg_ver__installed_p		alias for $11; -- default 'f'		
      apm_pkg_ver__data_model_loaded_p	alias for $12; -- default 'f'
      v_version_id                      apm_package_versions.version_id%TYPE;
begin
      if apm_pkg_ver__version_id = '' or apm_pkg_ver__version_id is null then
         select acs_object_id_seq.nextval
	 into v_version_id
	 from dual;
      else
         v_version_id := apm_pkg_ver__version_id;
      end if;

      v_version_id := acs_object__new(
		v_version_id,
		'apm_package_version',
                now(),
                null,
                null,
                null
        );

      insert into apm_package_versions
      (version_id, package_key, version_name, version_uri, summary, description_format, description,
      release_date, vendor, vendor_uri, installed_p, data_model_loaded_p)
      values
      (v_version_id, apm_pkg_ver__package_key, apm_pkg_ver__version_name, 
       apm_pkg_ver__version_uri, apm_pkg_ver__summary, 
       apm_pkg_ver__description_format, apm_pkg_ver__description,
       apm_pkg_ver__release_date, apm_pkg_ver__vendor, apm_pkg_ver__vendor_uri,
       apm_pkg_ver__installed_p, apm_pkg_ver__data_model_loaded_p);

      return v_version_id;		
  
end;$_$;


--
-- Name: apm_package_version__new(integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__new(integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, character varying, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
      apm_pkg_ver__version_id           alias for $1;  -- default null
      apm_pkg_ver__package_key		alias for $2;
      apm_pkg_ver__version_name		alias for $3;  -- default null
      apm_pkg_ver__version_uri		alias for $4;
      apm_pkg_ver__summary              alias for $5;
      apm_pkg_ver__description_format	alias for $6;
      apm_pkg_ver__description		alias for $7;
      apm_pkg_ver__release_date		alias for $8;
      apm_pkg_ver__vendor               alias for $9;
      apm_pkg_ver__vendor_uri		alias for $10;
      apm_pkg_ver__auto_mount           alias for $11;
      apm_pkg_ver__installed_p		alias for $12; -- default 'f'		
      apm_pkg_ver__data_model_loaded_p	alias for $13; -- default 'f'
      v_version_id                      apm_package_versions.version_id%TYPE;
begin
      if apm_pkg_ver__version_id is null then
         select nextval('t_acs_object_id_seq')
	 into v_version_id
	 from dual;
      else
         v_version_id := apm_pkg_ver__version_id;
      end if;

      v_version_id := acs_object__new(
		v_version_id,
		'apm_package_version',
                now(),
                null,
                null,
                null,
                't',
                apm_pkg_ver__package_key || ', Version ' || apm_pkg_ver__version_name,
                null
        );

      insert into apm_package_versions
      (version_id, package_key, version_name, version_uri, summary, description_format, description,
      release_date, vendor, vendor_uri, auto_mount, installed_p, data_model_loaded_p)
      values
      (v_version_id, apm_pkg_ver__package_key, apm_pkg_ver__version_name, 
       apm_pkg_ver__version_uri, apm_pkg_ver__summary, 
       apm_pkg_ver__description_format, apm_pkg_ver__description,
       apm_pkg_ver__release_date, apm_pkg_ver__vendor, apm_pkg_ver__vendor_uri, apm_pkg_ver__auto_mount,
       apm_pkg_ver__installed_p, apm_pkg_ver__data_model_loaded_p);

      return v_version_id;		
  
end;$_$;


--
-- Name: apm_package_version__remove_dependency(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__remove_dependency(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  remove_dependency__dependency_id          alias for $1;  
begin
    delete from apm_package_dependencies 
    where dependency_id = remove_dependency__dependency_id;

    return 0; 
end;$_$;


--
-- Name: apm_package_version__remove_dependency(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__remove_dependency(character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  remove_dependency__dependency_uri         alias for $1;  
  remove_dependency__dependency_version     alias for $2;  
  remove_dependency__version_id             alias for $3;  
  v_dep_id                           apm_package_dependencies.dependency_id%TYPE;
begin
      select dependency_id into v_dep_id from apm_package_dependencies 
      where service_uri = remove_dependency__dependency_uri 
      and service_version = remove_dependency__dependency_version;
      PERFORM apm_package_version__remove_dependency(v_dep_id);

      return 0; 
end;$_$;


--
-- Name: apm_package_version__remove_interface(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__remove_interface(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  remove_interface__interface_id           alias for $1;  
begin
    delete from apm_package_dependencies 
    where dependency_id = remove_interface__interface_id;

    return 0; 
end;$_$;


--
-- Name: apm_package_version__remove_interface(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__remove_interface(character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  remove_interface__interface_uri          alias for $1;  
  remove_interface__interface_version      alias for $2;  
  remove_interface__version_id             alias for $3;  
  v_dep_id                           apm_package_dependencies.dependency_id%TYPE;
begin
      select dependency_id into v_dep_id from apm_package_dependencies
      where service_uri = remove_interface__interface_uri 
      and interface_version = remove_interface__interface_version;
      PERFORM apm_package_version__remove_interface(v_dep_id);

      return 0; 
end;$_$;


--
-- Name: apm_package_version__sortable_version_name(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__sortable_version_name(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  version_name           alias for $1;  
  a_start                integer;       
  a_end                  integer;       
  a_order                varchar(1000) default ''; 
  a_char                 char(1);       
  a_seen_letter          boolean default 'f';        
begin
	a_start := 1;
	loop
	    a_end := a_start;
    
	    -- keep incrementing a_end until we run into a non-number        
	    while substr(version_name, a_end, 1) >= '0' and substr(version_name, a_end, 1) <= '9' loop
		a_end := a_end + 1;
	    end loop;
	    if a_end = a_start then
	    	return -1;
		-- raise_application_error(-20000, 'Expected number at position ' || a_start);
	    end if;
	    if a_end - a_start > 4 then
	    	return -1;
		-- raise_application_error(-20000, 'Numbers within versions can only be up to 4 digits long');
	    end if;
    
	    -- zero-pad and append the number
	    a_order := a_order || substr('0000', 1, 4 - (a_end - a_start)) ||
		substr(version_name, a_start, a_end - a_start) || '.';
	    if a_end > length(version_name) then
		-- end of string - we're outta here
		if a_seen_letter = 'f' then
		    -- append the "final" suffix if there haven't been any letters
		    -- so far (i.e., not development/alpha/beta)
		    a_order := a_order || '  3F.';
		end if;
		return a_order;
	    end if;
    
	    -- what's the next character? if a period, just skip it
	    a_char := substr(version_name, a_end, 1);
	    if a_char = '.' then
	    else
		-- if the next character was a letter, append the appropriate characters
		if a_char = 'd' then
		    a_order := a_order || '  0D.';
		else if a_char = 'a' then
		    a_order := a_order || '  1A.';
		else if a_char = 'b' then
		    a_order := a_order || '  2B.';
		end if; end if; end if;
    
		-- can't have something like 3.3a1b2 - just one letter allowed!
		if a_seen_letter = 't' then
		    return -1;
		    -- raise_application_error(-20000, 'Not allowed to have two letters in version name '''
		    --	|| version_name || '''');
		end if;
		a_seen_letter := 't';
    
		-- end of string - we're done!
		if a_end = length(version_name) then
		    return a_order;
		end if;
	    end if;
	    a_start := a_end + 1;
	end loop;
    
end;$_$;


--
-- Name: apm_package_version__upgrade(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__upgrade(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  upgrade__version_id             alias for $1;  
begin
    update apm_package_versions
    	set enabled_p = 'f',
	    installed_p = 'f'
	where package_key = (select package_key from apm_package_versions
	    	    	     where version_id = upgrade__version_id);
    update apm_package_versions
    	set enabled_p = 't',
	    installed_p = 't'
	where version_id = upgrade__version_id;			  
    
    return 0; 
end;$_$;


--
-- Name: apm_package_version__upgrade_p(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__upgrade_p(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  upgrade_p__path                   alias for $1;  
  upgrade_p__initial_version_name   alias for $2;  
  upgrade_p__final_version_name     alias for $3;  
  v_pos1                            integer;       
  v_pos2                            integer;       
  v_tmp                             varchar(1500);
  v_path                            varchar(1500);
  v_version_from                    apm_package_versions.version_name%TYPE;
  v_version_to                      apm_package_versions.version_name%TYPE;
begin

	-- Set v_path to the tail of the path (the file name).        
	v_path := substr(upgrade_p__path, instr(upgrade_p__path, '/', -1) + 1);

	-- Remove the extension, if it is .sql.
	v_pos1 := position('.sql' in v_path);
	if v_pos1 > 0 then
	    v_path := substr(v_path, 1, v_pos1 - 1);
	end if;

	-- Figure out the from/to version numbers for the individual file.
	v_pos1 := instr(v_path, '-', -1, 2);
	v_pos2 := instr(v_path, '-', -1);
	if v_pos1 = 0 or v_pos2 = 0 then
	    -- There aren't two hyphens in the file name. Bail.
	    return 0;
	end if;

	v_version_from := substr(v_path, v_pos1 + 1, v_pos2 - v_pos1 - 1);
	v_version_to := substr(v_path, v_pos2 + 1);

	if apm_package_version__version_name_greater(upgrade_p__initial_version_name, v_version_from) <= 0 and
	   apm_package_version__version_name_greater(upgrade_p__final_version_name, v_version_to) >= 0 then
	    return 1;
	end if;

	return 0;
        -- exception when others then
	-- Invalid version number.
	-- return 0;
   
end;$_$;


--
-- Name: apm_package_version__version_name_greater(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_package_version__version_name_greater(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  version_name_one       alias for $1;  
  version_name_two       alias for $2;
  a_order_a		 varchar(250);
  a_order_b		 varchar(250);  
begin
	a_order_a := apm_package_version__sortable_version_name(version_name_one);
	a_order_b := apm_package_version__sortable_version_name(version_name_two);
	if a_order_a < a_order_b then
	    return -1;
	else if a_order_a > a_order_b then
	    return 1;
	end if; end if;

	return 0;   
end;$_$;


--
-- Name: apm_parameter_value__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_parameter_value__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__value_id               alias for $1;  -- default null
begin
    delete from apm_parameter_values 
    where value_id = delete__value_id;
    PERFORM acs_object__delete(delete__value_id);

    return 0; 
end;$_$;


--
-- Name: apm_parameter_value__new(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_parameter_value__new(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__value_id               alias for $1;  -- default null  
  new__package_id             alias for $2;  
  new__parameter_id           alias for $3;  
  new__attr_value             alias for $4;  
  v_value_id                  apm_parameter_values.value_id%TYPE;
begin
   v_value_id := acs_object__new(
     new__value_id,
     'apm_parameter_value',
     now(),
     null,
     null,
     null
   );
   insert into apm_parameter_values 
    (value_id, package_id, parameter_id, attr_value)
     values
    (v_value_id, new__package_id, new__parameter_id, new__attr_value);

   return v_value_id;
    
end;$_$;


--
-- Name: apm_service__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_service__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__service_id    alias for $1;  
begin
    delete from apm_services
    where service_id = delete__service_id;
    PERFORM apm_package__delete(
	delete__service_id
    );

    return 0; 
end;$_$;


--
-- Name: apm_service__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION apm_service__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  service_id             alias for $1;  -- default null  
  instance_name          alias for $2;  -- default null
  package_key            alias for $3;  
  object_type            alias for $4;  -- default 'apm_service'
  creation_date          alias for $5;  -- default now()
  creation_user          alias for $6;  -- default null
  creation_ip            alias for $7;  -- default null
  context_id             alias for $8;  -- default null
  v_service_id           integer;       
begin
    v_service_id := apm_package__new (
      service_id,
      instance_name,
      package_key,
      object_type,
      creation_date,
      creation_user,
      creation_ip,
      context_id
    );

    return v_service_id;
   
end;$_$;


--
-- Name: application_group__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION application_group__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  group_id		alias for $1;
begin
    PERFORM acs_group__delete(group_id);

    return 0;
end;$_$;


--
-- Name: application_group__group_id_from_package_id(integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION application_group__group_id_from_package_id(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  group_id_from_package_id__package_id    alias for $1;
  group_id_from_package_id__no_complain_p alias for $2; -- default 'f'
  v_group_id				  application_groups.group_id%TYPE;
  v_object_name				  varchar;
begin

  select group_id 
    into v_group_id
    from application_groups 
    where package_id = group_id_from_package_id__package_id;

-- TODO: does this shortcut the exception in Oracle?
--    return v_group_id;

  if not found then
    if group_id_from_package_id__no_complain_p != 't' then
      v_object_name := acs_object__name(group_id_from_package_id__package_id);
      raise EXCEPTION '-20000: No group_id found for package % (%)', group_id_from_package_id__package_id, v_object_name;
    end if;
    return null;
  else
    return v_group_id;
  end if;

end;$_$;


--
-- Name: application_group__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION application_group__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__group_id              alias for $1;
  new__object_type           alias for $2; -- default 'application_group',
  new__creation_date         alias for $3; -- default sysdate,
  new__creation_user         alias for $4; -- default null,
  new__creation_ip           alias for $5; -- default null,
  new__email                 alias for $6; -- default null,
  new__url                   alias for $7; -- default null,
  new__group_name            alias for $8;
  new__package_id            alias for $9;
  new__context_id	     alias for $10; -- default null
  v_group_id		     application_groups.group_id%TYPE;
begin
  v_group_id := acs_group__new (
    new__group_id,
    new__object_type,
    new__creation_date,
    new__creation_user,
    new__creation_ip,
    new__email,
    new__url,
    new__group_name,
    null,
    new__context_id
  );

  insert into application_groups (group_id, package_id) 
    values (v_group_id, new__package_id);

  return v_group_id;

end;$_$;


--
-- Name: authority__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION authority__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_authority_id            alias for $1;
begin
  perform acs_object__delete(p_authority_id);

  return 0; 
end;$_$;


--
-- Name: authority__new(integer, character varying, character varying, character varying, boolean, integer, integer, integer, character varying, character varying, integer, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION authority__new(integer, character varying, character varying, character varying, boolean, integer, integer, integer, character varying, character varying, integer, character varying, character varying, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_authority_id alias for $1; -- default null,
    p_object_type alias for $2; -- default 'authority'
    p_short_name alias for $3;
    p_pretty_name alias for $4;
    p_enabled_p alias for $5; -- default 't'
    p_sort_order alias for $6;
    p_auth_impl_id alias for $7; -- default null
    p_pwd_impl_id alias for $8; -- default null
    p_forgotten_pwd_url alias for $9; -- default null
    p_change_pwd_url alias for $10; -- default null
    p_register_impl_id alias for $11; -- default null
    p_register_url alias for $12; -- default null
    p_help_contact_text alias for $13; -- default null,
    p_creation_user alias for $14; -- default null
    p_creation_ip alias for $15; -- default null
    p_context_id alias for $16; -- default null
  
    v_authority_id           integer;
    v_object_type            varchar;    
    v_sort_order             integer;
  
begin
    if p_object_type is null then
        v_object_type := 'authority';
    else
        v_object_type := p_object_type;
    end if;

    if p_sort_order is null then
          select into v_sort_order max(sort_order) + 1
                         from auth_authorities;
    else
        v_sort_order := p_sort_order;
    end if;

    -- Instantiate the ACS Object super type with auditing info
    v_authority_id  := acs_object__new(
        p_authority_id,
        v_object_type,
        now(),
        p_creation_user,
        p_creation_ip,
        p_context_id,
        't',
        p_short_name,
        null
    );

    insert into auth_authorities (authority_id, short_name, pretty_name, enabled_p, 
                                  sort_order, auth_impl_id, pwd_impl_id, 
                                  forgotten_pwd_url, change_pwd_url, register_impl_id,
                                  help_contact_text)
    values (v_authority_id, p_short_name, p_pretty_name, p_enabled_p, 
                                  v_sort_order, p_auth_impl_id, p_pwd_impl_id, 
                                  p_forgotten_pwd_url, p_change_pwd_url, p_register_impl_id,
                                  p_help_contact_text);

   return v_authority_id;
end;
$_$;


--
-- Name: bitfromint4(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION bitfromint4(integer) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
begin
    return $1::bit(32);
end;$_$;


--
-- Name: bittoint4(bit varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION bittoint4(bit varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	begin 
    	    return "int4"($1);
	end;$_$;


--
-- Name: cal_item__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cal_item__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    delete__cal_item_id		alias for $1;
begin
	-- Erase the cal_item associated with the id
    delete from 	cal_items
    where		cal_item_id = delete__cal_item_id;
 	
	-- Erase all the priviledges
    delete from 	acs_permissions
    where		object_id = delete__cal_item_id;

    PERFORM acs_event__delete(delete__cal_item_id);

    return 0;

end;$_$;


--
-- Name: cal_item__delete_all(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cal_item__delete_all(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    delete__recurrence_id		alias for $1;
    v_event                             RECORD;
begin
    for v_event in 
	select event_id from acs_events
        where recurrence_id= delete__recurrence_id
    LOOP
        PERFORM cal_item__delete(v_event.event_id);
    END LOOP;

    PERFORM recurrence__delete(delete__recurrence_id);

    return 0;

end;$_$;


--
-- Name: cal_item__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cal_item__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare 
    name__cal_item_id	alias for $1;
    v_name	acs_activities.name%TYPE;
begin
    select  name 
    into    v_name
    from    acs_activities
    where   activity_id = 
    (
	select  activity_id
        from    acs_events
        where   event_id = name__cal_item_id
    );
               
    return v_name;

end;$_$;


--
-- Name: cal_item__new(integer, integer, character varying, character varying, boolean, character varying, integer, integer, integer, character varying, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cal_item__new(integer, integer, character varying, character varying, boolean, character varying, integer, integer, integer, character varying, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    new__cal_item_id		alias for $1;	-- default null
    new__on_which_calendar	alias for $2;	-- default null
    new__name			alias for $3;	
    new__description		alias for $4;	
    new__html_p		        alias for $5;	-- default null
    new__status_summary		alias for $6;	-- default null
    new__timespan_id		alias for $7;	-- default null
    new__activity_id		alias for $8;	-- default null
    new__recurrence_id		alias for $9;	-- default null
    new__object_type		alias for $10;	-- default "cal_item"
    new__context_id		alias for $11;	-- default null
    new__creation_date		alias for $12;	-- default now()
    new__creation_user		alias for $13;	-- default null
    new__creation_ip		alias for $14;	-- default null
    v_cal_item_id		cal_items.cal_item_id%TYPE;

begin
    v_cal_item_id := acs_event__new(
	new__cal_item_id,	-- event_id
	new__name,		-- name
	new__description,	-- description
        new__html_p,		-- html_p
        new__status_summary,    -- status_summary
	new__timespan_id,	-- timespan_id
	new__activity_id,	-- activity_id
	new__recurrence_id,	-- recurrence_id
	new__object_type,	-- object_type
	new__creation_date,	-- creation_date
	new__creation_user,	-- creation_user
	new__creation_ip,	-- creation_ip
	new__context_id		-- context_id
	);

    insert into cal_items
	(cal_item_id, on_which_calendar)
    values          
	(v_cal_item_id, new__on_which_calendar);

    return v_cal_item_id;

end;$_$;


--
-- Name: cal_item__on_which_calendar(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cal_item__on_which_calendar(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    on_which_calendar__cal_item_id	alias for $1;
    v_calendar_id			calendars.calendar_id%TYPE;
begin
    select  on_which_calendar
    into    v_calendar_id
    from    cal_items
    where   cal_item_id = on_which_calendar__cal_item_id;
        
    return  v_calendar_id;

end;$_$;


--
-- Name: calendar__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$declare
	delete__calendar_id		alias for $1;
    begin
	delete from calendars
	where calendar_id = delete__calendar_id;

	-- Delete all privileges associate with this calendar
	
	delete from     acs_permissions 
        where           object_id = delete__calendar_id;

       delete from     acs_permissions
        where           object_id in (
				select  cal_item_id
                                from    cal_items
                                where   on_which_calendar = delete__calendar_id
			);
                         
	PERFORM acs_object__delete(delete__calendar_id);

    return 0;
    end;$_$;


--
-- Name: calendar__first_displayed_date(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__first_displayed_date(timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$declare
	first_displayed_date__current_date	alias for $1;
	v_date			timestamptz;
begin
        select next_day(date_trunc('Month', current_date) - 7 , 'SUNDAY')
	into		v_date
        from		dual;

        return  v_date;
end;$_$;


--
-- Name: calendar__last_displayed_date(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__last_displayed_date(timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$declare
	last_displayed_date__current_date	alias for $1;
	v_date			timestamptz;
begin
	select next_day(last_day(current_date), 'SATURDAY')
        into		v_date
        from		dual;

        return v_date;
end;$_$;


--
-- Name: calendar__month_name(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__month_name(timestamp with time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$declare
	month_name__current_date		alias for $1;
	v_name			varchar;
    begin
	select	to_char(month_name__current_date, 'fmMonth')
	into		v_name
	from		dual;

	return v_name;

    end;$_$;


--
-- Name: calendar__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$declare
	name__calendar_id		alias for $1;
	v_calendar_name			calendars.calendar_name%TYPE;

    begin
	select	calendar_name
	into	v_calendar_name
	from	calendars
	where	calendar_id = name__calendar_id;

    return  v_calendar_name;
end;$_$;


--
-- Name: calendar__new(integer, character varying, character varying, integer, boolean, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__new(integer, character varying, character varying, integer, boolean, integer, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$declare
	v_calendar_id           calendars.calendar_id%TYPE;
	new__calendar_id	alias for $1;
	new__calendar_name	alias for $2;
	new__object_type	alias for $3;
	new__owner_id		alias for $4;
	new__private_p		alias for $5;
	new__package_id		alias for $6;
	new__context_id		alias for $7;
	new__creation_date	alias for $8;
	new__creation_user	alias for $9;
	new__creation_ip	alias for $10;

    begin
        v_calendar_id := acs_object__new(
		new__calendar_id,
		new__object_type,
		new__creation_date,
		new__creation_user,
		new__creation_ip,
		new__context_id
	);
	
	insert into     calendars
                        (calendar_id, calendar_name, owner_id, package_id, private_p)
	values          (v_calendar_id, new__calendar_name, new__owner_id, new__package_id, new__private_p);
      
	PERFORM acs_permission__grant_permission (
              v_calendar_id,
              new__owner_id,
              'calendar_admin'
        );


	return v_calendar_id;
    end;$_$;


--
-- Name: calendar__next_month(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__next_month(timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$declare
	next_month__current_dates		alias for $1;
	v_date			timestamptz;
    begin
	--select	trunc(add_months(to_date(db_sysdate), -1))
        select date_trunc('day', current_timestamp + cast('1 month' as interval))
        into		v_date
        from		dual;

        return v_date;          
end;$_$;


--
-- Name: calendar__num_day_in_month(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__num_day_in_month(timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$declare
	num_day_in_month__current_date		alias for $1;
	v_num			integer;
begin
	select to_char(last_day(current_date), 'DD')
        into		v_num
        from		dual;

        return v_num;
end;$_$;


--
-- Name: calendar__prev_month(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__prev_month(timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$declare
	prev_month__current_date		alias for $1;
	v_date			date;
begin
--        select	trunc(add_months(to_date(db_sysdate), -1))
          select date_trunc('day', current_timestamp - cast('1 month' as interval))
        into		v_date
        from		dual;

        return v_date;
end;$_$;


--
-- Name: calendar__private_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__private_p(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$declare
        v_private_p             boolean;
	private_p__calendar_id	alias for $1;
    begin
	select	private_p
	into	v_private_p
	from	calendars
	where calendar_id = private_p__calendar_id;

	return v_private_p;
end;$_$;


--
-- Name: calendar__readable_p(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__readable_p(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$declare
	readable_p__calendar_id		alias for $1;
	readable_p__party_id		alias for $1;
	v_readable_p			boolean;

    begin
	select (case count(*)
		when 1 then true
			else false
		) into v_readable_p
	from    acs_object_party_privilege_map 
                where   party_id = readable_p__party_id
                and     object_id = readable_p__calendar_id 
                and     privilege = 'calendar_read';
	
	return v_readable_p;
end;$_$;


--
-- Name: calendar__show_p(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION calendar__show_p(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$declare
	show_p__calendar_id	 alias for $1;
	show_p__party_id	 alias for $2;
	v_show_p		 boolean := 't';
    begin
	select	(case count(*)
		when 1 then true
		else false
		end)
	into	v_show_p
	from	acs_permissions
	where	grantee_id = show_p__party_id
	and	object_id = show_p__calendar_id
	and	privilege = 'calendar_show';

	return v_show_p;
	
end;$_$;


--
-- Name: category__change_parent(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category__change_parent(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id       alias for $1;
    p_tree_id           alias for $2;
    p_parent_id         alias for $3;

    v_old_left_ind      integer;
    v_old_right_ind     integer;
    v_new_left_ind      integer;
    v_new_right_ind     integer;
    v_width             integer;
begin
 	update categories
	set parent_id = p_parent_id
	where category_id = p_category_id;

	-- first save the subtree, then compact tree, then expand tree to make room
	-- for subtree, then insert it

	select left_ind, right_ind into v_old_left_ind, v_old_right_ind
	from categories
	where category_id = p_category_id;

	v_width := v_old_right_ind - v_old_left_ind + 1;

	-- cut out old subtree
	update categories
	set left_ind = -left_ind, right_ind = -right_ind
	where tree_id = p_tree_id
	and left_ind >= v_old_left_ind
	and right_ind <= v_old_right_ind;

	-- compact parent trees
	update categories
	set right_ind = right_ind - v_width
	where tree_id = p_tree_id
	and left_ind < v_old_left_ind
	and right_ind > v_old_right_ind;

	-- compact right tree portion
	update categories
	set left_ind = left_ind - v_width,
	right_ind = right_ind - v_width
	where tree_id = p_tree_id
	and left_ind > v_old_left_ind;

	if (p_parent_id is null) then
	   select 1, max(right_ind)+1 into v_new_left_ind, v_new_right_ind
	   from categories
	   where tree_id = p_tree_id;
	else
	   select left_ind, right_ind into v_new_left_ind, v_new_right_ind
	   from categories
	   where category_id = p_parent_id;
	end if;

	-- move parent trees to make room
	update categories
	set right_ind = right_ind + v_width
	where tree_id = p_tree_id
	and left_ind <= v_new_left_ind
	and right_ind >= v_new_right_ind;

	-- move right tree portion to make room
	update categories
	set left_ind = left_ind + v_width,
	right_ind = right_ind + v_width
	where tree_id = p_tree_id
	and left_ind > v_new_right_ind;

	-- insert subtree at correct place
	update categories
	set left_ind = -left_ind + (v_new_right_ind - v_old_left_ind),
	right_ind = -right_ind + (v_new_right_ind - v_old_left_ind)
	where tree_id = p_tree_id
	and left_ind < 0;

	-- for debugging reasons
        perform category_tree__check_nested_ind(p_tree_id);

        return 0;
end;
$_$;


--
-- Name: category__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_category_id   alias for $1;

        v_tree_id       integer;
	v_left_ind      integer;
	v_right_ind     integer;
        node            record;
begin
        select tree_id, left_ind, right_ind
	into v_tree_id, v_left_ind, v_right_ind
	from categories where category_id = p_category_id;

	for node in 
           select category_id
	     from categories
	    where tree_id = v_tree_id
	      and left_ind >= v_left_ind
	      and right_ind <= v_right_ind 
        loop
	   delete from category_object_map where category_id = node.category_id;
	   delete from category_translations where category_id = node.category_id;
	   delete from categories where category_id = node.category_id;
	   perform acs_object__delete(node.category_id);
	end loop;

	update categories
	set right_ind = (right_ind - (1 + v_right_ind - v_left_ind))
	where left_ind <= v_left_ind
	and right_ind > v_left_ind
	and tree_id = v_tree_id;

	update categories
	set right_ind = (right_ind - (1 + v_right_ind - v_left_ind)),
	    left_ind = (left_ind - (1 + v_right_ind - v_left_ind))
	where left_ind > v_left_ind
	and tree_id = v_tree_id;
	
        -- for debugging reasons
        perform category_tree__check_nested_ind(v_tree_id);
        return 0;
end;
$_$;


--
-- Name: category__edit(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category__edit(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id       alias for $1;
    p_locale            alias for $2;
    p_name              alias for $3;
    p_description       alias for $4;
    p_modifying_date    alias for $5;
    p_modifying_user    alias for $6;
    p_modifying_ip      alias for $7;
begin
	-- change category name
    update category_translations
    set name = p_name,
       description = p_description
    where category_id = p_category_id
          and locale = p_locale;

    update acs_objects
    set last_modified = p_modifying_date,
	    modifying_user = p_modifying_user,
	    modifying_ip = p_modifying_ip
    where object_id = p_category_id;

    return 0;
end;
$_$;


--
-- Name: category__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category__name(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
    v_name      varchar;
begin
	select name into v_name
	from category_translations
	where category_id = p_category_id
	and locale = 'en_US';

        return 0;
end;
$$;


--
-- Name: category__new(integer, integer, character varying, character varying, character varying, integer, character, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category__new(integer, integer, character varying, character varying, character varying, integer, character, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id       alias for $1;
    p_tree_id           alias for $2;
    p_locale            alias for $3;
    p_name              alias for $4;
    p_description       alias for $5;
    p_parent_id         alias for $6;
    p_deprecated_p      alias for $7;
    p_creation_date     alias for $8;
    p_creation_user     alias for $9;
    p_creation_ip       alias for $10;

    v_category_id       integer; 
    v_left_ind          integer;
    v_right_ind         integer;
begin
	v_category_id := acs_object__new ( 
		p_category_id,          -- object_id
		'category',           -- object_type
		p_creation_date,        -- creation_date
		p_creation_user,        -- creation_user
		p_creation_ip,          -- creation_ip
		p_tree_id,              -- context_id
                't',                  -- security_inherit_p
                p_name,                 -- title
                null                    -- package_id
	);

	if (p_parent_id is null) then
		select 1, coalesce(max(right_ind)+1,1) into v_left_ind, v_right_ind
		from categories
		where tree_id = p_tree_id;
	else
		select left_ind, right_ind into v_left_ind, v_right_ind
		from categories
		where category_id = p_parent_id;
	end if;

 	insert into categories
        (category_id, tree_id, deprecated_p, parent_id, left_ind, right_ind)
	values
	(v_category_id, p_tree_id, p_deprecated_p, p_parent_id, -1, -2);

	-- move right subtrees to make room for new category
	update categories
	set left_ind = left_ind + 2,
	    right_ind = right_ind + 2
	where tree_id = p_tree_id
	and left_ind > v_right_ind;

	-- expand upper nodes to make room for new category
	update categories
	set right_ind = right_ind + 2
	where tree_id = p_tree_id
	and left_ind <= v_left_ind
	and right_ind >= v_right_ind;

	-- insert new category
	update categories
	set left_ind = v_right_ind,
	    right_ind = v_right_ind + 1
	where category_id = v_category_id;

	insert into category_translations
	    (category_id, locale, name, description)
	values
	    (v_category_id, p_locale, p_name, p_description);

	return v_category_id;
end;
$_$;


--
-- Name: category__new_translation(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category__new_translation(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id       alias for $1;
    p_locale            alias for $2;
    p_name              alias for $3;
    p_description       alias for $4;
    p_modifying_date    alias for $5;
    p_modifying_user    alias for $6;
    p_modifying_ip      alias for $7;
begin
        insert into category_translations
	    (category_id, locale, name, description)
	values
	    (p_category_id, p_locale, p_name, p_description);

	update acs_objects
        set last_modified = p_modifying_date,
	    modifying_user = p_modifying_user,
	    modifying_ip = p_modifying_ip
	where object_id = p_category_id;
        
        return 0;
end;
$_$;


--
-- Name: category__phase_in(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category__phase_in(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id       alias for $1;
begin
       update categories
       set deprecated_p = 'f'
       where category_id = p_category_id;

       return 0;
end;
$_$;


--
-- Name: category__phase_out(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category__phase_out(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id       alias for $1;
begin
       update categories
       set deprecated_p = 't'
       where category_id = p_category_id;

       return 0;
end;
$_$;


--
-- Name: category_link__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_link__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
	-- function for deleting category links
declare
	p_link_id	alias for $1;
begin
	delete from category_links
	where link_id = p_link_id;

	return p_link_id;
end;$_$;


--
-- Name: category_link__new(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_link__new(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
	-- function for adding category links
declare
	p_from_category_id	alias for $1;
	p_to_category_id	alias for $2;
	v_link_id		integer;
begin
	v_link_id := nextval ('category_links_id_seq');

	insert into category_links (link_id, from_category_id, to_category_id)
	values (v_link_id, p_from_category_id, p_to_category_id);

	return v_link_id;
end;$_$;


--
-- Name: category_synonym__convert_string(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_synonym__convert_string(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
-- return string to build search index
declare
        p_name		alias for $1;
        v_index_string	varchar(200);
begin
	-- convert string to uppercase and substitute special chars
        -- TODO: complete
        v_index_string := upper (
                        replace (
                        replace (
                        replace (
                        replace (
                        replace (
                        replace (
			replace (p_name, 'ä', 'AE'), 
					 'Ä', 'AE'),
					 'ö', 'OE'),
					 'Ö', 'OE'),
					 'ü', 'UE'),
					 'Ü', 'UE'),
					 'ß', 'SS'));
					  
	return (' ' || v_index_string || ' ');
end;$_$;


--
-- Name: category_synonym__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_synonym__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- delete synonym
declare
	p_synonym_id	alias for $1;
begin
	-- delete search results
	delete	from category_search_results
	where	synonym_id = p_synonym_id;

	-- delete synonym index
	delete	from category_synonym_index
	where	synonym_id = p_synonym_id;

	-- delete synonym
	delete	from category_synonyms
	where	synonym_id = p_synonym_id;

	return (1);
end;$_$;


--
-- Name: category_synonym__edit(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_synonym__edit(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_synonym_id	alias for $1;
	p_new_name	alias for $2;
	p_locale	alias for $3;
begin
	-- update synonym data
	update	category_synonyms
	set	name = p_new_name,
		locale = p_locale
	where	synonym_id = p_synonym_id;

	-- update synonym index and search results
	PERFORM category_synonym__reindex (p_synonym_id, p_new_name, p_locale);

	return (p_synonym_id);
end;$_$;


--
-- Name: category_synonym__edit_cat_trans_trg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_synonym__edit_cat_trans_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- trigger function for updating a category translation
declare
    v_synonym_id    integer;
begin
	-- get synonym_id of updated category translation
    select synonym_id into v_synonym_id
    from   category_synonyms
    where  category_id = OLD.category_id
           and name = OLD.name
           and locale = OLD.locale
           and synonym_p = 'f';

	-- update synonym
    PERFORM category_synonym__edit (v_synonym_id, NEW.name, NEW.locale);

    return new;
end;$$;


--
-- Name: category_synonym__get_similarity(integer, integer, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_synonym__get_similarity(integer, integer, bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- calculates similarity of two strings
declare
	p_len1		alias for $1;
	p_len2		alias for $2;
	p_matches	alias for $3;
begin
	return (p_matches * 200 / (p_len1 + p_len2));
end;$_$;


--
-- Name: category_synonym__new(character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_synonym__new(character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_name		alias for $1;
	p_locale	alias for $2;
	p_category_id	alias for $3;
	p_synonym_id	alias for $4;
	v_synonym_id	integer;
begin
	-- get new synonym_id
	if (p_synonym_id is null) then
		v_synonym_id := nextval ('category_synonyms_id_seq');
	else 
		v_synonym_id := p_synonym_id;
	end if;

	-- insert synonym data
	insert into category_synonyms (synonym_id, category_id, locale, name, synonym_p)
	values (v_synonym_id, p_category_id, p_locale, p_name, 't');

	-- insert in synonym index and search results
	PERFORM category_synonym__reindex (v_synonym_id, p_name, p_locale);

	return (v_synonym_id);
end;$_$;


--
-- Name: category_synonym__new_cat_trans_trg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_synonym__new_cat_trans_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- trigger function for inserting category translation
declare
    v_synonym_id     integer;
begin
	-- create synonym
    v_synonym_id := category_synonym__new (NEW.name, NEW.locale, NEW.category_id, null);

	-- mark synonym as not editable for users
    update category_synonyms
    set synonym_p = 'f'
    where synonym_id = v_synonym_id;

    return new;
end;$$;


--
-- Name: category_synonym__reindex(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_synonym__reindex(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- build search index for synonym
declare
	p_synonym_id	alias for $1;
	p_name		alias for $2;
	p_locale	alias for $3;
	v_name		varchar(200);
	v_len		integer;
	v_i		integer;
begin
	-- delete old search results for this synonym
	delete	from category_search_results
	where	synonym_id = p_synonym_id;

	-- delete old synonym index for this synonym
	delete	from category_synonym_index
	where	synonym_id = p_synonym_id;

	-- convert string to uppercase and substitute special chars
	v_name := category_synonym__convert_string (p_name);

	-- rebuild synonym index
	v_len := length (v_name) - 2;
	v_i := 1;
	while (v_i <= v_len) loop
		insert into category_synonym_index
		values (p_synonym_id, substring (v_name, v_i , 3));
		v_i := v_i + 1;
	end loop;

	-- rebuild search results
	insert into category_search_results
	select	s.query_id, p_synonym_id, 
		category_synonym__get_similarity (v_len, length (s.search_text) - 2, count(*))
	from	category_search_index si, 
		category_synonym_index i,
		category_search s
	where	i.synonym_id = p_synonym_id
	and	si.trigram = i.trigram
	and	si.query_id = s.query_id
	and	s.locale = p_locale
	group by s.query_id, s.search_text;

	return (1);
end;$_$;


--
-- Name: category_synonym__search(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_synonym__search(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- return id for search string
declare
	p_search_text	alias for $1;
	p_locale	alias for $2;
	v_search_text	varchar(200);
	v_query_id	integer;
	v_len		integer;
	v_i		integer;
begin
	-- check if search text already exists
	select	query_id into v_query_id
	from	category_search
	where	search_text = p_search_text
	and 	locale = p_locale;

	-- simply update old search data if already exists
	if (v_query_id is not null) then
		update	category_search
		set	queried_count = queried_count + 1,
			last_queried = date('now')
		where	query_id = v_query_id;
		return (v_query_id);
	end if;

	-- get new search query id
	v_query_id := nextval ('category_search_id_seq');

	-- convert string to uppercase and substitute special chars
	v_search_text := category_synonym__convert_string (p_search_text);

	-- insert search data
	insert into category_search (query_id, search_text, locale, queried_count, last_queried)
	values (v_query_id, p_search_text, p_locale, 1, date('now'));

	-- build search index
	v_len := length (v_search_text) - 2;
	v_i := 1;
	while (v_i <= v_len) loop
		insert into category_search_index 
		values (v_query_id, substring (v_search_text, v_i , 3));
		v_i := v_i + 1;
	end loop;

	-- build search result
	insert into category_search_results
	select	v_query_id, s.synonym_id, 
		category_synonym__get_similarity (v_len, length (s.name) - 2, count(*))
	from	category_search_index si, 
		category_synonym_index i,
		category_synonyms s
	where	si.query_id = v_query_id
	and	si.trigram = i.trigram
	and	s.synonym_id = i.synonym_id
	and	s.locale = p_locale
	group by s.synonym_id, s.name;

	return (v_query_id);
end;$_$;


--
-- Name: category_tree__check_nested_ind(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_tree__check_nested_ind(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_tree_id                alias for $1;
    v_negative               numeric;
    v_order                  numeric;
    v_parent                 numeric;
begin
        select count(*) into v_negative from categories
	where tree_id = p_tree_id and (left_ind < 1 or right_ind < 1);

	if v_negative > 0 then 
           raise EXCEPTION '-20001: negative index not allowed!';
        end if;

        select count(*) into v_order from categories
	where tree_id = p_tree_id
	and left_ind >= right_ind;
	
	if v_order > 0 then 
           raise EXCEPTION '-20002: right index must be greater than left index!';
        end if;

        select count(*) into v_parent
	from categories parent, categories child
		where parent.tree_id = p_tree_id
		and child.tree_id = parent.tree_id
		and (parent.left_ind >= child.left_ind or parent.right_ind <= child.right_ind)
		and child.parent_id = parent.category_id;

	if v_parent > 0 then 
           raise EXCEPTION '-20003: child index must be between parent index!';
        end if;

        return 0;
end;
$_$;


--
-- Name: category_tree__copy(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_tree__copy(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_source_tree           alias for $1;
    p_dest_tree             alias for $2;
    p_creation_user         alias for $3;
    p_creation_ip           alias for $4;

    v_new_left_ind          integer;
    v_category_id	    integer;
    source record;
begin
	select coalesce(max(right_ind),0) into v_new_left_ind 
	from categories
	where tree_id = p_dest_tree;

	for source in (select category_id, parent_id, left_ind, right_ind from categories where tree_id = p_source_tree) loop

	   v_category_id := acs_object__new ( 
		'category',     -- object_type
		now(),            -- creation_date
		p_creation_user,  -- creation_user
		p_creation_ip,    -- creation_ip
	  	p_dest_tree       -- context_id
	   );

	   insert into categories
	   (category_id, tree_id, parent_id, left_ind, right_ind)
	   values
	   (v_category_id, p_dest_tree, source.parent_id, source.left_ind + v_new_left_ind, source.right_ind + v_new_left_ind);
	end loop;

	-- correct parent_ids
	update categories c
	set parent_id = (select t.category_id
			from categories s, categories t
			where s.category_id = c.parent_id
			and t.tree_id = copy.dest_tree
			and s.left_ind + v_new_left_ind = t.left_ind)
	where tree_id = p_dest_tree;

	-- copy all translations
	insert into category_translations
	(category_id, locale, name, description)
	(select ct.category_id, t.locale, t.name, t.description
	from category_translations t, categories cs, categories ct
	where ct.tree_id = p_dest_tree
	and cs.tree_id = p_source_tree
	and cs.left_ind + v_new_left_ind = ct.left_ind
	and t.category_id = cs.category_id);

	-- for debugging reasons
	perform category_tree__check_nested_ind(p_dest_tree);

       return 0;
end;
$_$;


--
-- Name: category_tree__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_tree__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_tree_id                alias for $1;
begin

       delete from category_tree_map where tree_id = p_tree_id;

       delete from category_object_map where category_id in (select category_id from categories where tree_id = p_tree_id);

       delete from category_translations where category_id in (select category_id from categories where tree_id = p_tree_id);
 
       delete from categories where tree_id = p_tree_id;
 
       delete from acs_objects where context_id = p_tree_id;

       delete from acs_permissions where object_id = p_tree_id;

       delete from category_tree_translations where tree_id  = p_tree_id;
       delete from category_trees where tree_id  = p_tree_id;
 
       perform acs_object__delete(p_tree_id);

       return 0;
end;
$_$;


--
-- Name: category_tree__edit(integer, character varying, character varying, character varying, character, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_tree__edit(integer, character varying, character varying, character varying, character, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_tree_id                alias for $1;
    p_locale                 alias for $2;
    p_tree_name              alias for $3;
    p_description            alias for $4;
    p_site_wide_p            alias for $5;
    p_modifying_date         alias for $6;
    p_modifying_user         alias for $7;
    p_modifying_ip           alias for $8;
begin
	update category_trees
	set site_wide_p = p_site_wide_p
	where tree_id = p_tree_id;

	update category_tree_translations
	set name = p_tree_name,
	    description = p_description
	where tree_id = p_tree_id
	and locale = p_locale;

	update acs_objects
	set last_modified = p_modifying_date,
	    modifying_user = p_modifying_user,
	    modifying_ip = p_modifying_ip
	where object_id = p_tree_id;

       return 0;
end;
$_$;


--
-- Name: category_tree__map(integer, integer, integer, character, character); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_tree__map(integer, integer, integer, character, character) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id              alias for $1;
    p_tree_id                alias for $2;
    p_subtree_category_id    alias for $3;
    p_assign_single_p        alias for $4;
    p_require_category_p     alias for $5;

    v_map_count              integer;
begin
	select count(*) 
	into v_map_count
	from category_tree_map
	where object_id = p_object_id
	and tree_id = p_tree_id;

	if v_map_count = 0 then
	   insert into category_tree_map
	   (tree_id, subtree_category_id, object_id,
	    assign_single_p, require_category_p)
	   values (p_tree_id, p_subtree_category_id, p_object_id,
	           p_assign_single_p, p_require_category_p);
	end if;
        return 0;
end;
$_$;


--
-- Name: category_tree__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_tree__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_tree_id                alias for $1;
    v_name                   varchar;
begin
	select name into v_name
	from category_tree_translations
	where tree_id = p_tree_id
	and locale = 'en_US';

	return v_name;
end;
$_$;


--
-- Name: category_tree__new(integer, character varying, character varying, character varying, character, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_tree__new(integer, character varying, character varying, character varying, character, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_tree_id               alias for $1;
    p_locale                alias for $2;
    p_tree_name             alias for $3;
    p_description           alias for $4;
    p_site_wide_p           alias for $5;
    p_creation_date         alias for $6;
    p_creation_user         alias for $7;
    p_creation_ip           alias for $8;
    p_context_id            alias for $9;
  
    v_tree_id               integer;
begin
	v_tree_id := acs_object__new (
		p_tree_id,         -- object_id
		'category_tree', -- object_type
		p_creation_date,   -- creation_date
		p_creation_user,   -- creation_user
		p_creation_ip,     -- creation_ip
		p_context_id,      -- context_id
                p_tree_name,       -- title
                null               -- package_id
	);

	insert into category_trees
	   (tree_id, site_wide_p)
	values
	   (v_tree_id, p_site_wide_p);

	perform acs_permission__grant_permission (
		v_tree_id,             -- object_id
		p_creation_user,       -- grantee_id
		'category_tree_read' -- privilege
	);
	perform acs_permission__grant_permission (
		v_tree_id,                -- object_id
		p_creation_user,          -- grantee_id
		'category_tree_write'   -- privilege
	);
	perform acs_permission__grant_permission (
		v_tree_id,                          -- object_id
		p_creation_user,                    -- grantee_id
		'category_tree_grant_permissions' -- privilege
	);

	insert into category_tree_translations
	    (tree_id, locale, name, description)
	values
	    (v_tree_id, p_locale, p_tree_name, p_description);

	return v_tree_id;
end;
$_$;


--
-- Name: category_tree__new_translation(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_tree__new_translation(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_tree_id                alias for $1;
    p_locale                 alias for $2;
    p_tree_name              alias for $3;
    p_description            alias for $4;
    p_modifying_date         alias for $5;
    p_modifying_user         alias for $6;
    p_modifying_ip           alias for $7;
begin
	insert into category_tree_translations
	    (tree_id, locale, name, description)
	values
	    (p_tree_id, p_locale, p_tree_name, p_description);

	update acs_objects
	set last_modified = p_modifying_date,
	    modifying_user = p_modifying_user,
	    modifying_ip = p_modifying_ip
	where object_id = p_tree_id;
        return 0;
end;
$_$;


--
-- Name: category_tree__unmap(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION category_tree__unmap(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id              alias for $1;
    p_tree_id                alias for $2;
begin
	delete from category_tree_map
	where object_id = p_object_id
	and tree_id = p_tree_id;
        return 0;
end;
$_$;


--
-- Name: column_exists(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION column_exists(character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
        column_exists__table_name             alias for $1;  
        column_exists__column_name            alias for $2;  
begin

        return count(*) > 0
          from pg_class c, pg_attribute a
         where c.relname = lower(column_exists__table_name)
           and c.oid = a.attrelid
           and a.attname = lower(column_exists__column_name);

end;$_$;


--
-- Name: composition_rel__check_index(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION composition_rel__check_index(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  check_index__component_id           alias for $1;  
  check_index__container_id           alias for $2;  
  result                              boolean;       
  n_rows                              integer;       
  dc                                  record;
  r1                                  record;
  r2                                  record;
begin
    result := 't';

    -- Loop through all the direct containers (DC) of COMPONENT_ID
    -- that are also contained by CONTAINER_ID and verify that the
    -- GROUP_COMPONENT_INDEX contains the (GROUP_ID, DC.REL_ID,
    -- CONTAINER_ID) triple.
    for dc in  select r.rel_id, r.object_id_one as container_id
               from acs_rels r, composition_rels c
               where r.rel_id = c.rel_id
               and r.object_id_two = check_index__component_id 
    LOOP

      if composition_rel__check_path_exists_p(dc.container_id,
                             check_index__container_id) = 't' then
        select case when count(*) = 0 then 0 else 1 end into n_rows
        from group_component_index
        where group_id = check_index__container_id
        and component_id = check_index__component_id
        and rel_id = dc.rel_id;

        if n_rows = 0 then
          result := 'f';
          PERFORM acs_log__error('composition_rel.check_representation',
                        'Row missing from group_component_index for (' ||
                        'group_id = ' || check_index__container_id || ', ' ||
                        'component_id = ' || check_index__component_id || ', ' ||
                        'rel_id = ' || dc.rel_id || ')');
        end if;

      end if;

    end loop;

    -- Loop through all the containers of CONTAINER_ID.
    for r1 in  select r.object_id_one as container_id
               from acs_rels r, composition_rels c
               where r.rel_id = c.rel_id
               and r.object_id_two = check_index__container_id
               union
               select check_index__container_id as container_id
               from dual 
    LOOP
      -- Loop through all the components of COMPONENT_ID and make a
      -- recursive call.
      for r2 in  select r.object_id_two as component_id
                 from acs_rels r, composition_rels c
                 where r.rel_id = c.rel_id
                 and r.object_id_one = check_index__component_id
                 union
                 select check_index__component_id as component_id
                 from dual 
      LOOP
        if (r1.container_id != check_index__container_id or
            r2.component_id != check_index__component_id) and
           composition_rel__check_index(r2.component_id, r1.container_id) = 'f' then
          result := 'f';
        end if;
      end loop;
    end loop;

    return result;
   
end;$_$;


--
-- Name: composition_rel__check_path_exists_p(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION composition_rel__check_path_exists_p(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  component_id           alias for $1;  
  container_id           alias for $2;  
  row                    record;
begin
    if component_id = container_id then
      return 't';
    end if;

    for row in  select r.object_id_one as parent_id
                from acs_rels r, composition_rels c
                where r.rel_id = c.rel_id
                and r.object_id_two = component_id 
    LOOP
      if composition_rel__check_path_exists_p(row.parent_id, container_id) = 't' then
        return 't';
      end if;
    end loop;

    return 'f';
   
end;$_$;


--
-- Name: composition_rel__check_representation(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION composition_rel__check_representation(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  check_representation__rel_id                 alias for $1;  
  container_id                                 groups.group_id%TYPE;
  component_id                                 groups.group_id%TYPE;
  result                                       boolean;     
  row                                          record;  
begin
    result := 't';

    if acs_object__check_representation(check_representation__rel_id) = 'f' then
      result := 'f';
    end if;

    select object_id_one, object_id_two
    into container_id, component_id
    from acs_rels
    where rel_id = check_representation__rel_id;

    -- First let's check that the index has all the rows it should.
    if composition_rel__check_index(component_id, container_id) = 'f' then
      result := 'f';
    end if;

    -- Now let's check that the index doesn't have any extraneous rows
    -- relating to this relation.
    for row in  select *
                from group_component_index
                where rel_id = check_representation__rel_id  
    LOOP
      if composition_rel__check_path_exists_p(row.component_id, row.group_id) = 'f' then
        result := 'f';
        PERFORM acs_log__error('composition_rel.check_representation',
                      'Extraneous row in group_component_index: ' ||
                      'group_id = ' || row.group_id || ', ' ||
                      'component_id = ' || row.component_id || ', ' ||
                      'rel_id = ' || row.rel_id || ', ' ||
                      'container_id = ' || row.container_id || '.');
      end if;
    end loop;

    return result;
   
end;$_$;


--
-- Name: composition_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION composition_rel__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  rel_id                 alias for $1;  
begin
    PERFORM acs_rel__delete(rel_id);

    return 0; 
end;$_$;


--
-- Name: composition_rel__new(integer, character varying, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION composition_rel__new(integer, character varying, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__rel_id            alias for $1;  -- default null  
  rel_type               alias for $2;  -- default 'composition_rel'
  object_id_one          alias for $3;  
  object_id_two          alias for $4;  
  creation_user          alias for $5;  -- default null
  creation_ip            alias for $6;  -- default null
  v_rel_id               integer;       
begin
    v_rel_id := acs_rel__new (
      new__rel_id,
      rel_type,
      object_id_one,
      object_id_two,
      object_id_one,
      creation_user,
      creation_ip
    );

    insert into composition_rels
     (rel_id)
    values
     (v_rel_id);

    return v_rel_id;
   
end;$_$;


--
-- Name: composition_rel__new(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION composition_rel__new(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  object_id_one          alias for $1;  
  object_id_two          alias for $2;  
begin
        return composition_rel__new(null,
                                    'composition_rel',
                                    object_id_one,
                                    object_id_two,
                                    null,
                                    null);
end;$_$;


--
-- Name: composition_rels_del_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION composition_rels_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  v_object_id_one acs_rels.object_id_one%TYPE;
  v_object_id_two acs_rels.object_id_two%TYPE;
  n_rows          integer;
  v_error         text;
  map             record;
begin
  -- First check if removing this relation would violate any relational constraints
  v_error := rel_constraint__violation_if_removed(old.rel_id);
  if v_error is not null then
      raise EXCEPTION '-20000: %', v_error;
  end if;

  select object_id_one, object_id_two into v_object_id_one, v_object_id_two
  from acs_rels
  where rel_id = old.rel_id;

  for map in  select *
	      from group_component_map
	      where rel_id = old.rel_id 
  LOOP

    delete from group_element_index
    where rel_id = old.rel_id;

    select count(*) into n_rows
    from group_component_map
    where group_id = map.group_id
    and component_id = map.component_id;

    if n_rows = 0 then

      perform party_approved_member__remove(map.group_id, member_id, rel_id, rel_type)
      from group_approved_member_map
      where group_id = map.group_id
      and container_id = map.component_id;

      delete from group_element_index
      where group_id = map.group_id
      and container_id = map.component_id
      and ancestor_rel_type = 'membership_rel';
    end if;

  end loop;


  for map in  select *
              from group_component_map
	      where group_id in (select group_id
		               from group_component_map
		               where component_id = v_object_id_one
			       union
			       select v_object_id_one
			       from dual)
              and component_id in (select component_id
			           from group_component_map
			           where group_id = v_object_id_two
				   union
				   select v_object_id_two
				   from dual)
              and group_contains_p(group_id, component_id, rel_id) = 'f' 
  LOOP

    delete from group_element_index
    where group_id = map.group_id
    and element_id = map.component_id
    and rel_id = map.rel_id;

    select count(*) into n_rows
    from group_component_map
    where group_id = map.group_id
    and component_id = map.component_id;

    if n_rows = 0 then
    end if;

      perform party_approved_member__remove(map.group_id, member_id, rel_id, rel_type)
      from group_approved_member_map
      where group_id = map.group_id
      and container_id = map.component_id;

      delete from group_element_index
      where group_id = map.group_id
      and container_id = map.component_id
      and ancestor_rel_type = 'membership_rel';

  end loop;

  return old;

end;$$;


--
-- Name: composition_rels_in_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION composition_rels_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  v_object_id_one acs_rels.object_id_one%TYPE;
  v_object_id_two acs_rels.object_id_two%TYPE;
  v_rel_type      acs_rels.rel_type%TYPE;
  v_error         text;
  map             record;
begin
  
  -- First check if added this relation violated any relational constraints
  v_error := rel_constraint__violation(new.rel_id);

  if v_error is not null then
      raise EXCEPTION '-20000: %', v_error;
  end if;

  select object_id_one, object_id_two, rel_type
  into v_object_id_one, v_object_id_two, v_rel_type
  from acs_rels
  where rel_id = new.rel_id;

  -- Insert a row for me in group_element_index
  insert into group_element_index
   (group_id, element_id, rel_id, container_id,
    rel_type, ancestor_rel_type)
  values
   (v_object_id_one, v_object_id_two, new.rel_id, v_object_id_one,
    v_rel_type, 'composition_rel');

  -- Add to the denormalized party_approved_member_map

  perform party_approved_member__add(v_object_id_one, member_id, rel_id, rel_type)
  from group_approved_member_map m
  where group_id = v_object_id_two
  and not exists (select 1
		  from group_element_map
		  where group_id = v_object_id_one
		  and element_id = m.member_id
		  and rel_id = m.rel_id);

  -- Make my elements be elements of my new composite group
  insert into group_element_index
   (group_id, element_id, rel_id, container_id,
    rel_type, ancestor_rel_type)
  select distinct
   v_object_id_one, element_id, rel_id, container_id,
   rel_type, ancestor_rel_type
  from group_element_map m
  where group_id = v_object_id_two
  and not exists (select 1
		  from group_element_map
		  where group_id = v_object_id_one
		  and element_id = m.element_id
		  and rel_id = m.rel_id);

  -- For all direct or indirect containers of my new composite group, 
  -- add me and add my elements
  for map in  select distinct group_id
	      from group_component_map
	      where component_id = v_object_id_one 
  LOOP

    -- Add a row for me

    insert into group_element_index
     (group_id, element_id, rel_id, container_id,
      rel_type, ancestor_rel_type)
    values
     (map.group_id, v_object_id_two, new.rel_id, v_object_id_one,
      v_rel_type, 'composition_rel');

    -- Add to party_approved_member_map

    perform party_approved_member__add(map.group_id, member_id, rel_id, rel_type)
    from group_approved_member_map m
    where group_id = v_object_id_two
    and not exists (select 1
		    from group_element_map
		    where group_id = map.group_id
		    and element_id = m.member_id
		    and rel_id = m.rel_id);

    -- Add rows for my elements

    insert into group_element_index
     (group_id, element_id, rel_id, container_id,
      rel_type, ancestor_rel_type)
    select distinct
     map.group_id, element_id, rel_id, container_id,
     rel_type, ancestor_rel_type
    from group_element_map m
    where group_id = v_object_id_two
    and not exists (select 1
		    from group_element_map
		    where group_id = map.group_id
		    and element_id = m.element_id
		    and rel_id = m.rel_id);
  end loop;

  return new;

end;$$;


--
-- Name: content_extlink__copy(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_extlink__copy(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  copy__extlink_id             alias for $1;  
  copy__target_folder_id       alias for $2;  
  copy__creation_user          alias for $3;  
  copy__creation_ip            alias for $4;  -- default null
  v_extlink_id                 cr_extlinks.extlink_id%TYPE;
begin
	v_extlink_id := content_extlink__copy (
		copy__extlink_id,
		copy__target_folder_id,
		copy__creation_user,
		copy__creation_ip,
		NULL
	);
	return 0;
end;$_$;


--
-- Name: content_extlink__copy(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_extlink__copy(integer, integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  copy__extlink_id             alias for $1;  
  copy__target_folder_id       alias for $2;  
  copy__creation_user          alias for $3;  
  copy__creation_ip            alias for $4;  -- default null
  copy__name                   alias for $5;
  v_current_folder_id          cr_folders.folder_id%TYPE;
  v_name                       cr_items.name%TYPE;
  v_url                        cr_extlinks.url%TYPE;
  v_description                cr_extlinks.description%TYPE;
  v_label                      cr_extlinks.label%TYPE;
  v_extlink_id                 cr_extlinks.extlink_id%TYPE;
begin

  if content_folder__is_folder(copy__target_folder_id) = 't' then
    select
      parent_id
    into
      v_current_folder_id
    from
      cr_items
    where
      item_id = copy__extlink_id;

    -- can't copy to the same folder

    select
      i.name, e.url, e.description, e.label
    into
      v_name, v_url, v_description, v_label
    from
      cr_extlinks e, cr_items i
    where
      e.extlink_id = i.item_id
    and
      e.extlink_id = copy__extlink_id;
	
	-- copy to a different folder, or same folder if name
	-- is different
    if copy__target_folder_id != v_current_folder_id  or ( v_name <> copy_name and copy_name is not null ) then

      if content_folder__is_registered(copy__target_folder_id,
        'content_extlink','f') = 't' then

        v_extlink_id := content_extlink__new(
            coalesce (copy__name, v_name),
            v_url,
            v_label,
            v_description,
            copy__target_folder_id,
            null,
            current_timestamp,
	    copy__creation_user,
	    copy__creation_ip,
            null
        );

      end if;
    end if;
  end if;

  return 0; 
end;$_$;


--
-- Name: content_extlink__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_extlink__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__extlink_id             alias for $1;  
begin

  delete from cr_extlinks
    where extlink_id = delete__extlink_id;

  PERFORM content_item__delete(delete__extlink_id);

return 0; 
end;$_$;


--
-- Name: content_extlink__is_extlink(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_extlink__is_extlink(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_extlink__item_id                alias for $1;  
  v_extlink_p                        boolean;
begin

  select 
    count(1) = 1 into v_extlink_p
  from 
    cr_extlinks
  where 
    extlink_id = is_extlink__item_id;
  
  return v_extlink_p;
 
end;$_$;


--
-- Name: content_extlink__new(character varying, character varying, character varying, character varying, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_extlink__new(character varying, character varying, character varying, character varying, integer, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  -- default null  
  new__url                    alias for $2;  
  new__label                  alias for $3;  -- default null
  new__description            alias for $4;  -- default null
  new__parent_id              alias for $5;  
  new__extlink_id             alias for $6;  -- default null
  new__creation_date          alias for $7;  -- default now()
  new__creation_user          alias for $8;  -- default null
  new__creation_ip            alias for $9;  -- default null
begin
  return content_extlink__new(new__name,
                              new__url,
                              new__label,
                              new__description,
                              new__parent_id,
                              new__extlink_id,
                              new__creation_date,
                              new__creation_user,
                              new__creation_ip,
                              null
  );

end;$_$;


--
-- Name: content_extlink__new(character varying, character varying, character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_extlink__new(character varying, character varying, character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  -- default null  
  new__url                    alias for $2;  
  new__label                  alias for $3;  -- default null
  new__description            alias for $4;  -- default null
  new__parent_id              alias for $5;  
  new__extlink_id             alias for $6;  -- default null
  new__creation_date          alias for $7;  -- default now()
  new__creation_user          alias for $8;  -- default null
  new__creation_ip            alias for $9;  -- default null
  new__package_id             alias for $10; -- default null
  v_extlink_id                cr_extlinks.extlink_id%TYPE;
  v_package_id                acs_objects.package_id%TYPE;
  v_label                     cr_extlinks.label%TYPE;
  v_name                      cr_items.name%TYPE;
begin

  if new__label is null then
    v_label := new__url;
  else
    v_label := new__label;
  end if;

  if new__name is null then
    select acs_object_id_seq.nextval into v_extlink_id from dual;
    v_name := 'link' || v_extlink_id;
  else
    v_name := new__name;
  end if;

  if new__package_id is null then
    v_package_id := acs_object__package_id(new__parent_id);
  else
    v_package_id := new__package_id;
  end if;

  v_extlink_id := content_item__new(
      v_name, 
      new__parent_id,
      new__extlink_id,
      null,
      new__creation_date, 
      new__creation_user, 
      null,
      new__creation_ip, 
      'content_item',
      'content_extlink', 
      null,
      null,
      'text/plain',
      null,
      null,
      'text',
      v_package_id
  );

  insert into cr_extlinks
    (extlink_id, url, label, description)
  values
    (v_extlink_id, new__url, v_label, new__description);

  update acs_objects
  set title = v_label
  where object_id = v_extlink_id;

  return v_extlink_id;

end;$_$;


--
-- Name: content_folder__copy(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__copy(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  copy__folder_id              alias for $1;  
  copy__target_folder_id       alias for $2;  
  copy__creation_user          alias for $3;  
  copy__creation_ip            alias for $4;  -- default null  
  v_valid_folders_p            integer;        
  v_current_folder_id          cr_folders.folder_id%TYPE;
  v_name                       cr_items.name%TYPE;
  v_label                      cr_folders.label%TYPE;
  v_description                cr_folders.description%TYPE;
  v_new_folder_id              cr_folders.folder_id%TYPE;
  v_folder_contents_val        record;
begin
	v_new_folder_id := content_folder__copy (
			copy__folder_id,
			copy__target_folder_id,
			copy__creation_user,
			copy__creation_ip,
			NULL
			);
	return v_new_folder_id;
end;$_$;


--
-- Name: content_folder__copy(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__copy(integer, integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  copy__folder_id              alias for $1;  
  copy__target_folder_id       alias for $2;  
  copy__creation_user          alias for $3;  
  copy__creation_ip            alias for $4;  -- default null
  copy__name                   alias for $5; -- default null
  v_valid_folders_p            integer;
  v_current_folder_id          cr_folders.folder_id%TYPE;
  v_name                       cr_items.name%TYPE;
  v_label                      cr_folders.label%TYPE;
  v_description                cr_folders.description%TYPE;
  v_new_folder_id              cr_folders.folder_id%TYPE;
  v_folder_contents_val        record;
begin

  select 
    count(*)
  into 
    v_valid_folders_p
  from 
    cr_folders
  where
    folder_id = copy__target_folder_id
  or 
    folder_id = copy__folder_id;

  select
    parent_id
  into
    v_current_folder_id
  from
    cr_items
  where
    item_id = copy__folder_id;  

  if copy__folder_id = content_item__get_root_folder(null) 
     or copy__folder_id = content_template__get_root_folder() 
     or copy__target_folder_id = copy__folder_id then
    v_valid_folders_p := 0;
  end if;

    -- get the source folder info
    select
      name, label, description
    into
      v_name, v_label, v_description
    from 
      cr_items i, cr_folders f
    where
      f.folder_id = i.item_id
    and
      f.folder_id = copy__folder_id;

  if v_valid_folders_p = 2 then 

    if content_folder__is_sub_folder(copy__folder_id, copy__target_folder_id) != 't' or v_current_folder_id != copy__target_folder_id or (v_name != copy__name and copy__name is not null) then 

      -- create the new folder
      v_new_folder_id := content_folder__new(
          coalesce (copy__name, v_name),
	  v_label,
	  v_description,
	  copy__target_folder_id,
	  copy__target_folder_id,
          null,
          now(),
	  copy__creation_user,
	  copy__creation_ip,
          't',
          null
      );

      -- copy attributes of original folder
      insert into cr_folder_type_map
        select 
          v_new_folder_id as folder_id, content_type
        from
          cr_folder_type_map map
        where
          folder_id = copy__folder_id
        and
	  -- do not register content_type if it is already registered
          not exists ( select 1 from cr_folder_type_map
	               where folder_id = v_new_folder_id 
		       and content_type = map.content_type ) ;

      -- for each item in the folder, copy it
      for v_folder_contents_val in select
                                     item_id
                                   from
                                     cr_items
                                   where
                                     parent_id = copy__folder_id 
      LOOP
        
	PERFORM content_item__copy(
	    v_folder_contents_val.item_id,
	    v_new_folder_id,
	    copy__creation_user,
	    copy__creation_ip,
            null
	);

      end loop;
    end if;
  end if;

  return 0; 
end;$_$;


--
-- Name: content_folder__del(integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__del(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__folder_id              alias for $1;  
  p_cascade_p                    alias for $2;
  v_count                        integer;       
  v_child_row                    record;
  v_parent_id                    integer;  
  v_path                         varchar;     
  v_folder_sortkey               varbit;
begin

  if p_cascade_p = 'f' then
    select count(*) into v_count from cr_items 
     where parent_id = delete__folder_id;
    -- check if the folder contains any items
    if v_count > 0 then
      v_path := content_item__get_path(delete__folder_id, null);
      raise EXCEPTION '-20000: Folder ID % (%) cannot be deleted because it is not empty.', delete__folder_id, v_path;
    end if;  
  else 
  -- delete children
    select into v_folder_sortkey tree_sortkey
    from cr_items where item_id=delete__folder_id;

    for v_child_row in select
        item_id, tree_sortkey, name
        from cr_items
        where tree_sortkey between v_folder_sortkey and tree_right(v_folder_sortkey)   
	and tree_sortkey != v_folder_sortkey
        order by tree_sortkey desc
    loop
	if content_folder__is_folder(v_child_row.item_id) then
	  perform content_folder__delete(v_child_row.item_id);
        else
         perform content_item__delete(v_child_row.item_id);
	end if;
    end loop;
  end if;

  PERFORM content_folder__unregister_content_type(
      delete__folder_id,
      'content_revision',
      't' 
  );

  delete from cr_folder_type_map
    where folder_id = delete__folder_id;

  select parent_id into v_parent_id from cr_items 
    where item_id = delete__folder_id;
  raise notice 'deleteing folder %',delete__folder_id;
  PERFORM content_item__delete(delete__folder_id);

  -- check if any folders are left in the parent
  update cr_folders set has_child_folders = 'f' 
    where folder_id = v_parent_id and not exists (
      select 1 from cr_items 
        where parent_id = v_parent_id and content_type = 'content_folder');

  return 0; 
end;$_$;


--
-- Name: content_folder__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__folder_id              alias for $1;  
  v_count                        integer;       
  v_parent_id                    integer;  
  v_path                         varchar;     
begin
	return content_folder__del(
		delete__folder_id,
		'f'
		);
end;$_$;


--
-- Name: content_folder__delete(integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__delete(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__folder_id              alias for $1;  
  p_cascade_p                    alias for $2;
begin
        PERFORM content_folder__del(delete__folder_id,p_cascade_p);
  return 0; 
end;$_$;


--
-- Name: content_folder__edit_name(integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__edit_name(integer, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  edit_name__folder_id              alias for $1;  
  edit_name__name                   alias for $2;  -- default null  
  edit_name__label                  alias for $3;  -- default null
  edit_name__description            alias for $4;  -- default null
  v_name_already_exists_p        integer;
begin

  if edit_name__name is not null and edit_name__name != '' then
    PERFORM content_item__edit_name(edit_name__folder_id, edit_name__name);
  end if;

  if edit_name__label is not null and edit_name__label != '' then
    update acs_objects
    set title = edit_name__label
    where object_id = edit_name__folder_id;
  end if;

  if edit_name__label is not null and edit_name__label != '' and 
     edit_name__description is not null and edit_name__description != '' then 

    update cr_folders
      set label = edit_name__label,
      description = edit_name__description
      where folder_id = edit_name__folder_id;

  else if(edit_name__label is not null and edit_name__label != '') and 
         (edit_name__description is null or edit_name__description = '') then  
    update cr_folders
      set label = edit_name__label
      where folder_id = edit_name__folder_id;

  end if; end if;

  return 0; 
end;$_$;


--
-- Name: content_folder__get_index_page(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__get_index_page(integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get_index_page__folder_id              alias for $1;  
  v_folder_id                            cr_folders.folder_id%TYPE;
  v_index_page_id                        cr_items.item_id%TYPE;
begin

  -- if the folder is a symlink, resolve it
  if content_symlink__is_symlink(get_index_page__folder_id) = 't' then
    v_folder_id := content_symlink__resolve(get_index_page__folder_id);
  else
    v_folder_id := get_index_page__folder_id;
  end if;

  select
    item_id into v_index_page_id
  from
    cr_items
  where
    parent_id = v_folder_id
  and
    name = 'index'
  and
    content_item__is_subclass(
      content_item__get_content_type(content_symlink__resolve(item_id)),
    'content_folder') = 'f'
  and
    content_item__is_subclass(
      content_item__get_content_type(content_symlink__resolve(item_id)),
    'content_template') = 'f';

  if NOT FOUND then 
     return null;
  end if;

  return v_index_page_id;

end;$_$;


--
-- Name: content_folder__get_label(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__get_label(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get_label__folder_id              alias for $1;  
  v_label                           cr_folders.label%TYPE;
begin

  select 
    label into v_label 
  from 
    cr_folders       
  where 
    folder_id = get_label__folder_id;

  return v_label;
 
end;$_$;


--
-- Name: content_folder__is_empty(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__is_empty(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  is_empty__folder_id              alias for $1;  
  v_return                         boolean;    
begin

  select
    count(*) = 0 into v_return
  from
    cr_items
  where
    parent_id = is_empty__folder_id;

  return v_return;
 
end;$_$;


--
-- Name: content_folder__is_folder(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__is_folder(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  item_id                alias for $1;  
begin

  return count(*) > 0 from cr_folders
    where folder_id = item_id;

end;$_$;


--
-- Name: content_folder__is_registered(integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__is_registered(integer, character varying, boolean) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  is_registered__folder_id              alias for $1;  
  is_registered__content_type           alias for $2;  
  is_registered__include_subtypes       alias for $3;  -- default 'f'  
  v_is_registered                       integer;
  v_subtype_val                         record;
begin

  if is_registered__include_subtypes = 'f' or  is_registered__include_subtypes is null then
    select 
      count(1)
    into 
      v_is_registered
    from
      cr_folder_type_map
    where
      folder_id = is_registered__folder_id
    and
      content_type = is_registered__content_type;

  else
--                         select
--                            object_type
--                          from 
--                            acs_object_types
--                          where 
--                            object_type <> 'acs_object'
--                          connect by 
--                            prior object_type = supertype
--                          start with 
--                            object_type = is_registered.content_type 

    v_is_registered := 1;
    for v_subtype_val in select o.object_type
                         from acs_object_types o, acs_object_types o2
                         where o.object_type <> 'acs_object'
                           and o2.object_type = is_registered__content_type
                           and o.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey)
                         order by o.tree_sortkey
    LOOP
      if content_folder__is_registered(is_registered__folder_id,
                       v_subtype_val.object_type, 'f') = 'f' then
        v_is_registered := 0;
      end if;
    end loop;
  end if;

  if v_is_registered = 0 then
    return 'f';
  else
    return 't';
  end if;
 
end;$_$;


--
-- Name: content_folder__is_root(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__is_root(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_root__folder_id              alias for $1;  
  v_is_root                       boolean;       
begin

  select parent_id = -4 into v_is_root 
    from cr_items where item_id = is_root__folder_id;

  return v_is_root;
 
end;$_$;


--
-- Name: content_folder__is_sub_folder(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__is_sub_folder(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_sub_folder__folder_id              alias for $1;  
  is_sub_folder__target_folder_id       alias for $2;  
  v_parent_id                           integer default 0;       
  v_sub_folder_p                        boolean default 'f';           
  v_rec                                 record;
begin

  if is_sub_folder__folder_id = content_item__get_root_folder(null) or
    is_sub_folder__folder_id = content_template__get_root_folder() then

    v_sub_folder_p := 't';
  end if;

--               select
--                 parent_id
--               from 
--                 cr_items
--               connect by
--                 prior parent_id = item_id
--               start with
--                 item_id = is_sub_folder__target_folder_id

  for v_rec in select i2.parent_id
               from cr_items i1, cr_items i2
               where i1.item_id = is_sub_folder__target_folder_id
                 and i1.tree_sortkey between i2.tree_sortkey and tree_right(i2.tree_sortkey)
               order by i2.tree_sortkey desc
  LOOP
    v_parent_id := v_rec.parent_id;
    exit when v_parent_id = is_sub_folder__folder_id;
    -- we did not find the folder, reset v_parent_id
    v_parent_id := -4;
  end LOOP;

  if v_parent_id != -4 then 
    v_sub_folder_p := 't';
  end if;

  return v_sub_folder_p;
 
end;$_$;


--
-- Name: content_folder__move(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__move(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  move__folder_id              alias for $1;  
  move__target_folder_id       alias for $2;  
begin

  perform content_folder__move (
                                move__folder_id,
                                move__target_folder_id,
                                NULL
                               );
  return null;
end;$_$;


--
-- Name: content_folder__move(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__move(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  move__folder_id              alias for $1;  
  move__target_folder_id       alias for $2;
  move__name                   alias for $3;
  v_source_folder_id           integer;       
  v_valid_folders_p            integer;
begin

  select 
    count(*)
  into 
    v_valid_folders_p
  from 
    cr_folders
  where
    folder_id = move__target_folder_id
  or 
    folder_id = move__folder_id;

  if v_valid_folders_p != 2 then
    raise EXCEPTION '-20000: content_folder.move - Not valid folder(s)';
  end if;

  if move__folder_id = content_item__get_root_folder(null) or
    move__folder_id = content_template__get_root_folder() then
    raise EXCEPTION '-20000: content_folder.move - Cannot move root folder';
  end if;
  
  if move__target_folder_id = move__folder_id then
    raise EXCEPTION '-20000: content_folder.move - Cannot move a folder to itself';
  end if;

  if content_folder__is_sub_folder(move__folder_id, move__target_folder_id) = 't' then
    raise EXCEPTION '-20000: content_folder.move - Destination folder is subfolder';
  end if;

  if content_folder__is_registered(move__target_folder_id,'content_folder','f') != 't' then
    raise EXCEPTION '-20000: content_folder.move - Destination folder does not allow subfolders';
  end if;

  select parent_id into v_source_folder_id from cr_items 
    where item_id = move__folder_id;

   -- update the parent_id for the folder
   update cr_items 
     set parent_id = move__target_folder_id,
         name = coalesce ( move__name, name )
     where item_id = move__folder_id;

  -- update the has_child_folders flags

  -- update the source
  update cr_folders set has_child_folders = 'f' 
    where folder_id = v_source_folder_id and not exists (
      select 1 from cr_items 
        where parent_id = v_source_folder_id 
          and content_type = 'content_folder');

  -- update the destination
  update cr_folders set has_child_folders = 't'
    where folder_id = move__target_folder_id;

  return 0; 
end;$_$;


--
-- Name: content_folder__new(character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__new(character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__label                  alias for $2;  
  new__description            alias for $3;  -- default null  
  new__parent_id              alias for $4;  -- default null
begin
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   null,
                                   null,
                                   now(),
                                   null,
                                   null,
                                   't',
                                   null
               );

end;$_$;


--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__label                  alias for $2;  
  new__description            alias for $3;  -- default null
  new__parent_id              alias for $4;  -- default null
  new__context_id             alias for $5;  -- default null
  new__folder_id              alias for $6;  -- default null
  new__creation_date          alias for $7;  -- default now()
  new__creation_user          alias for $8;  -- default null
  new__creation_ip            alias for $9;  -- default null
begin
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   new__context_id,
                                   new__folder_id,
                                   new__creation_date,
                                   new__creation_user,
                                   new__creation_ip,
                                   't',
                                   null::integer
               );

end;$_$;


--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__label                  alias for $2;  
  new__description            alias for $3;  -- default null
  new__parent_id              alias for $4;  -- default null
  new__context_id             alias for $5;  -- default null
  new__folder_id              alias for $6;  -- default null
  new__creation_date          alias for $7;  -- default now()
  new__creation_user          alias for $8;  -- default null
  new__creation_ip            alias for $9;  -- default null
  new__security_inherit_p     alias for $10;  -- default true	
begin
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   new__context_id,
                                   new__folder_id,
                                   new__creation_date,
                                   new__creation_user,
                                   new__creation_ip,
                                   new__security_inherit_p,
                                   null::integer
               );

end;$_$;


--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__label                  alias for $2;  
  new__description            alias for $3;  -- default null
  new__parent_id              alias for $4;  -- default null
  new__context_id             alias for $5;  -- default null
  new__folder_id              alias for $6;  -- default null
  new__creation_date          alias for $7;  -- default now()
  new__creation_user          alias for $8;  -- default null
  new__creation_ip            alias for $9;  -- default null
  new__security_inherit_p     alias for $10;  -- default true
  new__package_id             alias for $11; -- default null
  v_folder_id                 cr_folders.folder_id%TYPE;
  v_context_id                acs_objects.context_id%TYPE;
begin

  -- set the context_id
  if new__context_id is null then
    v_context_id := new__parent_id;
  else
    v_context_id := new__context_id;
  end if;

  -- parent_id = security_context_root means that this is a mount point
  if new__parent_id != -4 and 
    content_folder__is_folder(new__parent_id) and
    content_folder__is_registered(new__parent_id,'content_folder','f') = 'f' then

    raise EXCEPTION '-20000: This folder does not allow subfolders to be created';
    return null;

  else

    v_folder_id := content_item__new(
	new__folder_id,
	new__name, 
        new__parent_id,
        null,
        new__creation_date, 
        new__creation_user, 
	new__context_id,
	new__creation_ip, 
	'f',
	'text/plain',
	null,
	'text',
	new__security_inherit_p,
	'CR_FILES',
	'content_folder',
        'content_folder',
        new__package_id
    );

    insert into cr_folders (
      folder_id, label, description, package_id
    ) values (
      v_folder_id, new__label, new__description, new__package_id
    );

    -- set the correct object title
    update acs_objects
    set title = new__label
    where object_id = v_folder_id;

    -- inherit the attributes of the parent folder
    if new__parent_id is not null then
    
      insert into cr_folder_type_map
        select
          v_folder_id as folder_id, content_type
        from
          cr_folder_type_map

where
          folder_id = new__parent_id;
    end if;

    -- update the child flag on the parent
    update cr_folders set has_child_folders = 't'
      where folder_id = new__parent_id;

    return v_folder_id;

  end if;

  return v_folder_id; 
end;$_$;


--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__new(character varying, character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__label                  alias for $2;  
  new__description            alias for $3;  -- default null  
  new__parent_id              alias for $4;  -- default null
  new__package_id             alias for $5;  -- default null
begin
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   null,
                                   null,
                                   now(),
                                   null,
                                   null,
                                   new__package_id
               );

end;$_$;


--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__label                  alias for $2;  
  new__description            alias for $3;  -- default null
  new__parent_id              alias for $4;  -- default null
  new__context_id             alias for $5;  -- default null
  new__folder_id              alias for $6;  -- default null
  new__creation_date          alias for $7;  -- default now()
  new__creation_user          alias for $8;  -- default null
  new__creation_ip            alias for $9;  -- default null
  new__package_id             alias for $10;  -- default null
  v_folder_id                 cr_folders.folder_id%TYPE;
  v_context_id                acs_objects.context_id%TYPE;
  v_package_id                acs_objects.package_id%TYPE;
begin
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   new__context_id,
                                   new__folder_id,
                                   new__creation_date,
                                   new__creation_user,
                                   new__creation_ip,
                                   't',
                                   new__package_id
               );
end;$_$;


--
-- Name: content_folder__register_content_type(integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__register_content_type(integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  register_content_type__folder_id              alias for $1;  
  register_content_type__content_type           alias for $2;  
  register_content_type__include_subtypes       alias for $3;  -- default 'f'
  v_is_registered                               varchar;  
begin

  if register_content_type__include_subtypes = 'f' then

    v_is_registered := content_folder__is_registered(
        register_content_type__folder_id,
	register_content_type__content_type, 
	'f' 
    );

    if v_is_registered = 'f' then

        insert into cr_folder_type_map (
	  folder_id, content_type
	) values (
	  register_content_type__folder_id, 
	  register_content_type__content_type
	);

    end if;

  else

--    insert into cr_folder_type_map
--      select 
--        register_content_type__folder_id as folder_id, 
--        object_type as content_type
--      from
--        acs_object_types
--      where
--        object_type <> 'acs_object'
--      and
--        not exists (select 1 from cr_folder_type_map
--                    where folder_id = register_content_type__folder_id
--                    and content_type = acs_object_types.object_type)
--      connect by 
--        prior object_type = supertype
--      start with 
--        object_type = register_content_type__content_type;
    
    insert into cr_folder_type_map
      select register_content_type__folder_id as folder_id, 
        o.object_type as content_type
      from acs_object_types o, acs_object_types o2
      where o.object_type <> 'acs_object'
        and not exists (select 1
                        from cr_folder_type_map
                        where folder_id = register_content_type__folder_id
                          and content_type = o.object_type)
        and o2.object_type = register_content_type__content_type
        and o.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey);
  end if;

  return 0; 
end;$_$;


--
-- Name: content_folder__rename(integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__rename(integer, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  rename__folder_id              alias for $1;  
  rename__name                   alias for $2;  -- default null  
  rename__label                  alias for $3;  -- default null
  rename__description            alias for $4;  -- default null
  v_name_already_exists_p        integer;
begin

  if rename__name is not null and rename__name != '' then
    PERFORM content_item__rename(rename__folder_id, rename__name);
  end if;

  if rename__label is not null and rename__label != '' then
    update acs_objects
    set title = rename__label
    where object_id = rename__folder_id;
  end if;

  if rename__label is not null and rename__label != '' and 
     rename__description is not null and rename__description != '' then 

    update cr_folders
      set label = rename__label,
      description = rename__description
      where folder_id = rename__folder_id;

  else if(rename__label is not null and rename__label != '') and 
         (rename__description is null or rename__description = '') then  
    update cr_folders
      set label = rename__label
      where folder_id = rename__folder_id;

  end if; end if;

  return 0; 
end;$_$;


--
-- Name: content_folder__unregister_content_type(integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_folder__unregister_content_type(integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unregister_content_type__folder_id              alias for $1;  
  unregister_content_type__content_type           alias for $2;  
  unregister_content_type__include_subtypes       alias for $3; -- default 'f' 
begin

  if unregister_content_type__include_subtypes = 'f' then
    delete from cr_folder_type_map
      where folder_id = unregister_content_type__folder_id
      and content_type = unregister_content_type__content_type;
  else

--    delete from cr_folder_type_map
--    where folder_id = unregister_content_type__folder_id
--    and content_type in (select object_type
--           from acs_object_types    
--	   where object_type <> 'acs_object'
--	   connect by prior object_type = supertype
--	   start with 
--             object_type = unregister_content_type__content_type);

    delete from cr_folder_type_map
    where folder_id = unregister_content_type__folder_id
    and content_type in (select o.object_type
                           from acs_object_types o, acs_object_types o2
	                  where o.object_type <> 'acs_object'
                            and o2.object_type = unregister_content_type__content_type
                            and o.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey));

  end if;

  return 0; 
end;$_$;


--
-- Name: content_item__abs_cursor_next_pos(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__abs_cursor_next_pos() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare 
        v_pos   integer;
begin
        select abs_cursor_pos into v_pos from get_path_cursors;
        update get_path_cursors set abs_cursor_pos = abs_cursor_pos + 1;

        return v_pos;        
end;$$;


--
-- Name: content_item__cleanup_cursors(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__cleanup_cursors(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        v_sid   alias for $1;
begin
        delete from get_path_abs_cursor where sid = v_sid;
        delete from get_path_rel_cursor where sid = v_sid;
        
        return null;
end;$_$;


--
-- Name: content_item__copy(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__copy(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  item_id                alias for $1;  
  target_folder_id       alias for $2;  
  creation_user          alias for $3;  
  creation_ip            alias for $4;  -- default null  
  copy_id                cr_items.item_id%TYPE;
begin

  copy_id := content_item__copy2(item_id, target_folder_id, creation_user, creation_ip);

  return 0; 
end;$_$;


--
-- Name: content_item__copy(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__copy(integer, integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  copy__item_id                alias for $1;  
  copy__target_folder_id       alias for $2;  
  copy__creation_user          alias for $3;  
  copy__creation_ip            alias for $4;  -- default null  
  copy__name                   alias for $5; -- default null
  v_current_folder_id           cr_folders.folder_id%TYPE;
  v_num_revisions               integer;       
  v_name                        cr_items.name%TYPE;
  v_content_type                cr_items.content_type%TYPE;
  v_locale                      cr_items.locale%TYPE;
  v_item_id                     cr_items.item_id%TYPE;
  v_revision_id                 cr_revisions.revision_id%TYPE;
  v_is_registered               boolean;
  v_old_revision_id             cr_revisions.revision_id%TYPE;
  v_new_revision_id             cr_revisions.revision_id%TYPE;
  v_old_live_revision_id             cr_revisions.revision_id%TYPE;
  v_new_live_revision_id             cr_revisions.revision_id%TYPE;
  v_storage_type                cr_items.storage_type%TYPE;
begin

  -- call content_folder.copy if the item is a folder
  if content_folder__is_folder(copy__item_id) = 't' then
    PERFORM content_folder__copy(
        copy__item_id,
        copy__target_folder_id,
        copy__creation_user,
        copy__creation_ip,
	copy__name
    ); 

  -- call content_symlink.copy if the item is a symlink
  else if content_symlink__is_symlink(copy__item_id) = 't' then
    PERFORM content_symlink__copy(
        copy__item_id,
        copy__target_folder_id,
        copy__creation_user,
        copy__creation_ip,
	copy__name
    );

  -- call content_extlink.copy if the item is an url
  else if content_extlink__is_extlink(copy__item_id) = 't' then
    PERFORM content_extlink__copy(
        copy__item_id,
        copy__target_folder_id,
        copy__creation_user,
        copy__creation_ip,
	copy__name
    );

  -- make sure the target folder is really a folder
  else if content_folder__is_folder(copy__target_folder_id) = 't' then

    select
      parent_id
    into
      v_current_folder_id
    from
      cr_items
    where
      item_id = copy__item_id;

    select
      content_type, name, locale,
      coalesce(live_revision, latest_revision), storage_type
    into
      v_content_type, v_name, v_locale, v_revision_id, v_storage_type
    from
      cr_items
    where
      item_id = copy__item_id;

-- copy to a different folder, or allow copy to the same folder
-- with a different name

    if copy__target_folder_id != v_current_folder_id  or ( v_name != copy__name and copy__name is not null ) then
      -- make sure the content type of the item is registered to the folder
      v_is_registered := content_folder__is_registered(
          copy__target_folder_id,
          v_content_type,
          'f'
      );

      if v_is_registered = 't' then
        -- create the new content item
        v_item_id := content_item__new(
            coalesce (copy__name, v_name),
            copy__target_folder_id,
            null,
            v_locale,
            now(),
            copy__creation_user,
            null,
            copy__creation_ip,
            'content_item',            
            v_content_type,
            null,
            null,
            'text/plain',
            null,
            null,
            v_storage_type
        );

	select
          latest_revision, live_revision into v_old_revision_id, v_old_live_revision_id
        from
       	  cr_items
        where
       	  item_id = copy__item_id;
	end if;

        -- copy the latest revision (if any) to the new item
	if v_old_revision_id is not null then
          v_new_revision_id := content_revision__copy (
              v_old_revision_id,
              null,
              v_item_id,
              copy__creation_user,
              copy__creation_ip
          );
        end if;

        -- copy the live revision (if there is one and it differs from the latest) to the new item
	if v_old_live_revision_id is not null then
          if v_old_live_revision_id <> v_old_revision_id then
            v_new_live_revision_id := content_revision__copy (
              v_old_live_revision_id,
              null,
              v_item_id,
              copy__creation_user,
              copy__creation_ip
            );
          else
            v_new_live_revision_id := v_new_revision_id;
          end if;
        end if;

        update cr_items set live_revision = v_new_live_revision_id, latest_revision = v_new_revision_id where item_id = v_item_id;

    end if;

  end if; end if; end if; end if;

  return v_item_id;

end;$_$;


--
-- Name: content_item__copy2(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__copy2(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  copy2__item_id                alias for $1;  
  copy2__target_folder_id       alias for $2;  
  copy2__creation_user          alias for $3;  
  copy2__creation_ip            alias for $4;  -- default null  
  v_current_folder_id           cr_folders.folder_id%TYPE;
  v_num_revisions               integer;       
  v_name                        cr_items.name%TYPE;
  v_content_type                cr_items.content_type%TYPE;
  v_locale                      cr_items.locale%TYPE;
  v_item_id                     cr_items.item_id%TYPE;
  v_revision_id                 cr_revisions.revision_id%TYPE;
  v_is_registered               boolean;       
  v_old_revision_id             cr_revisions.revision_id%TYPE;
  v_new_revision_id             cr_revisions.revision_id%TYPE;
  v_storage_type                cr_items.storage_type%TYPE;
begin

  -- call content_folder.copy if the item is a folder
  if content_folder__is_folder(copy2__item_id) = 't' then
    PERFORM content_folder__copy(
        copy2__item_id,
        copy2__target_folder_id,
        copy2__creation_user,
        copy2__creation_ip
    );
  -- call content_symlink.copy if the item is a symlink
  else if content_symlink__is_symlink(copy2__item_id) = 't' then
    PERFORM content_symlink__copy(
        copy2__item_id,
        copy2__target_folder_id,
        copy2__creation_user,
        copy2__creation_ip
    );
  -- call content_extlink.copy if the item is an url
  else if content_extlink__is_extlink(copy2__item_id) = 't' then
    PERFORM content_extlink__copy(
        copy2__item_id,
        copy2__target_folder_id,
        copy2__creation_user,
        copy2__creation_ip
    );
  -- make sure the target folder is really a folder
  else if content_folder__is_folder(copy2__target_folder_id) = 't' then

    select
      parent_id
    into
      v_current_folder_id
    from
      cr_items
    where
      item_id = copy2__item_id;

    -- can't copy to the same folder
    if copy2__target_folder_id != v_current_folder_id then

      select
        content_type, name, locale,
        coalesce(live_revision, latest_revision), storage_type
      into
        v_content_type, v_name, v_locale, v_revision_id, v_storage_type
      from
        cr_items
      where
        item_id = copy2__item_id;

      -- make sure the content type of the item is registered to the folder
      v_is_registered := content_folder__is_registered(
          copy2__target_folder_id,
          v_content_type,
          'f'
      );

      if v_is_registered = 't' then
        -- create the new content item
        v_item_id := content_item__new(
            v_name,
            copy2__target_folder_id,
            null,
            v_locale,
            now(),
            copy2__creation_user,
            null,
            copy2__creation_ip,
            'content_item',            
            v_content_type,
            null,
            null,
            'text/plain',
            null,
            null,
            v_storage_type
        );

        -- get the latest revision of the old item
        select
          latest_revision into v_old_revision_id
        from
          cr_items
        where
          item_id = copy2__item_id;

        -- copy the latest revision (if any) to the new item
        if v_old_revision_id is not null then
          v_new_revision_id := content_revision__copy (
              v_old_revision_id,
              null,
              v_item_id,
              copy2__creation_user,
              copy2__creation_ip
          );
        end if;
      end if;


    end if;
  end if; end if; end if; end if;

  return v_item_id;
 
end;$_$;


--
-- Name: content_item__create_abs_cursor(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__create_abs_cursor(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        v_item_id       alias for $1;
        v_sid           alias for $2;
        v_rec           record;
        v_cur_pos       integer default 0;
begin
        update get_path_cursors set abs_cursor_pos = 0;
        for v_rec in select i2.name, 
                            i2.parent_id, 
                            tree_level(i2.tree_sortkey) as tree_level
                     from (select * from cr_items where item_id = v_item_id) i1,
                          cr_items i2
                     where i2.parent_id <> 0
                       and i1.tree_sortkey between i2.tree_sortkey and tree_right(i2.tree_sortkey)
                  order by i2.tree_sortkey
                     
        LOOP
                insert into get_path_abs_cursor 
                (sid,pos,name,parent_id,tree_level)
                values
                (v_sid,v_cur_pos,v_rec.name,v_rec.parent_id,v_rec.tree_level);
                v_cur_pos := v_cur_pos + 1;
        end LOOP;

        return null;
end;$_$;


--
-- Name: content_item__create_rel_cursor(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__create_rel_cursor(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        v_item_id       alias for $1;
        v_sid           alias for $2;
        v_rec           record;
        v_cur_pos       integer default 0;
begin
        update get_path_cursors set rel_cursor_pos = 0;
        for v_rec in select i2.name, 
                            i2.parent_id, 
                            tree_level(i2.tree_sortkey) as tree_level
                     from (select * from cr_items where item_id = v_item_id) i1,
                          cr_items i2
                     where i2.parent_id <> 0
                       and i1.tree_sortkey between i2.tree_sortkey and tree_right(i2.tree_sortkey)
                  order by i2.tree_sortkey
                     
        LOOP
                insert into get_path_rel_cursor 
                (sid,pos,parent_id,tree_level)
                values
                (v_sid,v_cur_pos,v_rec.parent_id,v_rec.tree_level);
                v_cur_pos := v_cur_pos + 1;
        end LOOP;

        return null;
end;$_$;


--
-- Name: content_item__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__item_id                alias for $1;  
  -- v_wf_cases_val                 record;
  v_symlink_val                  record;
  v_revision_val                 record;
  v_rel_val                      record;
begin

  -- Removed this as having workflow stuff in the CR is just plain wrong.
  -- DanW, Aug 25th, 2001.

  --   raise NOTICE 'Deleting associated workflows...';
  -- 1) delete all workflow cases associated with this item
  --   for v_wf_cases_val in select
  --                           case_id
  --                         from
  --                           wf_cases
  --                         where
  --                           object_id = delete__item_id 
  --   LOOP
  --     PERFORM workflow_case__delete(v_wf_cases_val.case_id);
  --   end loop;

  raise NOTICE 'Deleting symlinks...';
  -- 2) delete all symlinks to this item
  for v_symlink_val in select 
                         symlink_id
                       from 
                         cr_symlinks
                       where 
                         target_id = delete__item_id 
  LOOP
    PERFORM content_symlink__delete(v_symlink_val.symlink_id);
  end loop;

  raise NOTICE 'Unscheduling item...';
  delete from cr_release_periods
    where item_id = delete__item_id;


  raise NOTICE 'Unsetting live and latest revisions...';
  update cr_items set live_revision = null, latest_revision = null where item_id = delete__item_id;

  raise NOTICE 'Deleting associated revisions...';
  -- 3) delete all revisions of this item
  delete from cr_item_publish_audit
    where item_id = delete__item_id;

  for v_revision_val in select
                          revision_id 
                        from
                          cr_revisions
                        where
                          item_id = delete__item_id 
  LOOP
    PERFORM acs_object__delete(v_revision_val.revision_id);
  end loop;
  
  raise NOTICE 'Deleting associated item templates...';
  -- 4) unregister all templates to this item
  delete from cr_item_template_map
    where item_id = delete__item_id; 

  raise NOTICE 'Deleting item relationships...';
  -- Delete all relations on this item
  for v_rel_val in select
                     rel_id
                   from
                     cr_item_rels
                   where
                     item_id = delete__item_id
                   or
                     related_object_id = delete__item_id 
  LOOP
    PERFORM acs_rel__delete(v_rel_val.rel_id);
  end loop;  

  raise NOTICE 'Deleting child relationships...';
  for v_rel_val in select
                     rel_id
                   from
                     cr_child_rels
                   where
                     child_id = delete__item_id 
  LOOP
    PERFORM acs_rel__delete(v_rel_val.rel_id);
  end loop;  

  raise NOTICE 'Deleting parent relationships...';
  for v_rel_val in select
                     rel_id, child_id
                   from
                     cr_child_rels
                   where
                     parent_id = delete__item_id 
  LOOP
    PERFORM acs_rel__delete(v_rel_val.rel_id);
    PERFORM content_item__delete(v_rel_val.child_id);
  end loop;  

  raise NOTICE 'Deleting associated permissions...';
  -- 5) delete associated permissions
  delete from acs_permissions
    where object_id = delete__item_id;

  raise NOTICE 'Deleting keyword associations...';
  -- 6) delete keyword associations
  delete from cr_item_keyword_map
    where item_id = delete__item_id;

  raise NOTICE 'Deleting associated comments...';
  -- 7) delete associated comments
  PERFORM journal_entry__delete_for_object(delete__item_id);

  -- context_id debugging loop
  --for v_error_val in c_error_cur loop
  --  raise NOTICE 'ID=' || v_error_val.object_id || ' TYPE=' 
  --    || v_error_val.object_type);
  --end loop;

  raise NOTICE 'Deleting content item...';
  PERFORM acs_object__delete(delete__item_id);

  return 0; 
end;$_$;


--
-- Name: content_item__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__item_id                alias for $1;  
begin
        PERFORM content_item__del (delete__item_id);
  return 0; 
end;$_$;


--
-- Name: content_item__edit_name(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__edit_name(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  edit_name__item_id                alias for $1;  
  edit_name__name                   alias for $2;  
  exists_id                      integer;       
begin
  select
    item_id
  into 
    exists_id
  from 
    cr_items
  where
    name = edit_name__name
  and 
    parent_id = (select 
	           parent_id
		 from
		   cr_items
		 where
		   item_id = edit_name__item_id);
  if NOT FOUND then
    update cr_items
      set name = edit_name__name
      where item_id = edit_name__item_id;
  else
    if exists_id != edit_name__item_id then
      raise EXCEPTION '-20000: An item with the name % already exists in this directory.', edit_name__name;
    end if;
  end if;

  return 0; 
end;$_$;


--
-- Name: content_item__get_best_revision(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_best_revision(integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get_best_revision__item_id                alias for $1;  
  v_revision_id                             cr_revisions.revision_id%TYPE;
begin
    
  select
    coalesce(live_revision, latest_revision )
  into
    v_revision_id
  from
    cr_items
  where
    item_id = get_best_revision__item_id;

  return v_revision_id;
 
end;$_$;


--
-- Name: content_item__get_content_type(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_content_type(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get_content_type__item_id                alias for $1;  
  v_content_type                           cr_items.content_type%TYPE;
begin

  select
    content_type into v_content_type
  from 
    cr_items
  where 
    item_id = get_content_type__item_id;  

  return v_content_type;
 
end;$_$;


--
-- Name: content_item__get_context(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_context(integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  get_context__item_id                alias for $1;  
  v_context_id                        acs_objects.context_id%TYPE;
begin

  select
    context_id
  into
    v_context_id
  from
    acs_objects
  where
    object_id = get_context__item_id;

  if NOT FOUND then 
     raise EXCEPTION '-20000: Content item % does not exist in content_item.get_context', get_context__item_id;
  end if;

  return v_context_id;
 
end;$_$;


--
-- Name: content_item__get_id(character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_id(character varying, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  get_id__item_path              alias for $1;  
  get_id__root_folder_id         alias for $2;  -- default null
  get_id__resolve_index          alias for $3;  -- default 'f'
  v_item_path                    varchar; 
  v_root_folder_id               cr_items.item_id%TYPE;
  get_id__parent_id              integer;       
  child_id                       integer;       
  start_pos                      integer default 1;        
  end_pos                        integer;       
  counter                        integer default 1;
  item_name                      varchar;  
begin

  v_root_folder_id := coalesce(get_id__root_folder_id, 
                               content_item_globals.c_root_folder_id);

  -- If the request path is the root, then just return the root folder
  if get_id__item_path = '/' then
    return v_root_folder_id;
  end if;  

  -- Remove leading, trailing spaces, leading slashes
  v_item_path := rtrim(ltrim(trim(get_id__item_path), '/'), '/');

  get_id__parent_id := v_root_folder_id;

  -- if parent_id is a symlink, resolve it
  get_id__parent_id := content_symlink__resolve(get_id__parent_id);

  LOOP

    end_pos := instr(v_item_path, '/', 1, counter);

    if end_pos = 0 then
      item_name := substr(v_item_path, start_pos);
    else
      item_name := substr(v_item_path, start_pos, end_pos - start_pos);
      counter := counter + 1;
    end if;

    select 
      item_id into child_id
    from 
      cr_items
    where
      parent_id = get_id__parent_id
    and
      name = item_name;

    if NOT FOUND then 
       return null;
    end if;

    exit when end_pos = 0;

    get_id__parent_id := child_id;

    -- if parent_id is a symlink, resolve it
    get_id__parent_id := content_symlink__resolve(get_id__parent_id);

    start_pos := end_pos + 1;
      
  end loop;

  if get_id__resolve_index = 't' then

    -- if the item is a folder and has an index page, then return

    if content_folder__is_folder(child_id ) = 't' and
      content_folder__get_index_page(child_id) is not null then 

      child_id := content_folder__get_index_page(child_id);
    end if;

  end if;

  return child_id;

-- exception
--   when NO_DATA_FOUND then 
--     return null;
 
end;$_$;


--
-- Name: content_item__get_latest_revision(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_latest_revision(integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get_latest_revision__item_id                alias for $1;
  v_revision_id                               integer;
  v_rec                                       record;
begin
  for v_rec in 
  select 
    r.revision_id 
  from 
    cr_revisions r, acs_objects o
  where 
    r.revision_id = o.object_id
  and 
    r.item_id = get_latest_revision__item_id
  order by 
    o.creation_date desc
  LOOP
      v_revision_id := v_rec.revision_id;
      exit;
  end LOOP;

  return v_revision_id;
 
end;$_$;


--
-- Name: content_item__get_live_revision(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_live_revision(integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get_live_revision__item_id                alias for $1;  
  v_revision_id                             acs_objects.object_id%TYPE;
begin

  select
    live_revision into v_revision_id
  from
    cr_items
  where
    item_id = get_live_revision__item_id;

  return v_revision_id;
 
end;$_$;


--
-- Name: content_item__get_parent_folder(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_parent_folder(integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get_parent_folder__item_id               alias for $1;  
  v_folder_id                              cr_folders.folder_id%TYPE;
  v_parent_folder_p                        boolean default 'f';       
begin
  v_folder_id := get_parent_folder__item_id;

  while NOT v_parent_folder_p and v_folder_id is not null LOOP

    select
      parent_id, content_folder__is_folder(parent_id) 
    into 
      v_folder_id, v_parent_folder_p
    from
      cr_items
    where
      item_id = v_folder_id;

  end loop; 

  return v_folder_id;
 
end;$_$;


--
-- Name: content_item__get_path(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_path(integer, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  get_path__item_id                alias for $1;  
  get_path__root_folder_id         alias for $2;  -- default null  
  v_count                          integer;       
  v_resolved_root_id               integer;       
  v_path                           text    default '';  
  v_rec                            record;
begin

  -- check that the item exists
  select count(*) into v_count from cr_items where item_id = get_path__item_id;

  if v_count = 0 then
    raise EXCEPTION '-20000: Invalid item ID: %', get_path__item_id;
  end if;

  -- begin walking down the path to the item (from the repository root)
 
  -- if the root folder is not null then prepare for a relative path

  if get_path__root_folder_id is not null then

    -- if root_folder_id is a symlink, resolve it (child items will point
    -- to the actual folder, not the symlink)

    v_resolved_root_id := content_symlink__resolve(get_path__root_folder_id);

    -- check to see if the item is under or out side the root_id
    PERFORM 1 from cr_items i, 
        (select tree_sortkey from cr_items where item_id = v_resolved_root_id) a
    where tree_ancestor_p(a.tree_sortkey, i.tree_sortkey) and i.item_id = get_path__item_id;

    if NOT FOUND then
        -- if not found then we need to go up the folder and append ../ until we have common ancestor

        for v_rec in select i1.name, i1.parent_id, tree_level(i1.tree_sortkey) as tree_level
                 from cr_items i1, (select tree_ancestor_keys(tree_sortkey) as tree_sortkey from cr_items where item_id = v_resolved_root_id) i2,
                 (select tree_sortkey from cr_items where item_id = get_path__item_id) i3
                 where 
                 i1.parent_id <> 0
                 and i2.tree_sortkey = i1.tree_sortkey
                 and not tree_ancestor_p(i2.tree_sortkey, i3.tree_sortkey)
                 order by tree_level desc
        LOOP
            v_path := v_path || '../';
        end loop;
        -- lets now assign the new root_id to be the last parent_id on the loop
        v_resolved_root_id := v_rec.parent_id;

    end if;

    -- go downwards the tree and append the name and /
    for v_rec in select i1.name, i1.item_id, tree_level(i1.tree_sortkey) as tree_level
             from cr_items i1, (select tree_sortkey from cr_items where item_id = v_resolved_root_id) i2,
            (select tree_ancestor_keys(tree_sortkey) as tree_sortkey from cr_items where item_id = get_path__item_id) i3
             where 
             i1.tree_sortkey = i3.tree_sortkey
             and i1.tree_sortkey > i2.tree_sortkey
             order by tree_level
    LOOP
        v_path := v_path || v_rec.name;
        if v_rec.item_id <> get_path__item_id then 
            -- put a / if we are still going down
            v_path := v_path || '/';
        end if;
    end loop;

  else

    -- this is an absolute path so prepend a '/'
    -- loop over the absolute path

    for v_rec in select i2.name, tree_level(i2.tree_sortkey) as tree_level
                 from cr_items i1, cr_items i2
                 where i2.parent_id <> 0
                 and i1.item_id = get_path__item_id
                 and i1.tree_sortkey between i2.tree_sortkey and tree_right(i2.tree_sortkey)
                 order by tree_level
    LOOP
      v_path := v_path || '/' || v_rec.name;
    end loop;

  end if;

  return v_path;
 
end;$_$;


--
-- Name: content_item__get_publish_date(integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_publish_date(integer, boolean) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  get_publish_date__item_id                alias for $1;  
  get_publish_date__is_live                alias for $2;  -- default 'f'  
  v_revision_id                            cr_revisions.revision_id%TYPE;
  v_publish_date                           cr_revisions.publish_date%TYPE;
begin

  if get_publish_date__is_live then
    select
	publish_date into v_publish_date
    from
	cr_revisions r, cr_items i
    where
      i.item_id = get_publish_date__item_id
    and
      r.revision_id = i.live_revision;
  else
    select
	publish_date into v_publish_date
    from
	cr_revisions r, cr_items i
    where
      i.item_id = get_publish_date__item_id
    and
      r.revision_id = i.latest_revision;
  end if;

  return v_publish_date;
 
end;$_$;


--
-- Name: content_item__get_revision_count(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_revision_count(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  get_revision_count__item_id   alias for $1;  
  v_count                       integer;       
begin

  select
    count(*) into v_count
  from 
    cr_revisions
  where
    item_id = get_revision_count__item_id;

  return v_count;
 
end;$_$;


--
-- Name: content_item__get_root_folder(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_root_folder(integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  get_root_folder__item_id                alias for $1;  -- default null 
  v_folder_id                             cr_folders.folder_id%TYPE;
begin

  if get_root_folder__item_id is NULL or get_root_folder__item_id in (-4,-100,-200) then

    v_folder_id := content_item_globals.c_root_folder_id;

  else

    select i2.item_id into v_folder_id
    from cr_items i1, cr_items i2
    where i2.parent_id = -4
    and i1.item_id = get_root_folder__item_id
    and i1.tree_sortkey between i2.tree_sortkey and tree_right(i2.tree_sortkey);

    if NOT FOUND then
       raise EXCEPTION ' -20000: Could not find a root folder for item ID %. Either the item does not exist or its parent value is corrupted.', get_root_folder__item_id;
    end if;
  end if;    

  return v_folder_id;
 
end;$_$;


--
-- Name: content_item__get_template(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_template(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  get_template__item_id                alias for $1;  
  get_template__use_context            alias for $2;  
  v_template_id                        cr_templates.template_id%TYPE;
  v_content_type                       cr_items.content_type%TYPE;
begin

  -- look for a template assigned specifically to this item
  select
    template_id 
  into 
     v_template_id
  from
    cr_item_template_map
  where
    item_id = get_template__item_id
  and
    use_context = get_template__use_context;
  -- otherwise get the default for the content type
  if NOT FOUND then
    select 
      m.template_id
    into 
      v_template_id
    from
      cr_items i, cr_type_template_map m
    where
      i.item_id = get_template__item_id
    and
      i.content_type = m.content_type
    and
      m.use_context = get_template__use_context
    and
      m.is_default = 't';

    if NOT FOUND then
       return null;
    end if;
  end if;

  return v_template_id;
 
end;$_$;


--
-- Name: content_item__get_title(integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_title(integer, boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  get_title__item_id                alias for $1;  
  get_title__is_live                alias for $2;  -- default 'f'  
  v_title                           cr_revisions.title%TYPE;
  v_content_type                    cr_items.content_type%TYPE;
begin
  
  select content_type into v_content_type from cr_items 
    where item_id = get_title__item_id;

  if v_content_type = 'content_folder' then
    select label into v_title from cr_folders 
      where folder_id = get_title__item_id;
  else if v_content_type = 'content_symlink' then
    select label into v_title from cr_symlinks 
      where symlink_id = get_title__item_id;
  else
    if get_title__is_live then
      select
	title into v_title
      from
	cr_revisions r, cr_items i
      where
        i.item_id = get_title__item_id
      and
        r.revision_id = i.live_revision;
    else
      select
	title into v_title
      from
	cr_revisions r, cr_items i
      where
        i.item_id = get_title__item_id
      and
        r.revision_id = i.latest_revision;
    end if;
  end if; end if;

  return v_title;

end;$_$;


--
-- Name: content_item__get_title(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_title(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  get_title__item_id                alias for $1;  
begin
  
  return content_item__get_title(get_title__item_id, 'f');

end;$_$;


--
-- Name: content_item__get_virtual_path(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__get_virtual_path(integer, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  get_virtual_path__item_id               alias for $1;  
  get_virtual_path__root_folder_id        alias for $2; -- default content_item_globals.c_root_folder_id
  v_path                                  varchar; 
  v_item_id                               cr_items.item_id%TYPE;
  v_is_folder                             boolean;       
  v_index                                 cr_items.item_id%TYPE;
begin

  -- first resolve the item
  v_item_id := content_symlink__resolve(get_virtual_path__item_id);

  v_is_folder := content_folder__is_folder(v_item_id);
  v_index := content_folder__get_index_page(v_item_id);

  -- if the folder has an index page
  if v_is_folder = 't' and v_index is not null then
    v_path := content_item__get_path(content_symlink__resolve(v_index),null);
  else
    v_path := content_item__get_path(v_item_id,null);
  end if;

  return v_path;
--  exception
--    when NO_DATA_FOUND then
--      return null;
 
end;$_$;


--
-- Name: content_item__is_index_page(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__is_index_page(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_index_page__item_id                alias for $1;  
  is_index_page__folder_id              alias for $2;  
begin
  if content_folder__get_index_page(is_index_page__folder_id) = is_index_page__item_id then
    return 't';
  else
    return 'f';
  end if;
 
end;$_$;


--
-- Name: content_item__is_publishable(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__is_publishable(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  is_publishable__item_id                alias for $1;  
  v_child_count                          integer;       
  v_rel_count                            integer;       
  v_template_id                          cr_templates.template_id%TYPE;
  v_child_type                           record;
  v_rel_type                             record;
  v_content_type			 varchar;
  -- v_pub_wf                               record;
begin
  -- check valid item_id
  select content_item__get_content_type(is_publishable__item_id) into v_content_type;

  if v_content_type is null then 
	raise exception 'content_item__is_publishable item_id % invalid',is_publishable__item_id;
  end if;

  -- validate children
  -- make sure the # of children of each type fall between min_n and max_n
  for v_child_type in select
                        child_type, min_n, max_n
                      from
                        cr_type_children
                      where
                        parent_type = v_content_type 
	                and (min_n is not null or max_n is not null)
  LOOP
    select
      count(rel_id) into v_child_count
    from
      cr_child_rels
    where
      parent_id = is_publishable__item_id
    and
      content_item__get_content_type(child_id) = v_child_type.child_type;

    -- make sure # of children is in range
    if v_child_type.min_n is not null 
      and v_child_count < v_child_type.min_n then
      return 'f';
    end if;
    if v_child_type.max_n is not null
      and v_child_count > v_child_type.max_n then
      return 'f';
    end if;

  end LOOP;

  -- validate relations
  -- make sure the # of ext links of each type fall between min_n and max_n
  -- only check if one of min_n max_n not null
  for v_rel_type in select
                      target_type, min_n, max_n
                    from
                      cr_type_relations
                    where
                      content_type = v_content_type
		      and (max_n is not null or min_n is not null)
  LOOP
    select
      count(rel_id) into v_rel_count
    from
      cr_item_rels i, acs_objects o
    where
      i.related_object_id = o.object_id
    and
      i.item_id = is_publishable__item_id
    and
      coalesce(content_item__get_content_type(o.object_id),o.object_type) = v_rel_type.target_type;
      
    -- make sure # of object relations is in range
    if v_rel_type.min_n is not null 
      and v_rel_count < v_rel_type.min_n then
      return 'f';
    end if;
    if v_rel_type.max_n is not null 
      and v_rel_count > v_rel_type.max_n then
      return 'f';
    end if;
  end loop;

  -- validate publishing workflows
  -- make sure any 'publishing_wf' associated with this item are finished
  -- KG: logic is wrong here.  Only the latest workflow matters, and even
  -- that is a little problematic because more than one workflow may be
  -- open on an item.  In addition, this should be moved to CMS.
  
  -- Removed this as having workflow stuff in the CR is just plain wrong.
  -- DanW, Aug 25th, 2001.

  --   for v_pub_wf in  select
  --                      case_id, state
  --                    from
  --                      wf_cases
  --                    where
  --                      workflow_key = 'publishing_wf'
  --                    and
  --                      object_id = is_publishable__item_id
  -- 
  --   LOOP
  --     if v_pub_wf.state != 'finished' then
  --        return 'f';
  --     end if;
  --   end loop;

  -- if NOT FOUND then 
  --   return 'f';
  -- end if;

  return 't';
 
end;$_$;


--
-- Name: content_item__is_published(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__is_published(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_published__item_id                alias for $1;  
begin

  return
    count(*) > 0
  from
    cr_items
  where
    live_revision is not null
  and
    publish_status = 'live'
  and
    item_id = is_published__item_id;
 
end;$_$;


--
-- Name: content_item__is_subclass(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__is_subclass(character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  is_subclass__object_type            alias for $1;  
  is_subclass__supertype              alias for $2;  
  v_subclass_p                        boolean;      
  v_inherit_val                       record;
begin
  select count(*) > 0 into v_subclass_p where exists (
	select 1
          from acs_object_types o, acs_object_types o2
         where o2.object_type = is_subclass__supertype
           and o.object_type = is_subclass__object_type
           and o.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey));

  return v_subclass_p;

end;$_$;


--
-- Name: content_item__is_valid_child(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__is_valid_child(integer, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_valid_child__item_id                alias for $1;  
  is_valid_child__content_type           alias for $2;  
  v_is_valid_child                       boolean;       
  v_max_children                         cr_type_children.max_n%TYPE;
  v_n_children                           integer;       
begin

  v_is_valid_child := 'f';

  -- first check if content_type is a registered child_type
  select
    max_n into v_max_children
  from
    cr_type_children
  where
    parent_type = content_item__get_content_type(is_valid_child__item_id)
  and
    child_type = is_valid_child__content_type;

  if NOT FOUND then 
     return 'f';
  end if;

  -- if the max is null then infinite number is allowed
  if v_max_children is null then
    return 't';
  end if;

  -- next check if there are already max_n children of that content type
  select
    count(rel_id) into v_n_children
  from
    cr_child_rels
  where
    parent_id = is_valid_child__item_id
  and
    content_item__get_content_type(child_id) = is_valid_child__content_type;

  if NOT FOUND then 
     return 'f';
  end if;

  if v_n_children < v_max_children then
    v_is_valid_child := 't';
  end if;

  return v_is_valid_child;
 
end;$_$;


--
-- Name: content_item__move(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__move(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  move__item_id                alias for $1;  
  move__target_folder_id       alias for $2;
begin
  perform content_item__move(
	move__item_id,
	move__target_folder_id,
	NULL
	);
return null;
end;$_$;


--
-- Name: content_item__move(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__move(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  move__item_id                alias for $1;  
  move__target_folder_id       alias for $2;
  move__name                   alias for $3;
begin

  if move__target_folder_id is null then 
	raise exception 'attempt to move item_id % to null folder_id', move__item_id;
  end if;

  if content_folder__is_folder(move__item_id) = 't' then

    PERFORM content_folder__move(move__item_id, move__target_folder_id);

  elsif content_folder__is_folder(move__target_folder_id) = 't' then
   

    if content_folder__is_registered(move__target_folder_id,
          content_item__get_content_type(move__item_id),'f') = 't' and
       content_folder__is_registered(move__target_folder_id,
          content_item__get_content_type(content_symlink__resolve(move__item_id)),'f') = 't'
      then
    -- update the parent_id for the item

    update cr_items 
      set parent_id = move__target_folder_id,
          name = coalesce(move__name, name)
      where item_id = move__item_id;
    end if;

    if move__name is not null then
      update acs_objects
        set title = move__name
        where object_id = move__item_id;
    end if;

  end if;

  return 0; 
end;$_$;


--
-- Name: content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__parent_id              alias for $2;  -- default null  
  new__item_id                alias for $3;  -- default null
  new__locale                 alias for $4;  -- default null
  new__creation_date          alias for $5;  -- default now()
  new__creation_user          alias for $6;  -- default null
  new__context_id             alias for $7;  -- default null
  new__creation_ip            alias for $8;  -- default null
  new__item_subtype           alias for $9;  -- default 'content_item'
  new__content_type           alias for $10; -- default 'content_revision'
  new__title                  alias for $11; -- default null
  new__description            alias for $12; -- default null
  new__mime_type              alias for $13; -- default 'text/plain'
  new__nls_language           alias for $14; -- default null
  new__text                   alias for $15; -- default null
  new__storage_type           alias for $16; -- check in ('text','file')
  v_item_id                   cr_items.item_id%TYPE;
begin
  v_item_id := content_item__new (new__name, new__parent_id, new__item_id, new__locale,
               new__creation_date, new__creation_user, new__context_id, new__creation_ip,
               new__item_subtype, new__content_type, new__title, new__description,
               new__mime_type, new__nls_language, new__text, new__storage_type, null::integer);

  return v_item_id;
 
end;$_$;


--
-- Name: content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__parent_id              alias for $2;  -- default null  
  new__item_id                alias for $3;  -- default null
  new__locale                 alias for $4;  -- default null
  new__creation_date          alias for $5;  -- default now()
  new__creation_user          alias for $6;  -- default null
  new__context_id             alias for $7;  -- default null
  new__creation_ip            alias for $8;  -- default null
  new__item_subtype           alias for $9;  -- default 'content_item'
  new__content_type           alias for $10; -- default 'content_revision'
  new__title                  alias for $11; -- default null
  new__description            alias for $12; -- default null
  new__mime_type              alias for $13; -- default 'text/plain'
  new__nls_language           alias for $14; -- default null
-- changed to integer for blob_id
  new__data                   alias for $15; -- default null
  v_item_id                   cr_items.item_id%TYPE;
begin
  v_item_id := content_item__new (new__name, new__parent_id, new__item_id, new__locale,
               new__creation_date, new__creation_user, new__context_id, new__creation_ip,
               new__item_subtype, new__content_type, new__title, new__description,
               new__mime_type, new__nls_language, new__data, null::integer);

  return v_item_id;
 
end;$_$;


--
-- Name: content_item__new(character varying, integer, character varying, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer, character varying, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        new__name               alias for $1;
        new__parent_id          alias for $2;  -- default null
        new__title              alias for $3;  -- default null
        new__description        alias for $4;  -- default null
        new__text               alias for $5;  -- default null
begin
        return content_item__new(new__name, new__parent_id, new__title, new__description,
                                 new__text, null);

end;$_$;


--
-- Name: content_item__new(character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        new__name       alias for $1;
        new__parent_id  alias for $2;
begin
        return content_item__new(new__name, new__parent_id, null, null, null, null);

end;$_$;


--
-- Name: content_item__new(integer, character varying, integer, character varying, timestamp with time zone, integer, integer, character varying, boolean, character varying, text, character varying, boolean, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(integer, character varying, integer, character varying, timestamp with time zone, integer, integer, character varying, boolean, character varying, text, character varying, boolean, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__item_id                alias for $1; --default null
  new__name                   alias for $2;  
  new__parent_id              alias for $3;  -- default null  
  new__title                  alias for $4; -- default null
  new__creation_date	      alias for $5; -- default now()
  new__creation_user	      alias for $6; -- default null
  new__context_id	      alias for $7; -- default null
  new__creation_ip	      alias for $8; -- default null
  new__is_live		      alias for $9; -- default 'f'
  new__mime_type	      alias for $10; 
  new__text		      alias for $11; -- default null
  new__storage_type	      alias for $12; -- check in ('text', 'file') 
  new__security_inherit_p     alias for $13; -- default 't'
  new__storage_area_key       alias for $14; -- default 'CR_FILES'
  new__item_subtype	      alias for $15;
  new__content_type	      alias for $16; 
  v_item_id                   cr_items.item_id%TYPE;
begin
  v_item_id := content_item__new (new__item_id, new__name, new__parent_id, new__title,
               new__creation_date, new__creation_user, new__context_id, new__creation_ip,
               new__is_live, new__mime_type, new__text, new__storage_type,
               new__security_inherit_p, new__storage_area_key, new__item_subtype,
               new__content_type, null);

  return v_item_id;

end;$_$;


--
-- Name: content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, text, character varying, character varying, character varying, text, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, text, character varying, character varying, character varying, text, character varying, boolean, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name       alias for $1;
  new__parent_id  alias for $2;
  new__item_id    alias for $3;
  new__locale     alias for $4;
  new__creation_date alias for $5;
  new__creation_user alias for $6;
  new__context_id    alias for $7;
  new__creation_ip   alias for $8;
  new__item_subtype  alias for $9;
  new__content_type  alias for $10;
  new__title         alias for $11;
  new__description   alias for $12;
  new__mime_type     alias for $13;
  new__nls_language  alias for $14;
  new__text          alias for $15;
  new__data          alias for $16;
  new__relation_tag  alias for $17;
  new__is_live       alias for $18;
  new__storage_type  alias for $19;
  v_item_id        cr_items.item_id%TYPE;
begin
  v_item_id := content_item__new (new__name, new__parent_id, new__item_id, new__locale,
               new__creation_date, new__creation_user, new__context_id, new__creation_ip,
               new__item_subtype, new__content_type, new__title, new__description,
               new__mime_type, new__nls_language, new__text, new__data, new__relation_tag,
               new__is_live, new__storage_type, null);

  return v_item_id;

end;$_$;


--
-- Name: content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, text, character varying, character varying, character varying, text, character varying, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, text, character varying, character varying, character varying, text, character varying, boolean, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name       alias for $1;
  new__parent_id  alias for $2;
  new__item_id    alias for $3;
  new__locale     alias for $4;
  new__creation_date alias for $5;
  new__creation_user alias for $6;
  new__context_id    alias for $7;
  new__creation_ip   alias for $8;
  new__item_subtype  alias for $9;
  new__content_type  alias for $10;
  new__title         alias for $11;
  new__description   alias for $12;
  new__mime_type     alias for $13;
  new__nls_language  alias for $14;
  new__text          alias for $15;
  new__data          alias for $16;
  new__relation_tag  alias for $17;
  new__is_live       alias for $18;
  new__storage_type  alias for $19;
  new__package_id    alias for $20;
  v_parent_id      cr_items.parent_id%TYPE;
  v_parent_type    acs_objects.object_type%TYPE;
  v_item_id        cr_items.item_id%TYPE;
  v_title          cr_revisions.title%TYPE;
  v_revision_id    cr_revisions.revision_id%TYPE;
  v_rel_id         acs_objects.object_id%TYPE;
  v_rel_tag        cr_child_rels.relation_tag%TYPE;
  v_context_id     acs_objects.context_id%TYPE;
  v_storage_type   cr_items.storage_type%TYPE;
begin

  -- place the item in the context of the pages folder if no
  -- context specified 

  if new__parent_id is null then
    v_parent_id := content_item_globals.c_root_folder_id;
  else
    v_parent_id := new__parent_id;
  end if;

  -- Determine context_id
  if new__context_id is null then
    v_context_id := v_parent_id;
  else
    v_context_id := new__context_id;
  end if;

  -- use the name of the item if no title is supplied
  if new__title is null or new__title = '' then
    v_title := new__name;
  else
    v_title := new__title;
  end if;

  if v_parent_id = -4 or 
    content_folder__is_folder(v_parent_id) = 't' then

    if v_parent_id != -4 and 
      content_folder__is_registered(
        v_parent_id, new__content_type, 'f') = 'f' then

      raise EXCEPTION '-20000: This items content type % is not registered to this folder %', new__content_type, v_parent_id;
    end if;

  else if v_parent_id != -4 then

     if new__relation_tag is null then
       v_rel_tag := content_item__get_content_type(v_parent_id) 
         || '-' || new__content_type;
     else
       v_rel_tag := new__relation_tag;
     end if;

     select object_type into v_parent_type from acs_objects
       where object_id = v_parent_id;

     if NOT FOUND then 
       raise EXCEPTION '-20000: Invalid parent ID % specified in content_item.new',  v_parent_id;
     end if;

     if content_item__is_subclass(v_parent_type, 'content_item') = 't' and
        content_item__is_valid_child(v_parent_id, new__content_type, v_rel_tag) = 'f' then

       raise EXCEPTION '-20000: This items content type % is not allowed in this container %', new__content_type, v_parent_id;
     end if;

  end if; end if;

  -- Create the object

  v_item_id := acs_object__new(
      new__item_id,
      new__item_subtype, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      v_context_id,
      't',
      v_title,
      new__package_id
  );


  insert into cr_items (
    item_id, name, content_type, parent_id, storage_type
  ) values (
    v_item_id, new__name, new__content_type, v_parent_id, new__storage_type
  );

  -- if the parent is not a folder, insert into cr_child_rels
  if v_parent_id != -4 and
    content_folder__is_folder(v_parent_id) = 'f' then

    v_rel_id := acs_object__new(
      null,
      'cr_item_child_rel',
      now(),
      null,
      null,
      v_parent_id,
      't',
      v_rel_tag || ': ' || v_parent_id || ' - ' || v_item_id,
      new__package_id
    );

    insert into cr_child_rels (
      rel_id, parent_id, child_id, relation_tag, order_n
    ) values (
      v_rel_id, v_parent_id, v_item_id, v_rel_tag, v_item_id
    );

  end if;

  if new__data is not null then

    v_revision_id := content_revision__new(
        v_title,
	new__description,
        now(),
	new__mime_type,
	new__nls_language,
	new__data,
        v_item_id,
        null,
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
        new__package_id
        );

  elsif new__text is not null or new__title is not null then

    v_revision_id := content_revision__new(
        v_title,
	new__description,
        now(),
	new__mime_type,
        null,
	new__text,
	v_item_id,
        null,
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
        new__package_id
    );

  end if;

  -- make the revision live if is_live is true
  if new__is_live = 't' then
    PERFORM content_item__set_live_revision(v_revision_id);
  end if;

  return v_item_id;

end;$_$;


--
-- Name: content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__parent_id              alias for $2;  -- default null  
  new__item_id                alias for $3;  -- default null
  new__locale                 alias for $4;  -- default null
  new__creation_date          alias for $5;  -- default now()
  new__creation_user          alias for $6;  -- default null
  new__context_id             alias for $7;  -- default null
  new__creation_ip            alias for $8;  -- default null
  new__item_subtype           alias for $9;  -- default 'content_item'
  new__content_type           alias for $10; -- default 'content_revision'
  new__title                  alias for $11; -- default null
  new__description            alias for $12; -- default null
  new__mime_type              alias for $13; -- default 'text/plain'
  new__nls_language           alias for $14; -- default null
  new__text                   alias for $15; -- default null
  new__storage_type           alias for $16; -- check in ('text','file')
  new__package_id             alias for $17; -- default null
  new__relation_tag           varchar default null;
  new__is_live                boolean default 'f';

  v_parent_id                 cr_items.parent_id%TYPE;
  v_parent_type               acs_objects.object_type%TYPE;
  v_item_id                   cr_items.item_id%TYPE;
  v_revision_id               cr_revisions.revision_id%TYPE;
  v_title                     cr_revisions.title%TYPE;
  v_rel_id                    acs_objects.object_id%TYPE;
  v_rel_tag                   cr_child_rels.relation_tag%TYPE;
  v_context_id                acs_objects.context_id%TYPE;
begin

  -- place the item in the context of the pages folder if no
  -- context specified 

  if new__parent_id is null then
    v_parent_id := content_item_globals.c_root_folder_id;
  else
    v_parent_id := new__parent_id;
  end if;

  -- Determine context_id
  if new__context_id is null then
    v_context_id := v_parent_id;
  else
    v_context_id := new__context_id;
  end if;

  if v_parent_id = -4 or 
    content_folder__is_folder(v_parent_id) = 't' then

    if v_parent_id != -4 and 
      content_folder__is_registered(
        v_parent_id, new__content_type, 'f') = 'f' then

      raise EXCEPTION '-20000: This items content type % is not registered to this folder %', new__content_type, v_parent_id;
    end if;

  else if v_parent_id != -4 then

     select object_type into v_parent_type from acs_objects
       where object_id = v_parent_id;

     if NOT FOUND then 
       raise EXCEPTION '-20000: Invalid parent ID % specified in content_item.new',  v_parent_id;
     end if;

     if content_item__is_subclass(v_parent_type, 'content_item') = 't' and
	content_item__is_valid_child(v_parent_id, new__content_type) = 'f' then

       raise EXCEPTION '-20000: This items content type % is not allowed in this container %', new__content_type, v_parent_id;
     end if;

  end if; end if;

  -- Create the object

  v_item_id := acs_object__new(
      new__item_id,
      new__item_subtype, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      v_context_id,
      't',
      coalesce(new__title,new__name),
      new__package_id
  );

  insert into cr_items (
    item_id, name, content_type, parent_id, storage_type
  ) values (
    v_item_id, new__name, new__content_type, v_parent_id, new__storage_type
  );

  -- if the parent is not a folder, insert into cr_child_rels
  if v_parent_id != -4 and
    content_folder__is_folder(v_parent_id) = 'f' and 
    content_item__is_valid_child(v_parent_id, new__content_type) = 't' then

    if new__relation_tag is null then
      v_rel_tag := content_item__get_content_type(v_parent_id) 
        || '-' || new__content_type;
    else
      v_rel_tag := new__relation_tag;
    end if;

    v_rel_id := acs_object__new(
      null,
      'cr_item_child_rel',
      now(),
      null,
      null,
      v_parent_id,
      't',
      v_rel_tag || ': ' || v_parent_id || ' - ' || v_item_id,
      new__package_id
    );

    insert into cr_child_rels (
      rel_id, parent_id, child_id, relation_tag, order_n
    ) values (
      v_rel_id, v_parent_id, v_item_id, v_rel_tag, v_item_id
    );

  end if;

  -- use the name of the item if no title is supplied
  if new__title is null then
    v_title := new__name;
  else
    v_title := new__title;
  end if;

  if new__title is not null or 
     new__text is not null then

    v_revision_id := content_revision__new(
	v_title,
	new__description,
        now(),
	new__mime_type,
        null,
	new__text,
	v_item_id,
        null,
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
        new__package_id
    );

  end if;

  -- make the revision live if is_live is true
  if new__is_live = 't' then
    PERFORM content_item__set_live_revision(v_revision_id);
  end if;

  return v_item_id;
 
end;$_$;


--
-- Name: content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__parent_id              alias for $2;  -- default null  
  new__item_id                alias for $3;  -- default null
  new__locale                 alias for $4;  -- default null
  new__creation_date          alias for $5;  -- default now()
  new__creation_user          alias for $6;  -- default null
  new__context_id             alias for $7;  -- default null
  new__creation_ip            alias for $8;  -- default null
  new__item_subtype           alias for $9;  -- default 'content_item'
  new__content_type           alias for $10; -- default 'content_revision'
  new__title                  alias for $11; -- default null
  new__description            alias for $12; -- default null
  new__mime_type              alias for $13; -- default 'text/plain'
  new__nls_language           alias for $14; -- default null
-- changed to integer for blob_id
  new__data                   alias for $15; -- default null
  new__package_id             alias for $16; -- default null
  new__relation_tag           varchar default null;
  new__is_live                boolean default 'f';

  v_parent_id                 cr_items.parent_id%TYPE;
  v_parent_type               acs_objects.object_type%TYPE;
  v_item_id                   cr_items.item_id%TYPE;
  v_revision_id               cr_revisions.revision_id%TYPE;
  v_title                     cr_revisions.title%TYPE;
  v_rel_id                    acs_objects.object_id%TYPE;
  v_rel_tag                   cr_child_rels.relation_tag%TYPE;
  v_context_id                acs_objects.context_id%TYPE;
begin

  -- place the item in the context of the pages folder if no
  -- context specified 

  if new__parent_id is null then
    v_parent_id := content_item_globals.c_root_folder_id;
  else
    v_parent_id := new__parent_id;
  end if;

  -- Determine context_id
  if new__context_id is null then
    v_context_id := v_parent_id;
  else
    v_context_id := new__context_id;
  end if;

  -- use the name of the item if no title is supplied
  if new__title is null or new__title = '' then
    v_title := new__name;
  else
    v_title := new__title;
  end if;

  if v_parent_id = -4 or 
    content_folder__is_folder(v_parent_id) = 't' then

    if v_parent_id != -4 and 
      content_folder__is_registered(
        v_parent_id, new__content_type, 'f') = 'f' then

      raise EXCEPTION '-20000: This items content type % is not registered to this folder %', new__content_type, v_parent_id;
    end if;

  else if v_parent_id != -4 then

     select object_type into v_parent_type from acs_objects
       where object_id = v_parent_id;

     if NOT FOUND then 
       raise EXCEPTION '-20000: Invalid parent ID % specified in content_item.new',  v_parent_id;
     end if;

     if content_item__is_subclass(v_parent_type, 'content_item') = 't' and
	content_item__is_valid_child(v_parent_id, new__content_type) = 'f' then

       raise EXCEPTION '-20000: This items content type % is not allowed in this container %', new__content_type, v_parent_id;
     end if;

  end if; end if;

  -- Create the object

  v_item_id := acs_object__new(
      new__item_id,
      new__item_subtype, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      v_context_id,
      't',
      v_title,
      new__package_id
  );

  insert into cr_items (
    item_id, name, content_type, parent_id, storage_type
  ) values (
    v_item_id, new__name, new__content_type, v_parent_id, 'lob'
  );

  -- if the parent is not a folder, insert into cr_child_rels
  if v_parent_id != -4 and
    content_folder__is_folder(v_parent_id) = 'f' and 
    content_item__is_valid_child(v_parent_id, new__content_type) = 't' then

    if new__relation_tag is null or new__relation_tag = '' then
      v_rel_tag := content_item__get_content_type(v_parent_id) 
        || '-' || new__content_type;
    else
      v_rel_tag := new__relation_tag;
    end if;

    v_rel_id := acs_object__new(
      null,
      'cr_item_child_rel',
      now(),
      null,
      null,
      v_parent_id,
      't',
      v_rel_tag || ': ' || v_parent_id || ' - ' || v_item_id,
      new__package_id
    );

    insert into cr_child_rels (
      rel_id, parent_id, child_id, relation_tag, order_n
    ) values (
      v_rel_id, v_parent_id, v_item_id, v_rel_tag, v_item_id
    );

  end if;

  -- create the revision if data or title is not null

  if new__data is not null then

    v_revision_id := content_revision__new(
        v_title,
	new__description,
        now(),
	new__mime_type,
	new__nls_language,
	new__data,
        v_item_id,
        null,
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
        new__package_id
        );

  elsif new__title is not null then

    v_revision_id := content_revision__new(
	v_title,
	new__description,
        now(),
	new__mime_type,
        null,
	null,
	v_item_id,
        null,
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
        new__package_id
    );

  end if;

  -- make the revision live if is_live is true
  if new__is_live = 't' then
    PERFORM content_item__set_live_revision(v_revision_id);
  end if;

  return v_item_id;
 
end;$_$;


--
-- Name: content_item__new(character varying, integer, character varying, text, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer, character varying, text, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        new__name               alias for $1;
        new__parent_id          alias for $2;  -- default null
        new__title              alias for $3;  -- default null
        new__description        alias for $4;  -- default null
        new__text               alias for $5;  -- default null
        new__package_id         alias for $6;  -- default null
begin
        return content_item__new(new__name,
                                 new__parent_id,
                                 null,
                                 null,
                                 now(),
                                 null,
                                 null,
                                 null,
                                 'content_item',
                                 'content_revision',   
                                 new__title,
                                 new__description,
                                 'text/plain',
                                 null,
                                 new__text,
                                 'text',
                                 new__package_id
               );

end;$_$;


--
-- Name: content_item__new(character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        new__name        alias for $1;
        new__parent_id   alias for $2;
        new__package_id  alias for $3;
begin
        return content_item__new(new__name, new__parent_id, null, null, null, new__package_id);
end;$_$;


--
-- Name: content_item__new(integer, character varying, integer, character varying, timestamp with time zone, integer, integer, character varying, boolean, character varying, text, character varying, boolean, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__new(integer, character varying, integer, character varying, timestamp with time zone, integer, integer, character varying, boolean, character varying, text, character varying, boolean, character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__item_id                alias for $1; --default null
  new__name                   alias for $2;  
  new__parent_id              alias for $3;  -- default null  
  new__title                  alias for $4; -- default null
  new__creation_date	      alias for $5; -- default now()
  new__creation_user	      alias for $6; -- default null
  new__context_id	      alias for $7; -- default null
  new__creation_ip	      alias for $8; -- default null
  new__is_live		      alias for $9; -- default 'f'
  new__mime_type	      alias for $10; 
  new__text		      alias for $11; -- default null
  new__storage_type	      alias for $12; -- check in ('text', 'file') 
  new__security_inherit_p     alias for $13; -- default 't'
  new__storage_area_key       alias for $14; -- default 'CR_FILES'
  new__item_subtype	      alias for $15;
  new__content_type	      alias for $16; 
  new__package_id	      alias for $17; -- default null
  new__description	      varchar default null;
  new__relation_tag           varchar default null;
  new__nls_language	      varchar default null; 
  v_parent_id                 cr_items.parent_id%TYPE;
  v_parent_type               acs_objects.object_type%TYPE;
  v_item_id                   cr_items.item_id%TYPE;
  v_revision_id               cr_revisions.revision_id%TYPE;
  v_title                     cr_revisions.title%TYPE;
  v_rel_id                    acs_objects.object_id%TYPE;
  v_rel_tag                   cr_child_rels.relation_tag%TYPE;
  v_context_id                acs_objects.context_id%TYPE;
  v_package_id                acs_objects.package_id%TYPE;
begin

  -- place the item in the context of the pages folder if no
  -- context specified 

  if new__parent_id is null then
    v_parent_id := content_item_globals.c_root_folder_id;
  else
    v_parent_id := new__parent_id;
  end if;

  -- Determine context_id
  if new__context_id is null then
    v_context_id := v_parent_id;
  else
    v_context_id := new__context_id;
  end if;

  -- use the name of the item if no title is supplied
  if new__title is null or new__title = '' then
    v_title := new__name;
  else
    v_title := new__title;
  end if;

  if new__package_id is null then
    v_package_id := acs_object__package_id(content_item__get_root_folder(v_parent_id));
  else
    v_package_id := new__package_id;
  end if;

  if v_parent_id = 0 or 
    content_folder__is_folder(v_parent_id) = 't' then

    if v_parent_id != 0 and 
      content_folder__is_registered(
        v_parent_id, new__content_type, 'f') = 'f' then

      raise EXCEPTION '-20000: This items content type % is not registered to this folder %', new__content_type, v_parent_id;
    end if;

  else if v_parent_id != 0 then

     select object_type into v_parent_type from acs_objects
       where object_id = v_parent_id;

     if NOT FOUND then 
       raise EXCEPTION '-20000: Invalid parent ID % specified in content_item.new',  v_parent_id;
     end if;

     if content_item__is_subclass(v_parent_type, 'content_item') = 't' and
	content_item__is_valid_child(v_parent_id, new__content_type) = 'f' then

       raise EXCEPTION '-20000: This items content type % is not allowed in this container %', new__content_type, v_parent_id;
     end if;

  end if; end if;

 
  -- Create the object

  v_item_id := acs_object__new(
      new__item_id,
      new__item_subtype, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      v_context_id,
      new__security_inherit_p,
      v_title,
      v_package_id
  );

  insert into cr_items (
    item_id, name, content_type, parent_id, storage_type, storage_area_key
  ) values (
    v_item_id, new__name, new__content_type, v_parent_id, new__storage_type,
    new__storage_area_key
  );

  -- if the parent is not a folder, insert into cr_child_rels
  if v_parent_id != 0 and
    content_folder__is_folder(v_parent_id) = 'f' and 
    content_item__is_valid_child(v_parent_id, new__content_type) = 't' then

    if new__relation_tag is null then
      v_rel_tag := content_item__get_content_type(v_parent_id) 
        || '-' || new__content_type;
    else
      v_rel_tag := new__relation_tag;
    end if;

    v_rel_id := acs_object__new(
      null,
      'cr_item_child_rel',
      new__creation_date,
      null,
      null,
      v_parent_id,
      'f',
      v_rel_tag || ': ' || v_parent_id || ' - ' || v_item_id,
      v_package_id
    );

    insert into cr_child_rels (
      rel_id, parent_id, child_id, relation_tag, order_n
    ) values (
      v_rel_id, v_parent_id, v_item_id, v_rel_tag, v_item_id
    );

  end if;

  if new__title is not null or 
     new__text is not null then

    v_revision_id := content_revision__new(
	v_title,
	new__description,
        now(),
	new__mime_type,
        null,
	new__text,
	v_item_id,
        null,
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
        v_package_id
    );

  end if;

  -- make the revision live if is_live is true
  if new__is_live = 't' then
    PERFORM content_item__set_live_revision(v_revision_id);
  end if;

  return v_item_id;

end;$_$;


--
-- Name: content_item__register_template(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__register_template(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  register_template__item_id                alias for $1;  
  register_template__template_id            alias for $2;  
  register_template__use_context            alias for $3;  
                                        
begin

 -- register template if it is not already registered
  insert into cr_item_template_map
  select
    register_template__item_id as item_id,
    register_template__template_id as template_id,
    register_template__use_context as use_context
  from
    dual
  where
    not exists ( select 1
                 from
                   cr_item_template_map
                 where
                   item_id = register_template__item_id
                 and
                   template_id = register_template__template_id
                 and
                   use_context = register_template__use_context );

  return 0; 
end;$_$;


--
-- Name: content_item__rel_cursor_next_pos(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__rel_cursor_next_pos() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare 
        v_pos   integer;
begin
        select rel_cursor_pos into v_pos from get_path_cursors;
        update get_path_cursors set rel_cursor_pos = rel_cursor_pos + 1;

        return v_pos;        
end;$$;


--
-- Name: content_item__relate(integer, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__relate(integer, integer, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  relate__item_id                alias for $1;  
  relate__object_id              alias for $2;  
  relate__relation_tag           alias for $3;  -- default 'generic'  
  relate__order_n                alias for $4;  -- default null
  relate__relation_type          alias for $5;  -- default 'cr_item_rel'
  v_content_type                 cr_items.content_type%TYPE;
  v_object_type                  acs_objects.object_type%TYPE;
  v_is_valid                     integer;       
  v_rel_id                       integer;       
  v_exists                       integer;       
  v_order_n                      cr_item_rels.order_n%TYPE;
begin

  -- check the relationship is valid
  v_content_type := content_item__get_content_type (relate__item_id);
  v_object_type := content_item__get_content_type (relate__object_id);

  select
    count(1) into v_is_valid
  from
    cr_type_relations
  where
    content_item__is_subclass( v_object_type, target_type ) = 't'
  and
    content_item__is_subclass( v_content_type, content_type ) = 't';

  if v_is_valid = 0 then
    raise EXCEPTION '-20000: There is no registered relation type matching this item relation.';
  end if;

  if relate__item_id != relate__object_id then
    -- check that these two items are not related already
    --dbms_output.put_line( 'checking if the items are already related...');
    
    select
      rel_id, 1 into v_rel_id, v_exists
    from
      cr_item_rels
    where
      item_id = relate__item_id
    and
      related_object_id = relate__object_id
    and
      relation_tag = relate__relation_tag;

    if NOT FOUND then
       v_exists := 0;
    end if;
    
    -- if order_n is null, use rel_id (the order the item was related)
    if relate__order_n is null then
      v_order_n := v_rel_id;
    else
      v_order_n := relate__order_n;
    end if;


    -- if relationship does not exist, create it
    if v_exists <> 1 then
      --dbms_output.put_line( 'creating new relationship...');
      v_rel_id := acs_object__new(
        null,
        relate__relation_type,
        now(),
        null,
        null,
        relate__item_id
      );
      insert into cr_item_rels (
        rel_id, item_id, related_object_id, order_n, relation_tag
      ) values (
        v_rel_id, relate__item_id, relate__object_id, v_order_n, 
        relate__relation_tag
      );

    -- if relationship already exists, update it
    else
      --dbms_output.put_line( 'updating existing relationship...');
      update cr_item_rels set
        relation_tag = relate__relation_tag,
        order_n = v_order_n
      where
        rel_id = v_rel_id;
    end if;

  end if;

  return v_rel_id;
 
end;$_$;


--
-- Name: content_item__rename(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__rename(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  rename__item_id                alias for $1;  
  rename__name                   alias for $2;  
  exists_id                      integer;       
begin
  select
    item_id
  into 
    exists_id
  from 
    cr_items
  where
    name = rename__name
  and 
    parent_id = (select 
	           parent_id
		 from
		   cr_items
		 where
		   item_id = rename__item_id);
  if NOT FOUND then
    update cr_items
      set name = rename__name
      where item_id = rename__item_id;
  else
    if exists_id != rename__item_id then
      raise EXCEPTION '-20000: An item with the name % already exists in this directory.', rename__name;
    end if;
  end if;

  return 0; 
end;$_$;


--
-- Name: content_item__set_live_revision(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__set_live_revision(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_live_revision__revision_id    alias for $1;  
  set_live_revision__publish_status cr_items.publish_status%TYPE default 'ready';
begin

  update
    cr_items
  set
    live_revision = set_live_revision__revision_id,
    publish_status = set_live_revision__publish_status
  where
    item_id = (select
                 item_id
               from
                 cr_revisions
               where
                 revision_id = set_live_revision__revision_id);

  update
    cr_revisions
  set
    publish_date = now()
  where
    revision_id = set_live_revision__revision_id;

  return 0; 
end;$_$;


--
-- Name: content_item__set_live_revision(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__set_live_revision(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_live_revision__revision_id    alias for $1;  
  set_live_revision__publish_status alias for $2; -- default 'ready'
begin

  update
    cr_items
  set
    live_revision = set_live_revision__revision_id,
    publish_status = set_live_revision__publish_status
  where
    item_id = (select
                 item_id
               from
                 cr_revisions
               where
                 revision_id = set_live_revision__revision_id);

  update
    cr_revisions
  set
    publish_date = now()
  where
    revision_id = set_live_revision__revision_id;

  return 0; 
end;$_$;


--
-- Name: content_item__set_release_period(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__set_release_period(integer, timestamp with time zone, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_release_period__item_id                alias for $1;  
  set_release_period__start_when             alias for $2;  -- default null
  set_release_period__end_when               alias for $3;  -- default null
  v_count                                    integer;       
begin

  select count(*) into v_count from cr_release_periods 
    where item_id = set_release_period__item_id;

  if v_count = 0 then
    insert into cr_release_periods (
      item_id, start_when, end_when
    ) values (
      set_release_period__item_id, 
      set_release_period__start_when, 
      set_release_period__end_when
    );
  else
    update cr_release_periods
      set start_when = set_release_period__start_when,
      end_when = set_release_period__end_when
    where
      item_id = set_release_period__item_id;
  end if;

  return 0; 
end;$_$;


--
-- Name: content_item__unregister_template(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__unregister_template(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unregister_template__item_id                alias for $1;  
  unregister_template__template_id            alias for $2;  -- default null  
  unregister_template__use_context            alias for $3;  -- default null
                                        
begin

  if unregister_template__use_context is null and 
     unregister_template__template_id is null then

    delete from cr_item_template_map
      where item_id = unregister_template__item_id;

  else if unregister_template__use_context is null then

    delete from cr_item_template_map
      where template_id = unregister_template__template_id
      and item_id = unregister_template__item_id;

  else if unregister_template__template_id is null then

    delete from cr_item_template_map
      where item_id = unregister_template__item_id
      and use_context = unregister_template__use_context;

  else

    delete from cr_item_template_map
      where template_id = unregister_template__template_id
      and item_id = unregister_template__item_id
      and use_context = unregister_template__use_context;

  end if; end if; end if;

  return 0; 
end;$_$;


--
-- Name: content_item__unrelate(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__unrelate(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unrelate__rel_id      alias for $1;  
begin

  -- delete the relation object
  PERFORM acs_rel__delete(unrelate__rel_id);

  -- delete the row from the cr_item_rels table
  delete from cr_item_rels where rel_id = unrelate__rel_id;

  return 0; 
end;$_$;


--
-- Name: content_item__unset_live_revision(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__unset_live_revision(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unset_live_revision__item_id                alias for $1;  
begin

  update
    cr_items
  set
    live_revision = NULL
  where
    item_id = unset_live_revision__item_id;

  -- if an items publish status is "live", change it to "ready"
  update
    cr_items
  set
    publish_status = 'production'
  where
    publish_status = 'live'
  and
    item_id = unset_live_revision__item_id;

  return 0; 
end;$_$;


--
-- Name: content_item__write_to_file(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item__write_to_file(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  item_id                alias for $1;  
  root_path              alias for $2;  
  -- blob_loc               cr_revisions.content%TYPE;
  -- v_revision             cr_items.live_revision%TYPE;
begin
  
  -- FIXME:
  raise NOTICE 'not implemented for postgresql';
/*
  v_revision := content_item__get_live_revision(item_id);

  select content into blob_loc from cr_revisions 
    where revision_id = v_revision;

  if NOT FOUND then 
    raise EXCEPTION '-20000: No live revision for content item % in content_item.write_to_file.', item_id;    
  end if;
  
  PERFORM blob_to_file(root_path || content_item__get_path(item_id), blob_loc);
*/
  return 0; 
end;$_$;


--
-- Name: content_item_search__utrg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_item_search__utrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if new.live_revision is not null and coalesce(old.live_revision,0) <> new.live_revision then
	perform search_observer__enqueue(new.live_revision,'INSERT');		
    end if;

    if old.live_revision is not null and old.live_revision <> coalesce(new.live_revision,0) then
	perform search_observer__enqueue(old.live_revision,'DELETE');
    end if;

    return new;
end;$$;


--
-- Name: content_keyword__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__keyword_id             alias for $1;  
  v_rec                          record; 
begin

  for v_rec in select item_id from cr_item_keyword_map 
    where keyword_id = delete__keyword_id LOOP
    PERFORM content_keyword__item_unassign(v_rec.item_id, delete__keyword_id);
  end LOOP;

  PERFORM acs_object__delete(delete__keyword_id);

  return 0; 
end;$_$;


--
-- Name: content_keyword__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__keyword_id             alias for $1;  
  v_rec                          record; 
begin
  perform content_keyword__del(delete__keyword_id);
  return 0; 
end;$_$;


--
-- Name: content_keyword__get_description(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__get_description(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
  get_description__keyword_id             alias for $1;  
  v_description                           text; 
begin

  select description into v_description from cr_keywords
    where keyword_id = get_description__keyword_id;

  return v_description;
 
end;$_$;


--
-- Name: content_keyword__get_heading(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__get_heading(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
  get_heading__keyword_id             alias for $1;  
  v_heading                           text; 
begin

  select heading into v_heading from cr_keywords
    where keyword_id = get_heading__keyword_id;

  return v_heading;
 
end;$_$;


--
-- Name: content_keyword__get_path(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__get_path(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
  get_path__keyword_id             alias for $1;  
  v_path                          text default '';
  v_is_found                      boolean default 'f';   
  v_heading                       cr_keywords.heading%TYPE;
  v_rec                           record;
begin
--               select
--                 heading 
--               from (
--                  select 
--                    heading, level as tree_level
--                  from cr_keywords
--                    connect by prior parent_id = keyword_id
--                    start with keyword_id = get_path.keyword_id) k 
--                order by 
--                  tree_level desc 

  for v_rec in select heading 
               from (select k2.heading, tree_level(k2.tree_sortkey) as tree_level
                     from cr_keywords k1, cr_keywords k2
                     where k1.keyword_id = get_path__keyword_id
                       and k1.tree_sortkey between k2.tree_sortkey and tree_right(k2.tree_sortkey)) k
                order by tree_level desc 
  LOOP
      v_heading := v_rec.heading;
      v_is_found := 't';
      v_path := v_path || '/' || v_heading;
  end LOOP;

  if v_is_found = 'f' then
    return null;
  else
    return v_path;
  end if;
 
end;$_$;


--
-- Name: content_keyword__is_assigned(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__is_assigned(integer, integer, character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  is_assigned__item_id                alias for $1;  
  is_assigned__keyword_id             alias for $2;  
  is_assigned__recurse                alias for $3;  -- default 'none'  
  v_ret                               boolean;    
  v_is_assigned__recurse	      varchar;
begin
  if is_assigned__recurse is null then 
	v_is_assigned__recurse := 'none';
  else
      	v_is_assigned__recurse := is_assigned__recurse;	
  end if;

  -- Look for an exact match
  if v_is_assigned__recurse = 'none' then
      return count(*) > 0 from cr_item_keyword_map
       where item_id = is_assigned__item_id
         and keyword_id = is_assigned__keyword_id;
  end if;

  -- Look from specific to general
  if v_is_assigned__recurse = 'up' then
      return count(*) > 0
      where exists (select 1
                    from (select keyword_id from cr_keywords c, cr_keywords c2
	                  where c2.keyword_id = is_assigned__keyword_id
                            and c.tree_sortkey between c2.tree_sortkey and tree_right(c2.tree_sortkey)) t,
                      cr_item_keyword_map m
                    where t.keyword_id = m.keyword_id
                      and m.item_id = is_assigned__item_id);
  end if;

  if v_is_assigned__recurse = 'down' then
      return count(*) > 0
      where exists (select 1
                    from (select k2.keyword_id
                          from cr_keywords k1, cr_keywords k2
                          where k1.keyword_id = is_assigned__keyword_id
                            and k1.tree_sortkey between k2.tree_sortkey and tree_right(k2.tree_sortkey)) t, 
                      cr_item_keyword_map m
                    where t.keyword_id = m.keyword_id
                      and m.item_id = is_assigned__item_id);

  end if;  

  -- Tried none, up and down - must be an invalid parameter
  raise EXCEPTION '-20000: The recurse parameter to content_keyword.is_assigned should be \'none\', \'up\' or \'down\'';
  
  return null;
end;$_$;


--
-- Name: content_keyword__is_leaf(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__is_leaf(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_leaf__keyword_id             alias for $1;  
begin

  return 
      count(*) = 0
  from 
    cr_keywords k
  where
    k.parent_id = is_leaf__keyword_id;
 
end;$_$;


--
-- Name: content_keyword__item_assign(integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__item_assign(integer, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  item_assign__item_id                alias for $1;  
  item_assign__keyword_id             alias for $2;  
  item_assign__context_id             alias for $3;  -- default null  
  item_assign__creation_user          alias for $4;  -- default null
  item_assign__creation_ip            alias for $5;  -- default null
  exists_p                            boolean;
begin
  
  -- Do nothing if the keyword is assigned already
  select count(*) > 0 into exists_p from dual 
    where exists (select 1 from cr_item_keyword_map
                   where item_id = item_assign__item_id 
                   and keyword_id = item_assign__keyword_id);

  if NOT exists_p then

    insert into cr_item_keyword_map (
      item_id, keyword_id
    ) values (
      item_assign__item_id, item_assign__keyword_id
    );
  end if;

  return 0; 
end;$_$;


--
-- Name: content_keyword__item_unassign(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__item_unassign(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  item_unassign__item_id                alias for $1;  
  item_unassign__keyword_id             alias for $2;  
begin

  delete from cr_item_keyword_map
    where item_id = item_unassign__item_id 
    and keyword_id = item_unassign__keyword_id;

  return 0; 
end;$_$;


--
-- Name: content_keyword__new(character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__new(character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__heading                alias for $1;  
  new__description            alias for $2;  -- default null  
  new__parent_id              alias for $3;  -- default null
  new__keyword_id             alias for $4;  -- default null
  new__creation_date          alias for $5;  -- default now()
  new__creation_user          alias for $6;  -- default null
  new__creation_ip            alias for $7;  -- default null
  new__object_type            alias for $8;  -- default 'content_keyword'
begin
  return content_keyword__new(new__heading,
                              new__description,
                              new__parent_id,
                              new__keyword_id,
                              new__creation_date,
                              new__creation_user,
                              new__creation_ip,
                              new__object_type,
                              null
  );

end;$_$;


--
-- Name: content_keyword__new(character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__new(character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__heading                alias for $1;  
  new__description            alias for $2;  -- default null  
  new__parent_id              alias for $3;  -- default null
  new__keyword_id             alias for $4;  -- default null
  new__creation_date          alias for $5;  -- default now()
  new__creation_user          alias for $6;  -- default null
  new__creation_ip            alias for $7;  -- default null
  new__object_type            alias for $8;  -- default 'content_keyword'
  new__package_id             alias for $9;  -- default null
  v_id                        integer;       
  v_package_id                acs_objects.package_id%TYPE;
begin

  if new__package_id is null then
    v_package_id := acs_object__package_id(new__parent_id);
  else
    v_package_id := new__package_id;
  end if;

  v_id := acs_object__new (new__keyword_id,
                           new__object_type,
                           new__creation_date, 
                           new__creation_user, 
                           new__creation_ip,
                           new__parent_id,
                           't',
                           new__heading,
                           v_package_id
  );
    
  insert into cr_keywords 
    (heading, description, keyword_id, parent_id)
  values
    (new__heading, new__description, v_id, new__parent_id);

  return v_id;
 
end;$_$;


--
-- Name: content_keyword__set_description(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__set_description(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_description__keyword_id             alias for $1;  
  set_description__description            alias for $2;  
begin

  update cr_keywords set 
    description = set_description__description
  where
    keyword_id = set_description__keyword_id;

  return 0; 
end;$_$;


--
-- Name: content_keyword__set_heading(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_keyword__set_heading(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_heading__keyword_id             alias for $1;  
  set_heading__heading                alias for $2;  
begin

  update cr_keywords set 
    heading = set_heading__heading
  where
    keyword_id = set_heading__keyword_id;

  return 0; 
end;$_$;


--
-- Name: content_revision__content_copy(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__content_copy(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  content_copy__revision_id            alias for $1;  
  content_copy__revision_id_dest       alias for $2;  -- default null  
  v_item_id                            cr_items.item_id%TYPE;
  v_content_length                     cr_revisions.content_length%TYPE;
  v_revision_id_dest                   cr_revisions.revision_id%TYPE;
  v_content                            cr_revisions.content%TYPE;
  v_lob                                cr_revisions.lob%TYPE;
  v_new_lob                            cr_revisions.lob%TYPE;
  v_storage_type                       varchar;
begin
  if content_copy__revision_id is null then 
	raise exception 'content_revision__content_copy attempt to copy a null revision_id';
  end if;

  select
    content_length, item_id
  into
    v_content_length, v_item_id
  from
    cr_revisions
  where
    revision_id = content_copy__revision_id;

  -- get the destination revision
  if content_copy__revision_id_dest is null then
    select
      latest_revision into v_revision_id_dest
    from
      cr_items
    where
      item_id = v_item_id;
  else
    v_revision_id_dest := content_copy__revision_id_dest;
  end if;


  -- only copy the content if the source content is not null
  if v_content_length is not null and v_content_length > 0 then

    /* The internal LOB types - BLOB, CLOB, and NCLOB - use copy semantics, as 
       opposed to the reference semantics which apply to BFILEs.
       When a BLOB, CLOB, or NCLOB is copied from one row to another row in 
       the same table or in a different table, the actual LOB value is
       copied, not just the LOB locator. */

    select r.content, r.content_length, r.lob, i.storage_type 
      into v_content, v_content_length, v_lob, v_storage_type
      from cr_revisions r, cr_items i 
     where r.item_id = i.item_id 
       and r.revision_id = content_copy__revision_id;

    if v_storage_type = 'lob' then
        v_new_lob := empty_lob();

        update cr_revisions
           set content = null,
               content_length = v_content_length,
               lob = v_new_lob
         where revision_id = v_revision_id_dest;
        PERFORM lob_copy(v_lob, v_new_lob);
    else 
        -- this will work for both file and text types... well sort of.
        -- this really just creates a reference to the first file which is
        -- wrong since, the item_id, revision_id uniquely describes the 
        -- location of the file in the content repository file system.  
        -- after copy is called, the content attribute needs to be updated 
        -- with the new relative file path:

        -- update cr_revisions
        -- set content = '[cr_create_content_file $item_id $revision_id [cr_fs_path]$old_rel_path]'
        -- where revision_id = :revision_id
        
        -- old_rel_path is the content attribute value of the content revision
        -- that is being copied.
        update cr_revisions
           set content = v_content,
               content_length = v_content_length,
               lob = null
         where revision_id = v_revision_id_dest;
    end if;

  end if;

  return 0; 
end;$_$;


--
-- Name: content_revision__copy(integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__copy(integer, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  copy__revision_id            alias for $1;  
  copy__copy_id                alias for $2;  -- default null  
  copy__target_item_id         alias for $3;  -- default null
  copy__creation_user          alias for $4;  -- default null
  copy__creation_ip            alias for $5;  -- default null
  v_copy_id                    cr_revisions.revision_id%TYPE;
  v_target_item_id             cr_items.item_id%TYPE;
  type_rec                     record;
begin
  -- use the specified item_id or the item_id of the original revision 
  --   if none is specified
  if copy__target_item_id is null then
    select item_id into v_target_item_id from cr_revisions 
      where revision_id = copy__revision_id;
  else
    v_target_item_id := copy__target_item_id;
  end if;

  -- use the copy_id or generate a new copy_id if none is specified
  --   the copy_id is a revision_id
  if copy__copy_id is null then
    select acs_object_id_seq.nextval into v_copy_id from dual;
  else
    v_copy_id := copy__copy_id;
  end if;

  -- create the basic object
  insert into acs_objects (
                 object_id,
                 object_type,
                 context_id,
                 security_inherit_p,
                 creation_user,
                 creation_date,
                 creation_ip,
                 last_modified,
                 modifying_user,
                 modifying_ip,
                 title,
                 package_id)
       select
         v_copy_id as object_id,
         object_type,
         v_target_item_id,
         security_inherit_p,
         copy__creation_user as creation_user,
         now() as creation_date,
         copy__creation_ip as creation_ip,
         now() as last_modified,
         copy__creation_user as modifying_user,
         copy__creation_ip as modifying_ip,
         title,
         package_id
       from
         acs_objects
       where
         object_id = copy__revision_id;

  -- create the basic revision (using v_target_item_id)
  insert into cr_revisions 
      select 
        v_copy_id as revision_id, 
        v_target_item_id as item_id, 
        title, 
        description, 
        publish_date, 
        mime_type, 
        nls_language, 
        lob,
	content,
        content_length
      from 
        cr_revisions 
      where
        revision_id = copy__revision_id;

  -- iterate over the ancestor types and copy attributes
  for type_rec in select ot2.object_type, tree_level(ot2.tree_sortkey) as level
                  from acs_object_types ot1, acs_object_types ot2, acs_objects o
                  where ot2.object_type <> 'acs_object'                       
                    and ot2.object_type <> 'content_revision'
                    and o.object_id = copy__revision_id 
                    and ot1.object_type = o.object_type 
                    and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
                  order by level desc
  LOOP
    PERFORM content_revision__copy_attributes(type_rec.object_type, 
                                              copy__revision_id, v_copy_id);
  end loop;

  return v_copy_id;
 
end;$_$;


--
-- Name: content_revision__copy_attributes(character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__copy_attributes(character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  copy_attributes__content_type           alias for $1;  
  copy_attributes__revision_id            alias for $2;  
  copy_attributes__copy_id                alias for $3;  
  v_table_name                            acs_object_types.table_name%TYPE;
  v_id_column                             acs_object_types.id_column%TYPE;
  cols                                    varchar default ''; 
  attr_rec                                record;
begin

  if copy_attributes__content_type is null or copy_attributes__revision_id is null or copy_attributes__copy_id is null then 
     raise exception 'content_revision__copy_attributes called with null % % %',copy_attributes__content_type,copy_attributes__revision_id, copy_attributes__copy_id;
  end if;

  select table_name, id_column into v_table_name, v_id_column
  from acs_object_types where object_type = copy_attributes__content_type;

  for attr_rec in select
                    attribute_name
                  from
                    acs_attributes
                  where
                    object_type = copy_attributes__content_type 
  LOOP
    cols := cols || ', ' || attr_rec.attribute_name;
  end loop;

    execute 'insert into ' || v_table_name || '(' || v_id_column || cols || ')' || ' select ' || copy_attributes__copy_id || 
          ' as ' || v_id_column || cols || ' from ' || 
          v_table_name || ' where ' || v_id_column || ' = ' || 
          copy_attributes__revision_id;

  return 0; 

end;$_$;


--
-- Name: content_revision__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__revision_id    alias for $1;  
  v_item_id              cr_items.item_id%TYPE;
  v_latest_revision      cr_revisions.revision_id%TYPE;
  v_live_revision        cr_revisions.revision_id%TYPE;
  v_rec                  record;                                      
begin

  -- Get item id and latest/live revisions
  select item_id into v_item_id from cr_revisions 
    where revision_id = delete__revision_id;

  select 
    latest_revision, live_revision
  into 
    v_latest_revision, v_live_revision
  from 
    cr_items
  where 
    item_id = v_item_id;

  -- Recalculate latest revision
  if v_latest_revision = delete__revision_id then
      for v_rec in 
          select r.revision_id
            from cr_revisions r, acs_objects o
           where o.object_id = r.revision_id
             and r.item_id = v_item_id
             and r.revision_id <> delete__revision_id
        order by o.creation_date desc 
      LOOP

          v_latest_revision := v_rec.revision_id;
          exit;
      end LOOP;
      if NOT FOUND then
         v_latest_revision := null;        
      end if;
      
      update cr_items set latest_revision = v_latest_revision
      where item_id = v_item_id;    
  end if; 
 
  -- Clear live revision
  if v_live_revision = delete__revision_id then
    update cr_items set live_revision = null
      where item_id = v_item_id;   
  end if; 

  -- Clear the audit
  delete from cr_item_publish_audit
    where old_revision = delete__revision_id
       or new_revision = delete__revision_id;

  -- Delete the revision
  PERFORM acs_object__delete(delete__revision_id);

  return 0; 
end;$_$;


--
-- Name: content_revision__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__revision_id    alias for $1;  
begin
        PERFORM content_revision__del(delete__revision_id);
  return 0; 
end;$_$;


--
-- Name: content_revision__export_xml(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__export_xml(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  revision_id            alias for $1;  
  clob_loc               text;          
  v_doc_id               cr_xml_docs.doc_id%TYPE;
  v_revision_id          cr_revisions.revision_id%TYPE;
begin

  raise exception ' content_revision__export_xml Not currently implemented on postgresql';
 
end;$_$;


--
-- Name: content_revision__get_content(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__get_content(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
  get_content__revision_id            alias for $1;  
  v_storage_type                      varchar;
  v_lob_id                            integer;
  v_data                              text;
begin
       select i.storage_type, r.lob 
         into v_storage_type, v_lob_id
         from cr_items i, cr_revisions r
        where i.item_id = r.item_id 
          and r.revision_id = get_content__revision_id;
        
        if v_storage_type = 'lob' then
           return v_lob_id::text;
        else 
           return content
             from cr_revisions
            where revision_id = get_content__revision_id;
        end if;

end;$_$;


--
-- Name: content_revision__get_number(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__get_number(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  get_number__revision_id            alias for $1;  
  v_revision                         cr_revisions.revision_id%TYPE;
  v_row_count                        integer default 0;
  rev_cur                            record;
begin
  for rev_cur in select
                   revision_id
                 from 
                   cr_revisions r, acs_objects o
                 where
                   item_id = (select item_id from cr_revisions 
                               where revision_id = get_number__revision_id)
                 and
                   o.object_id = r.revision_id
                 order by
                   o.creation_date
  LOOP
    v_row_count := v_row_count + 1;
    if rev_cur.revision_id = get_number__revision_id then 
       return v_row_count;
       exit;
    end if;
  end LOOP;

  return null;
 
end;$_$;


--
-- Name: content_revision__import_xml(integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__import_xml(integer, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  import_xml__item_id                alias for $1;  
  import_xml__revision_id            alias for $2;  
  import_xml__doc_id                 alias for $3;  
  clob_loc                           text;          
  v_revision_id                      cr_revisions.revision_id%TYPE;
begin

	raise exception ' content_revision__import_xml not implemented on postgres';

end;$_$;


--
-- Name: content_revision__index_attributes(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__index_attributes(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  index_attributes__revision_id            alias for $1;  
  clob_loc                                 text;          
  v_revision_id                            cr_revisions.revision_id%TYPE;
begin

	raise exception 'content_revision__index_attributes not implemented on postgres';

end;$_$;


--
-- Name: content_revision__is_latest(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__is_latest(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_latest__revision_id            alias for $1;  
begin

  return count(*) > 0 from cr_items
    where latest_revision = is_latest__revision_id;
 
end;$_$;


--
-- Name: content_revision__is_live(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__is_live(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_live__revision_id            alias for $1;  
begin

  return count(*) > 0 from cr_items
   where live_revision = is_live__revision_id;

end;$_$;


--
-- Name: content_revision__new(character varying, character varying, timestamp with time zone, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__new(character varying, character varying, timestamp with time zone, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__title                  alias for $1;  
  new__description            alias for $2;  -- default null 
  new__publish_date           alias for $3;  -- default now()
  new__mime_type              alias for $4;  -- default 'text/plain'
  new__nls_language           alias for $5;  -- default null
  -- lob id 
  new__data                   alias for $6;  
  new__item_id                alias for $7;  
  new__revision_id            alias for $8;  -- default null
  new__creation_date          alias for $9;  -- default now()
  new__creation_user          alias for $10; -- default null
  new__creation_ip            alias for $11; -- default null
  v_revision_id               integer;       
  v_content_type              acs_object_types.object_type%TYPE;
begin

  v_content_type := content_item__get_content_type(new__item_id);

  v_revision_id := acs_object__new(
      new__revision_id,
      v_content_type, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      new__item_id
  );

  -- binary data is stored in cr_revisions using Dons lob hack.
  -- This routine only inserts the lob id.  It would need to be followed by 
  -- ns_pg blob_dml from within a tcl script to actually insert the lob data.

  -- After the lob data is inserted, the content_length needs to be updated 
  -- as well.
  -- DanW, 2001-05-10.

  insert into cr_revisions (
    revision_id, title, description, mime_type, publish_date,
    nls_language, lob, item_id, content_length
  ) values (
    v_revision_id, new__title, new__description,
    new__mime_type, 
    new__publish_date, new__nls_language, new__data, 
    new__item_id, 0
  );

  return v_revision_id;

end;$_$;


--
-- Name: content_revision__new(character varying, character varying, timestamp with time zone, character varying, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__new(character varying, character varying, timestamp with time zone, character varying, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        new__title              alias for $1;
        new__description        alias for $2;  -- default null
        new__publish_date       alias for $3;  -- default now()
        new__mime_type          alias for $4;  -- default 'text/plain'
        new__text               alias for $5;  -- default ' '
        new__item_id            alias for $6;
begin
        return content_revision__new(new__title,
                                     new__description,
                                     new__publish_date,
                                     new__mime_type,
                                     null,
                                     new__text,
                                     new__item_id,
                                     null,
                                     now(),
                                     null,
                                     null
               );

end;$_$;


--
-- Name: content_revision__new(character varying, character varying, timestamp with time zone, character varying, character varying, text, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__new(character varying, character varying, timestamp with time zone, character varying, character varying, text, integer, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__title                  alias for $1;  
  new__description            alias for $2;  -- default null  
  new__publish_date           alias for $3;  -- default now()
  new__mime_type              alias for $4;  -- default 'text/plain'
  new__nls_language           alias for $5;  -- default null
  new__text                   alias for $6;  -- default ' '
  new__item_id                alias for $7;  
  new__revision_id            alias for $8;  -- default null
  new__creation_date          alias for $9;  -- default now()
  new__creation_user          alias for $10; -- default null
  new__creation_ip            alias for $11; -- default null
begin
        return content_revision__new(new__title,
                                     new__description,
                                     new__publish_date,
                                     new__mime_type,
                                     new__nls_language,
                                     new__text,
                                     new__item_id,
                                     new__revision_id,
                                     new__creation_date,
                                     new__creation_user,
                                     new__creation_ip,
                                     null
                                     );
end;$_$;


--
-- Name: content_revision__new(character varying, character varying, timestamp with time zone, character varying, character varying, text, integer, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__new(character varying, character varying, timestamp with time zone, character varying, character varying, text, integer, integer, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__title                  alias for $1;  
  new__description            alias for $2;  -- default null  
  new__publish_date           alias for $3;  -- default now()
  new__mime_type              alias for $4;  -- default 'text/plain'
  new__nls_language           alias for $5;  -- default null
  new__text                   alias for $6;  -- default ' '
  new__item_id                alias for $7;  
  new__revision_id            alias for $8;  -- default null
  new__creation_date          alias for $9;  -- default now()
  new__creation_user          alias for $10; -- default null
  new__creation_ip            alias for $11; -- default null
  new__content_length         alias for $12; -- default null
  v_revision_id               integer;       
  v_content_type              acs_object_types.object_type%TYPE;
  v_storage_type              cr_items.storage_type%TYPE;
  v_length                    cr_revisions.content_length%TYPE;
begin

  v_content_type := content_item__get_content_type(new__item_id);

  v_revision_id := acs_object__new(
      new__revision_id,
      v_content_type, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      new__item_id
  );

  select storage_type into v_storage_type
    from cr_items
   where item_id = new__item_id;

  if v_storage_type = 'text' then 
     v_length := length(new__text);
  else
     v_length := coalesce(new__content_length,0);
  end if;

  -- text data is stored directly in cr_revisions using text datatype.

  insert into cr_revisions (
    revision_id, title, description, mime_type, publish_date,
    nls_language, content, item_id, content_length
  ) values (
    v_revision_id, new__title, new__description,
     new__mime_type, 
    new__publish_date, new__nls_language, 
    new__text, new__item_id, v_length
  );

  return v_revision_id;
 
end;$_$;


--
-- Name: content_revision__revision_name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__revision_name(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
        p_revision_id   alias for $1;
begin
        return 'Revision ' || content_revision__get_number(revision_id) || 
               ' of ' || (select count(*) from cr_revisions where item_id = r.item_id) || ' for item: ' 
               || content_item__get_title(item_id)
               from cr_revisions r where r.revision_id = p_revision_id;
end;$_$;


--
-- Name: content_revision__to_html(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__to_html(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  to_html__revision_id            alias for $1;  
  tmp_clob                        text;          
  blob_loc                        integer;          
begin

  -- FIXME
  -- ctx_doc.filter('cr_doc_filter_index', revision_id, tmp_clob);

  select 
    content into blob_loc
  from 
    cr_revisions 
  where 
    revision_id = to_html__revision_id
  for update;

 PERFORM clob_to_blob(tmp_clob, blob_loc);

 PERFORM dbms_lob__freetemporary(tmp_clob);

 return 0; 
end;$_$;


--
-- Name: content_revision__to_temporary_clob(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_revision__to_temporary_clob(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  to_temporary_clob__revision_id            alias for $1;  
  -- b                                         blob;          
  -- c                                         text;          
begin
  -- FIXME:  I cannot find an instance in the 4.2 beta code where this
  --         is used so I am not worrying about porting it for now.
  --         DCW - 2001-03-28.

  raise EXCEPTION 'not implemented content_revision.to_temporary_clob';
/*
  insert into cr_content_text (
    revision_id, content
  ) values (
    revision_id, empty_clob()
  ) returning content into c;

  select content into b from cr_revisions 
    where revision_id = to_temporary_clob__revision_id;

  PERFORM blob_to_clob(b, c);
*/
  return 0; 
end;$_$;


--
-- Name: content_search__dtrg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_search__dtrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
     v_live_revision integer;
begin
    select into v_live_revision live_revision from
        cr_items where item_id=old.item_id;
    if old.revision_id=v_live_revision then
        perform search_observer__enqueue(old.revision_id,'DELETE');
    end if;
    return old;
end;$$;


--
-- Name: content_search__itrg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_search__itrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
if (select live_revision from cr_items where item_id=new.item_id) = new.revision_id then	
	perform search_observer__enqueue(new.revision_id,'INSERT');
    end if;
    return new;
end;$$;


--
-- Name: content_search__utrg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_search__utrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
    v_live_revision integer;
begin
    select into v_live_revision live_revision from
	cr_items where item_id=old.revision_id;
    if old.revision_id=v_live_revision then
	insert into search_observer_queue (
            object_id,
	    event
        ) values (
old.revision_id,
            'UPDATE'
        );
    end if;
    return new;
end;$$;


--
-- Name: content_symlink__copy(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_symlink__copy(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  copy__symlink_id             alias for $1;  
  copy__target_folder_id       alias for $2;  
  copy__creation_user          alias for $3;  
  copy__creation_ip            alias for $4;  -- default null  
  v_current_folder_id          cr_folders.folder_id%TYPE;
  v_name                       cr_items.name%TYPE;
  v_target_id                  cr_items.item_id%TYPE;
  v_label                      cr_symlinks.label%TYPE;
  v_symlink_id                 cr_symlinks.symlink_id%TYPE;
begin

  if content_folder__is_folder(copy__target_folder_id) = 't' then
    select
      parent_id
    into
      v_current_folder_id
    from
      cr_items
    where
      item_id = copy__symlink_id;

    -- can't copy to the same folder
    if copy__target_folder_id != v_current_folder_id then

      select
        i.name, content_symlink__resolve(i.item_id), s.label
      into
        v_name, v_target_id, v_label
      from
        cr_symlinks s, cr_items i
      where
        s.symlink_id = i.item_id
      and
        s.symlink_id = copy__symlink_id;


      if content_folder__is_registered(copy__target_folder_id,
        'content_symlink','f') = 't' then
        if content_folder__is_registered(copy__target_folder_id,
          content_item__get_content_type(content_symlink__resolve(copy__symlink_id)),'f') = 't' then

          v_symlink_id := content_symlink__new(
              v_name,
	      v_label,
              v_target_id,
              copy__target_folder_id,
              null,
              now(),
	      copy__creation_user,
	      copy__creation_ip
          );


	end if;
      end if;
    end if;
  end if;

  return 0; 
end;$_$;


--
-- Name: content_symlink__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_symlink__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  del__symlink_id             alias for $1;  
begin

  delete from cr_symlinks
    where symlink_id = del__symlink_id;

  PERFORM content_item__delete(del__symlink_id);

  return 0; 
end;$_$;


--
-- Name: content_symlink__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_symlink__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__symlink_id             alias for $1;  
begin

  PERFORM content_symlink__del(delete__symlink_id);

  return 0; 
end;$_$;


--
-- Name: content_symlink__is_symlink(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_symlink__is_symlink(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_symlink__item_id                alias for $1;  
  v_symlink_p                        boolean;
begin

  select 
    count(*) = 1 into v_symlink_p
  from 
    cr_symlinks
  where 
    symlink_id = is_symlink__item_id;

  return v_symlink_p;  
 
end;$_$;


--
-- Name: content_symlink__new(character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_symlink__new(character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  -- default null  
  new__label                  alias for $2;  -- default null
  new__target_id              alias for $3;  
  new__parent_id              alias for $4;  
  new__symlink_id             alias for $5;  -- default null
  new__creation_date          alias for $6;  -- default now()
  new__creation_user          alias for $7;  -- default null
  new__creation_ip            alias for $8;  -- default null
  v_symlink_id                cr_symlinks.symlink_id%TYPE;
  v_name                      cr_items.name%TYPE;
  v_label                     cr_symlinks.label%TYPE;
  v_ctype                     varchar;
begin

  -- SOME CHECKS --

  -- 1) check that the target is now a symlink
  if content_symlink__is_symlink(new__target_id) = 't' then
    raise EXCEPTION '-20000: Cannot create a symlink to a symlink %', new__target_id;
  end if;

  -- 2) check that the parent is a folder
  if content_folder__is_folder(new__parent_id) = 'f' then
    raise EXCEPTION '-20000: The parent is not a folder';
  end if;

  -- 3) check that parent folder supports symlinks
  if content_folder__is_registered(new__parent_id,'content_symlink','f') = 'f' then
    raise EXCEPTION '-20000: This folder does not allow symlinks to be created';
  end if;

  -- 4) check that the content folder supports the target items content type
  if content_folder__is_registered(new__parent_id, content_item__get_content_type(new__target_id), 'f') = 'f' then

    v_ctype := content_item__get_content_type(new__target_id);
    raise EXCEPTION '-20000: This folder does not allow symlinks to items of type % to be created', v_ctype;
  end if;

  -- PASSED ALL CHECKS --

  -- Select default name if the name is null
  if  new__name is null or new__name = '' then
    select 
      'symlink_to_' ||  name into v_name
    from 
      cr_items
    where
       item_id =  new__target_id;
  
    if NOT FOUND then 
       v_name := null;
    end if;
  else
    v_name :=  new__name;
  end if;

  -- Select default label if the label is null
  if new__label is null then
    v_label := 'Symlink to ' || v_name;
  else
    v_label := new__label;
  end if;

  v_symlink_id := content_item__new(
      v_name, 
      new__parent_id,
      new__symlink_id,
      null,
      new__creation_date, 
      new__creation_user, 
      null,
      new__creation_ip, 
      'content_item',
      'content_symlink', 
      null,
      null,
      'text/plain',
      null,
      null,
      'text'
  );

  insert into cr_symlinks
    (symlink_id, target_id, label)
  values
    (v_symlink_id, new__target_id, v_label);

  return v_symlink_id;

end;$_$;


--
-- Name: content_symlink__resolve(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_symlink__resolve(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  resolve__item_id                alias for $1;  
  v_target_id                     cr_items.item_id%TYPE;
begin

  select
    target_id into v_target_id
  from
    cr_symlinks
  where
    symlink_id = resolve__item_id;
  
  if NOT FOUND then
     return resolve__item_id;
  else
     return v_target_id;
  end if;

end;$_$;


--
-- Name: content_symlink__resolve_content_type(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_symlink__resolve_content_type(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  resolve_content_type__item_id                alias for $1;  
  v_content_type                               cr_items.content_type%TYPE;
begin

  select 
    content_item__get_content_type(target_id) into v_content_type
  from
    cr_symlinks
  where
    symlink_id = resolve_content_type__item_id;

  if NOT FOUND then 
     return null;
  end if;

  return v_content_type;
 
end;$_$;


--
-- Name: content_template__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_template__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__template_id            alias for $1;  
begin

  delete from cr_type_template_map
    where template_id = delete__template_id;

  delete from cr_item_template_map
    where template_id = delete__template_id;
 
  delete from cr_templates
    where template_id = delete__template_id;

  PERFORM content_item__delete(delete__template_id);

  return 0; 
end;$_$;


--
-- Name: content_template__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_template__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__template_id            alias for $1;  
begin
  PERFORM content_template__delete(delete__template_id);

  return 0; 
end;$_$;


--
-- Name: content_template__get_path(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_template__get_path(integer, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  template_id            alias for $1;  
  root_folder_id         alias for $2; -- default content_template_globals.c_root_folder_id
                                        
begin

  return content_item__get_path(template_id, root_folder_id);

end;$_$;


--
-- Name: content_template__get_root_folder(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_template__get_root_folder() RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
  return content_template_globals.c_root_folder_id;
end;$$;


--
-- Name: content_template__is_template(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_template__is_template(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_template__template_id            alias for $1;  
begin
  
  return count(*) > 0 from cr_templates
    where template_id = is_template__template_id;
 
end;$_$;


--
-- Name: content_template__new(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_template__new(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        new__name       alias for $1;
begin
        return content_template__new(new__name,
                                     null,
                                     null,
                                     now(),
                                     null,
                                     null
        );

end;$_$;


--
-- Name: content_template__new(character varying, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_template__new(character varying, integer, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__parent_id              alias for $2;  -- default null  
  new__template_id            alias for $3;  -- default null
  new__creation_date          alias for $4;  -- default now()
  new__creation_user          alias for $5;  -- default null
  new__creation_ip            alias for $6;  -- default null
  v_template_id               cr_templates.template_id%TYPE;
  v_parent_id                 cr_items.parent_id%TYPE;
begin

  if new__parent_id is null then
    v_parent_id := content_template_globals.c_root_folder_id;
  else
    v_parent_id := new__parent_id;
  end if;

  -- make sure we're allowed to create a template in this folder
  if content_folder__is_folder(new__parent_id) = 't' and
    content_folder__is_registered(new__parent_id,'content_template','f') = 'f' then

    raise EXCEPTION '-20000: This folder does not allow templates to be created';

  else
    v_template_id := content_item__new (
        new__name, 
        v_parent_id,
        new__template_id,
        null,
        new__creation_date, 
        new__creation_user, 
        null,
        new__creation_ip,
        'content_item',
        'content_template',
        null,
        null,
        'text/plain',
        null,
        null,
        'text'
    );

    insert into cr_templates ( 
      template_id 
    ) values (
      v_template_id
    );

    return v_template_id;

  end if;
 
end;$_$;


--
-- Name: content_template__new(character varying, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_template__new(character varying, text, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        new__name       alias for $1;
        new__text       alias for $2;
        new__is_live    alias for $3;
begin
        return content_template__new(new__name,
                                     null,
                                     null,
                                     now(),
                                     null,
                                     null,
                                     new__text,
                                     new__is_live
        );

end;$_$;


--
-- Name: content_template__new(character varying, integer, integer, timestamp with time zone, integer, character varying, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_template__new(character varying, integer, integer, timestamp with time zone, integer, character varying, text, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__name                   alias for $1;  
  new__parent_id              alias for $2;  -- default null  
  new__template_id            alias for $3;  -- default null
  new__creation_date          alias for $4;  -- default now()
  new__creation_user          alias for $5;  -- default null
  new__creation_ip            alias for $6;  -- default null
  new__text                   alias for $7;  -- default null
  new__is_live                alias for $8;  -- default 'f'
  v_template_id               cr_templates.template_id%TYPE;
  v_parent_id                 cr_items.parent_id%TYPE;
begin

  if new__parent_id is null then
    v_parent_id := content_template_globals.c_root_folder_id;
  else
    v_parent_id := new__parent_id;
  end if;

  -- make sure we're allowed to create a template in this folder
  if content_folder__is_folder(new__parent_id) = 't' and
    content_folder__is_registered(new__parent_id,'content_template','f') = 'f' then

    raise EXCEPTION '-20000: This folder does not allow templates to be created';

  else
    v_template_id := content_item__new (
        new__template_id,     -- new__item_id
        new__name,            -- new__name
        v_parent_id,          -- new__parent_id
        null,                 -- new__title
        new__creation_date,   -- new__creation_date
        new__creation_user,   -- new__creation_user
        null,                 -- new__context_id
        new__creation_ip,     -- new__creation_ip
        new__is_live,         -- new__is_live
        'text/plain',       -- new__mime_type
        new__text,            -- new__text
        'text',             -- new__storage_type
        't',                -- new__security_inherit_p
        'CR_FILES',         -- new__storage_area_key
        'content_item',     -- new__item_subtype
        'content_template'  -- new__content_type
    );

    insert into cr_templates ( 
      template_id 
    ) values (
      v_template_id
    );

    return v_template_id;

  end if;
 
end;$_$;


--
-- Name: content_type__create_attribute(character varying, character varying, character varying, character varying, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__create_attribute(character varying, character varying, character varying, character varying, character varying, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_attribute__content_type           alias for $1;  
  create_attribute__attribute_name         alias for $2;  
  create_attribute__datatype               alias for $3;  
  create_attribute__pretty_name            alias for $4;  
  create_attribute__pretty_plural          alias for $5;  -- default null  
  create_attribute__sort_order             alias for $6;  -- default null
  create_attribute__default_value          alias for $7;  -- default null
  create_attribute__column_spec            alias for $8;  -- default 'text'
  v_attr_id                                acs_attributes.attribute_id%TYPE;
  v_table_name                             acs_object_types.table_name%TYPE;
  v_column_exists                          boolean;       
begin

 -- add the appropriate column to the table
 
 select table_name into v_table_name from acs_object_types
  where object_type = create_attribute__content_type;

 if NOT FOUND then
   raise EXCEPTION '-20000: Content type % does not exist in content_type.create_attribute', create_attribute__content_type;
 end if; 

 select count(*) > 0 into v_column_exists 
   from pg_class c, pg_attribute a
  where c.relname::varchar = v_table_name
    and c.oid = a.attrelid
    and a.attname = lower(create_attribute__attribute_name);

 if NOT v_column_exists then
   execute 'alter table ' || v_table_name || ' add ' || 
      create_attribute__attribute_name || ' ' 
      || create_attribute__column_spec;
 end if;

 v_attr_id := acs_attribute__create_attribute (
   create_attribute__content_type,
   create_attribute__attribute_name,
   create_attribute__datatype,
   create_attribute__pretty_name,
   create_attribute__pretty_plural,
   null,
   null,
   create_attribute__default_value,
   1,
   1,
   create_attribute__sort_order,
   'type_specific',
   'f'
 );

 PERFORM content_type__refresh_view(create_attribute__content_type);

 return v_attr_id;

end;$_$;


--
-- Name: content_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_type__content_type           alias for $1;  
  create_type__supertype              alias for $2;  -- default 'content_revision'  
  create_type__pretty_name            alias for $3;  
  create_type__pretty_plural          alias for $4;  
  create_type__table_name             alias for $5;  -- default null  
  create_type__id_column              alias for $6;  -- default 'XXX'
  create_type__name_method            alias for $7;  -- default null
  table_exists                        boolean;       
  v_supertype_table                   acs_object_types.table_name%TYPE;
                                        
begin

 -- create the attribute table if not already created

  select count(*) > 0 into table_exists 
    from pg_class
   where relname = lower(create_type__table_name);

  if NOT table_exists then
    select table_name into v_supertype_table from acs_object_types
      where object_type = create_type__supertype;

    execute 'create table ' || create_type__table_name || ' (' ||
      create_type__id_column  || ' integer primary key references ' || 
      v_supertype_table || ')';
  end if;

  PERFORM acs_object_type__create_type (
    create_type__content_type,
    create_type__pretty_name,
    create_type__pretty_plural,
    create_type__supertype,
    create_type__table_name,
    create_type__id_column,
    null,
    'f',
    null,
    create_type__name_method
  );

  PERFORM content_type__refresh_view(create_type__content_type);

  return 0; 
end;$_$;


--
-- Name: content_type__drop_attribute(character varying, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__drop_attribute(character varying, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_attribute__content_type           alias for $1;  
  drop_attribute__attribute_name         alias for $2;  
  drop_attribute__drop_column            alias for $3;  -- default 'f'  
  v_attr_id                              acs_attributes.attribute_id%TYPE;
  v_table                                acs_object_types.table_name%TYPE;
begin

  -- Get attribute information 
  select 
    upper(t.table_name), a.attribute_id 
  into 
    v_table, v_attr_id
  from 
    acs_object_types t, acs_attributes a
  where 
    t.object_type = drop_attribute__content_type
  and 
    a.object_type = drop_attribute__content_type
  and
    a.attribute_name = drop_attribute__attribute_name;
    
  if NOT FOUND then
    raise EXCEPTION '-20000: Attribute %:% does not exist in content_type.drop_attribute', drop_attribute__content_type, drop_attribute__attribute_name;
  end if;

  -- Drop the attribute
  PERFORM acs_attribute__drop_attribute(drop_attribute__content_type, 
                                        drop_attribute__attribute_name);

  -- Drop the column if neccessary
  if drop_attribute__drop_column then
      execute 'alter table ' || v_table || ' drop column ' ||
	drop_attribute__attribute_name || ' cascade';

--    exception when others then
--      raise_application_error(-20000, 'Unable to drop column ' || 
--       v_table || '.' || attribute_name || ' in content_type.drop_attribute');  
  end if;  

  PERFORM content_type__refresh_view(drop_attribute__content_type);

  return 0; 
end;$_$;


--
-- Name: content_type__drop_type(character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__drop_type(character varying, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_type__content_type           alias for $1;  
  drop_type__drop_children_p        alias for $2;  -- default 'f'  
  drop_type__drop_table_p           alias for $3;  -- default 'f'
  table_exists_p                      boolean;       
  v_table_name                      varchar;   
  is_subclassed_p                   boolean;      
  child_rec                         record;    
  attr_row                          record;
begin

  -- first we'll rid ourselves of any dependent child types, if any , 
  -- along with their own dependent grandchild types

  select 
    count(*) > 0 into is_subclassed_p 
  from 
    acs_object_types 
  where supertype = drop_type__content_type;

  -- this is weak and will probably break;
  -- to remove grand child types, the process will probably
  -- require some sort of querying for drop_type 
  -- methods within the children's packages to make
  -- certain there are no additional unanticipated
  -- restraints preventing a clean drop

  if drop_type__drop_children_p and is_subclassed_p then

    for child_rec in select 
                       object_type
                     from 
                       acs_object_types
                     where
                       supertype = drop_type__content_type 
    LOOP
      PERFORM content_type__drop_type(child_rec.object_type, 't', 'f');
    end LOOP;

  end if;

  -- now drop all the attributes related to this type
  for attr_row in select
                    attribute_name
                  from
                    acs_attributes
                  where
                    object_type = drop_type__content_type 
  LOOP
    PERFORM content_type__drop_attribute(drop_type__content_type,
                                         attr_row.attribute_name,
                                         'f'
    );
  end LOOP;

  -- we'll remove the associated table if it exists
  select 
    table_exists(lower(table_name)) into table_exists_p
  from 
    acs_object_types
  where 
    object_type = drop_type__content_type;

  if table_exists_p and drop_type__drop_table_p then
    select 
      table_name into v_table_name 
    from 
      acs_object_types 
    where
      object_type = drop_type__content_type;
       
    -- drop the rule and input/output views for the type
    -- being dropped.
    -- FIXME: this did not exist in the oracle code and it needs to be
    -- tested.  Thanks to Vinod Kurup for pointing this out.
    -- The rule dropping might be redundant as the rule might be dropped
    -- when the view is dropped.

    execute 'drop rule ' || v_table_name || '_r';
    execute 'drop view ' || v_table_name || 'x';
    execute 'drop view ' || v_table_name || 'i';

    execute 'drop table ' || v_table_name;
  end if;

  PERFORM acs_object_type__drop_type(drop_type__content_type, 'f');

  return 0; 
end;$_$;


--
-- Name: content_type__get_template(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__get_template(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get_template__content_type           alias for $1;  
  get_template__use_context            alias for $2;  
  v_template_id                        cr_templates.template_id%TYPE;
begin
  select
    template_id
  into
    v_template_id
  from
    cr_type_template_map
  where
    content_type = get_template__content_type
  and
    use_context = get_template__use_context
  and
    is_default = 't';

  return v_template_id;
 
end;$_$;


--
-- Name: content_type__is_content_type(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__is_content_type(character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  is_content_type__object_type            alias for $1;  
  v_is_content_type                       boolean       
begin

  if is_content_type__object_type = 'content_revision' then

    v_is_content_type := 't';

  else    
    select count(*) > 0 into v_is_content_type
    from acs_object_type_supertype_map
    where object_type = is_content_type__object_type 
    and ancestor_type = 'content_revision';
  end if;
  
  return v_is_content_type;
 
end;$_$;


--
-- Name: content_type__refresh_trigger(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__refresh_trigger(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  refresh_trigger__content_type           alias for $1;  
  rule_text                               text default '';
  v_table_name                            acs_object_types.table_name%TYPE;
  type_rec                                record;
begin

  -- get the table name for the content type (determines view name)

  select table_name 
    into v_table_name
    from acs_object_types 
   where object_type = refresh_trigger__content_type;

  --=================== start building rule code =======================

  rule_text := 'create rule ' || v_table_name || '_r as on insert to ' ||
               v_table_name || 'i do instead (
                update cr_dummy set val = (
                select content_revision__new(
                                     new.title,
                                     new.description,
                                     now(),
                                     new.mime_type,
                                     new.nls_language,
                                     case when new.text is null 
                                              then new.data 
                                              else new.text
                                           end,
                                     content_symlink__resolve(new.item_id),
                                     new.revision_id,
                                     now(),
                                     new.creation_user, 
                                     new.creation_ip,
                                     new.object_package_id
                ));
                ';

  -- add an insert statement for each subtype in the hierarchy for this type

  for type_rec in select ot2.object_type, tree_level(ot2.tree_sortkey) as level
                  from acs_object_types ot1, acs_object_types ot2
                  where ot2.object_type <> 'acs_object'                       
                    and ot2.object_type <> 'content_revision'
                    and ot1.object_type = refresh_trigger__content_type
                    and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
                  order by level desc
  LOOP
    rule_text := rule_text || ' ' || content_type__trigger_insert_statement(type_rec.object_type) || ';';
  end loop;

  -- end building the rule definition code

  rule_text := rule_text || ' );';

  --================== done building rule code =======================

  -- drop the old rule
  if rule_exists(v_table_name || '_r', v_table_name || 'i') then 

    -- different syntax for dropping a rule in 7.2 and 7.3 so check which
    -- version is being used (olah).
    if version() like '%PostgreSQL 7.2%' then
      execute 'drop rule ' || v_table_name || '_r';
    else
      -- 7.3 syntax
      execute 'drop rule ' || v_table_name || '_r ' || 'on ' || v_table_name || 'i';
    end if;

  end if;

  -- create the new rule for inserts on the content type
  execute rule_text;

  return null; 

end;$_$;


--
-- Name: content_type__refresh_view(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__refresh_view(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  refresh_view__content_type           alias for $1;  
  cols                                 varchar default ''; 
  tabs                                 varchar default ''; 
  joins                                varchar default '';
  v_table_name                         varchar;
  join_rec                             record;
begin
--                  select 
--                    table_name, id_column, level
--                  from
--                    acs_object_types
--                  where
--                    object_type <> 'acs_object'
--                  and
--                    object_type <> 'content_revision'
--                  start with
--                    object_type = refresh_view__content_type
--                  connect by
--                    object_type = prior supertype 

  for join_rec in select ot2.table_name, ot2.id_column, tree_level(ot2.tree_sortkey) as level
                  from acs_object_types ot1, acs_object_types ot2
                  where ot2.object_type <> 'acs_object'                       
                    and ot2.object_type <> 'content_revision'
                    and lower(ot2.table_name) <> 'acs_objects'     
                    and lower(ot2.table_name) <> 'cr_revisions'
                    and ot1.object_type = refresh_view__content_type
                    and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
                  order by ot2.tree_sortkey desc
  LOOP
    cols := cols || ', ' || join_rec.table_name || '.*';
    tabs := tabs || ', ' || join_rec.table_name;
    joins := joins || ' and acs_objects.object_id = ' || 
             join_rec.table_name || '.' || join_rec.id_column;
  end loop;

  select table_name into v_table_name from acs_object_types
    where object_type = refresh_view__content_type;

  if length(v_table_name) > 25 then
      raise exception 'Table name cannot be longer than 25 characters, because that causes conflicting rules when we create the views.';
  end if;

  -- create the input view (includes content columns)

  if table_exists(v_table_name || 'i') then
     execute 'drop view ' || v_table_name || 'i';
  end if;

  -- FIXME:  need to look at content_revision__get_content.  Since the CR
  -- can store data in a lob, a text field or in an external file, getting
  -- the data attribute for this view will be problematic.

  execute 'create or replace view ' || v_table_name ||
    'i as select  acs_objects.object_id,
 acs_objects.object_type,
 acs_objects.title as object_title,
 acs_objects.package_id as object_package_id,
 acs_objects.context_id,
 acs_objects.security_inherit_p,
 acs_objects.creation_user,
 acs_objects.creation_date,
 acs_objects.creation_ip,
 acs_objects.last_modified,
 acs_objects.modifying_user,
 acs_objects.modifying_ip,
 acs_objects.tree_sortkey,
 acs_objects.max_child_sortkey, cr.revision_id, cr.title, cr.item_id,
    content_revision__get_content(cr.revision_id) as data, 
    cr_text.text_data as text,
    cr.description, cr.publish_date, cr.mime_type, cr.nls_language' || 
    cols || 
    ' from acs_objects, cr_revisions cr, cr_text' || tabs || ' where 
    acs_objects.object_id = cr.revision_id ' || joins;

  -- create the output view (excludes content columns to enable SELECT *)

  if table_exists(v_table_name || 'x') then
     execute 'drop view ' || v_table_name || 'x';
  end if;

  execute 'create or replace view ' || v_table_name ||
    'x as select  acs_objects.object_id,
 acs_objects.object_type,
 acs_objects.title as object_title,
 acs_objects.package_id as object_package_id,
 acs_objects.context_id,
 acs_objects.security_inherit_p,
 acs_objects.creation_user,
 acs_objects.creation_date,
 acs_objects.creation_ip,
 acs_objects.last_modified,
 acs_objects.modifying_user,
 acs_objects.modifying_ip,
 acs_objects.tree_sortkey,
 acs_objects.max_child_sortkey, cr.revision_id, cr.title, cr.item_id,
    cr.description, cr.publish_date, cr.mime_type, cr.nls_language,
    i.name, i.parent_id' || 
    cols || 
    ' from acs_objects, cr_revisions cr, cr_items i, cr_text' || tabs || 
    ' where acs_objects.object_id = cr.revision_id 
      and cr.item_id = i.item_id' || joins;

  PERFORM content_type__refresh_trigger(refresh_view__content_type);

-- exception
--   when others then
--     dbms_output.put_line('Error creating attribute view or trigger for'
--  || content_type);

  return 0; 
end;$_$;


--
-- Name: content_type__register_child_type(character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__register_child_type(character varying, character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  register_child_type__parent_type   alias for $1;  
  register_child_type__child_type    alias for $2;  
  register_child_type__relation_tag  alias for $3;  -- default 'generic'  
  register_child_type__min_n         alias for $4;  -- default 0
  register_child_type__max_n         alias for $5;  -- default null
  v_exists                           integer;
begin

  select count(*) into v_exists 
    from cr_type_children
    where parent_type = register_child_type__parent_type
    and child_type = register_child_type__child_type;

  if v_exists = 0 then

    insert into cr_type_children (
      parent_type, child_type, relation_tag, min_n, max_n
    ) values (
      register_child_type__parent_type, register_child_type__child_type, 
      register_child_type__relation_tag, 
      register_child_type__min_n, 
      register_child_type__max_n
    );

  else

    update cr_type_children set
      min_n = register_child_type__min_n,
      max_n = register_child_type__max_n
    where 
      parent_type = register_child_type__parent_type
    and 
      child_type = register_child_type__child_type
    and
      relation_tag = register_child_type__relation_tag;

  end if;
      
  return 0; 
end;$_$;


--
-- Name: content_type__register_mime_type(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__register_mime_type(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  register_mime_type__content_type           alias for $1;  
  register_mime_type__mime_type              alias for $2;  
  v_valid_registration                       integer;       
begin

  -- check if this type is already registered  
  select
    count(*) into v_valid_registration
  from 
    cr_mime_types
  where 
    not exists ( select 1
                 from
	           cr_content_mime_type_map
                 where
                   mime_type = register_mime_type__mime_type
                 and
                   content_type = register_mime_type__content_type )
  and
    mime_type = register_mime_type__mime_type;

  if v_valid_registration = 1 then    
    insert into cr_content_mime_type_map (
      content_type, mime_type
    ) values (
      register_mime_type__content_type, register_mime_type__mime_type
    );
  end if;

  return 0; 
end;$_$;


--
-- Name: content_type__register_relation_type(character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__register_relation_type(character varying, character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  register_relation_type__content_type  alias for $1;  
  register_relation_type__target_type   alias for $2;  
  register_relation_type__relation_tag  alias for $3;  -- default 'generic'  
  register_relation_type__min_n         alias for $4;  -- default 0
  register_relation_type__max_n         alias for $5;  -- default null
  v_exists                              integer;       
begin

  -- check if the relation type exists
  select 
    count(*) into v_exists 
  from 
    cr_type_relations
  where 
    content_type = register_relation_type__content_type
  and
    target_type = register_relation_type__target_type
  and 
    relation_tag = register_relation_type__relation_tag;

  -- if the relation type does not exist, insert a row into cr_type_relations
  if v_exists = 0 then
    insert into cr_type_relations (
      content_type, target_type, relation_tag, min_n, max_n
    ) values (
      register_relation_type__content_type, 
      register_relation_type__target_type, 
      register_relation_type__relation_tag, 
      register_relation_type__min_n, register_relation_type__max_n
    );

  -- otherwise, update the row in cr_type_relations
  else
    update cr_type_relations set
      min_n = register_relation_type__min_n,
      max_n = register_relation_type__max_n
    where 
      content_type = register_relation_type__content_type
    and 
      target_type = register_relation_type__target_type
    and
      relation_tag = register_relation_type__relation_tag;
  end if;

  return 0; 
end;$_$;


--
-- Name: content_type__register_template(character varying, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__register_template(character varying, integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  register_template__content_type           alias for $1;  
  register_template__template_id            alias for $2;  
  register_template__use_context            alias for $3;  
  register_template__is_default             alias for $4;  -- default 'f'  
  v_template_registered                     boolean;       
begin
  select 
    count(*) > 0 into v_template_registered
  from
    cr_type_template_map
  where
    content_type = register_template__content_type
  and
    use_context =  register_template__use_context
  and
    template_id =  register_template__template_id;

  -- register the template
  if NOT v_template_registered then
    insert into cr_type_template_map (
      template_id, content_type, use_context, is_default
    ) values (
      register_template__template_id, register_template__content_type, 
      register_template__use_context, register_template__is_default
    );

  -- update the registration status of the template
  else

    -- unset the default template before setting this one as the default
    if register_template__is_default then
      update cr_type_template_map
        set is_default = 'f'
        where content_type = register_template__content_type
        and use_context = register_template__use_context;
    end if;

    update cr_type_template_map
      set is_default =    register_template__is_default
      where template_id = register_template__template_id
      and content_type =  register_template__content_type
      and use_context =   register_template__use_context;
  end if;

  return 0; 
end;$_$;


--
-- Name: content_type__rotate_template(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__rotate_template(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  rotate_template__template_id            alias for $1;  
  rotate_template__v_content_type         alias for $2;  
  rotate_template__use_context            alias for $3;  
  v_template_id                           cr_templates.template_id%TYPE;
  v_items_val                             record;
begin

  -- get the default template
  select
    template_id into v_template_id
  from
    cr_type_template_map
  where
    content_type = rotate_template__v_content_type
  and
    use_context = rotate_template__use_context
  and
    is_default = 't';

  if v_template_id is not null then

    -- register an item-template to all items without an item-template
    for v_items_val in select
                         item_id
                       from
                         cr_items i, cr_type_template_map m
                       where
                         i.content_type = rotate_template__v_content_type
                       and
                         m.use_context = rotate_template__use_context
                       and
                         i.content_type = m.content_type
                       and
                         not exists ( select 1
                                        from
                                          cr_item_template_map
                                        where
                                          item_id = i.item_id
                                        and
                                          use_context = rotate_template__use_context ) 
    LOOP
      PERFORM content_item__register_template ( 
         v_items_val.item_id, 
         v_template_id,
         rotate_template__use_context
      );
    end loop;
  end if;

  -- register the new template as the default template of the content type
  if v_template_id != rotate_template__template_id then
    PERFORM content_type__register_template(
        rotate_template__v_content_type,
        rotate_template__template_id,
        rotate_template__use_context,
        't'
    );
  end if;

  return 0; 
end;$_$;


--
-- Name: content_type__set_default_template(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__set_default_template(character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_default_template__content_type           alias for $1;  
  set_default_template__template_id            alias for $2;  
  set_default_template__use_context            alias for $3;  
                                        
begin

  update cr_type_template_map
    set is_default = 't'
    where template_id = set_default_template__template_id
    and content_type = set_default_template__content_type
    and use_context = set_default_template__use_context;

  -- make sure there is only one default template for
  --   any given content_type/use_context pair
  update cr_type_template_map
    set is_default = 'f'
    where template_id <> set_default_template__template_id
    and content_type = set_default_template__content_type
    and use_context = set_default_template__use_context
    and is_default = 't';

  return 0; 
end;$_$;


--
-- Name: content_type__trigger_insert_statement(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__trigger_insert_statement(character varying) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  trigger_insert_statement__content_type   alias for $1;  
  v_table_name                             acs_object_types.table_name%TYPE;
  v_id_column                              acs_object_types.id_column%TYPE;
  cols                                     varchar default '';
  vals                                     varchar default '';
  attr_rec                                 record;
begin
  if trigger_insert_statement__content_type is null then 
	return exception 'content_type__trigger_insert_statement called with null content_type';
  end if;

  select 
    table_name, id_column into v_table_name, v_id_column
  from 
    acs_object_types 
  where 
    object_type = trigger_insert_statement__content_type;

  for attr_rec in select
                    attribute_name
                  from
                    acs_attributes
                  where
                    object_type = trigger_insert_statement__content_type 
  LOOP
    cols := cols || ', ' || attr_rec.attribute_name;
    vals := vals || ', new.' || attr_rec.attribute_name;
  end LOOP;

  return 'insert into ' || v_table_name || 
    ' ( ' || v_id_column || cols || ' ) values (cr_dummy.val' ||
    vals || ')';
  
end;$_$;


--
-- Name: content_type__unregister_child_type(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__unregister_child_type(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unregister_child_type__parent_type            alias for $1;  
  unregister_child_type__child_type             alias for $2;  
  unregister_child_type__relation_tag           alias for $3;  -- default null
begin

  delete from 
    cr_type_children
  where 
    parent_type = unregister_child_type__parent_type
  and 
    child_type = unregister_child_type__child_type
  and
    relation_tag = unregister_child_type__relation_tag;

  return 0; 
end;$_$;


--
-- Name: content_type__unregister_mime_type(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__unregister_mime_type(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unregister_mime_type__content_type           alias for $1;  
  unregister_mime_type__mime_type              alias for $2;  
begin

  delete from cr_content_mime_type_map
    where content_type = unregister_mime_type__content_type
    and mime_type = unregister_mime_type__mime_type;

  return 0; 
end;$_$;


--
-- Name: content_type__unregister_relation_type(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__unregister_relation_type(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unregister_relation_type__content_type  alias for $1;  
  unregister_relation_type__target_type   alias for $2;  
  unregister_relation_type__relation_tag  alias for $3;  -- default null  
                                        
begin

  delete from 
    cr_type_relations
  where 
    content_type = unregister_relation_type__content_type
  and 
    target_type = unregister_relation_type__target_type
  and
    relation_tag = unregister_relation_type__relation_tag;

  return 0; 
end;$_$;


--
-- Name: content_type__unregister_template(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION content_type__unregister_template(character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unregister_template__content_type           alias for $1;  -- default null  
  unregister_template__template_id            alias for $2; 
  unregister_template__use_context            alias for $3;  -- default null 
begin

  if unregister_template__use_context is null and 
     unregister_template__content_type is null then

    delete from cr_type_template_map
      where template_id = unregister_template__template_id;

  else if unregister_template__use_context is null then

    delete from cr_type_template_map
      where template_id = unregister_template__template_id
      and content_type = unregister_template__content_type;

  else if unregister_template__content_type is null then

    delete from cr_type_template_map
      where template_id = unregister_template__template_id
      and use_context = unregister_template__use_context;

  else

    delete from cr_type_template_map
      where template_id = unregister_template__template_id
      and content_type = unregister_template__content_type
      and use_context = unregister_template__use_context;

  end if; end if; end if;

  return 0; 
end;$_$;


--
-- Name: cr_cleanup_cr_files_del_trg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_cleanup_cr_files_del_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        
begin
        insert into cr_files_to_delete
        select r.content as path, i.storage_area_key
          from cr_items i, cr_revisions r
         where i.item_id = r.item_id
           and r.revision_id = old.revision_id
           and i.storage_type = 'file';

        return old;
end;$$;


--
-- Name: cr_dummy_ins_del_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_dummy_ins_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        raise exception 'Only updates are allowed on cr_dummy';
        return null;
end;$$;


--
-- Name: cr_folder_del_ri_trg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_folder_del_ri_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        dummy           integer;
begin
        delete from cr_folders where folder_id = old.item_id;          
        return old;
end;$$;


--
-- Name: cr_folder_ins_up_ri_trg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_folder_ins_up_ri_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        dummy           integer;
        v_latest        integer;
        v_live          integer;
begin
        select 1 into dummy
        from 
          cr_items         
        where 
          item_id = new.folder_id;
        
        if NOT FOUND then
          raise EXCEPTION 'Referential Integrity: folder_id does not exist in cr_items: %', new.folder_id;
        end if;

        return new;
end;$$;


--
-- Name: cr_items_get_tree_sortkey(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_items_get_tree_sortkey(integer) RETURNS bit varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_item_id    alias for $1;
begin
  return tree_sortkey from cr_items where item_id = p_item_id;
end;$_$;


--
-- Name: cr_items_publish_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_items_publish_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  if new.live_revision <> old.live_revision or
     new.publish_status <> old.publish_status
  then 

    insert into cr_item_publish_audit (
      item_id, old_revision, new_revision, old_status, new_status, publish_date
    ) values (
      new.item_id, old.live_revision, new.live_revision, 
      old.publish_status, new.publish_status,
      now()
    );

  end if;

  return new;

end;$$;


--
-- Name: cr_items_tree_insert_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_items_tree_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
    v_parent_sk      	varbit default null;
    v_max_child_sortkey varbit;
    v_parent_id      	integer default null;
begin
    select item_id
    into   v_parent_id
    from   cr_items
    where  item_id = new.parent_id;

    if new.parent_id = 0 then
	
	new.tree_sortkey := int_to_tree_key(new.item_id+1000);

    elsif v_parent_id is null then 

	new.tree_sortkey := int_to_tree_key(new.parent_id+1000) || int_to_tree_key(new.item_id+1000);

    else

	SELECT tree_sortkey, tree_increment_key(max_child_sortkey)
	INTO v_parent_sk, v_max_child_sortkey
	FROM cr_items
	WHERE item_id = new.parent_id 
	FOR UPDATE;

	UPDATE cr_items
	SET max_child_sortkey = v_max_child_sortkey
	WHERE item_id = new.parent_id;

	new.tree_sortkey := v_parent_sk || v_max_child_sortkey;

    end if;

    return new;
end;$$;


--
-- Name: cr_items_tree_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_items_tree_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk     	varbit default null;
        v_max_child_sortkey     varbit;
        v_parent_id            	integer default null;
        v_old_parent_length	integer;
begin
        if new.item_id = old.item_id and 
           ((new.parent_id = old.parent_id) or
            (new.parent_id is null and old.parent_id is null)) then

           return new;

        end if;

        select item_id
    	into   v_parent_id
	from   cr_items
	where  item_id = new.parent_id;

	-- the tree sortkey is going to change so get the new one and update it and all its
	-- children to have the new prefix...
	v_old_parent_length := length(new.tree_sortkey) + 1;

        if new.parent_id = 0 then
            v_parent_sk := int_to_tree_key(new.item_id+1000);
	elsif v_parent_id is null then 
            v_parent_sk := int_to_tree_key(new.parent_id+1000) || int_to_tree_key(new.item_id+1000);
        else
	    SELECT tree_sortkey, tree_increment_key(max_child_sortkey)
	    INTO v_parent_sk, v_max_child_sortkey
	    FROM cr_items
	    WHERE item_id = new.parent_id 
	    FOR UPDATE;

	    UPDATE cr_items
	    SET max_child_sortkey = v_max_child_sortkey
	    WHERE item_id = new.parent_id;

	    v_parent_sk := v_parent_sk || v_max_child_sortkey;
        end if;

	UPDATE cr_items
	SET tree_sortkey = v_parent_sk || substring(tree_sortkey, v_old_parent_length)
	WHERE tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);

        return new;

end;$$;


--
-- Name: cr_items_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_items_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

  if new.parent_id <> old.parent_id then
    update acs_objects set context_id = new.parent_id
    where object_id = new.item_id;
  end if;

  return new;
end;$$;


--
-- Name: cr_keywords_get_tree_sortkey(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_keywords_get_tree_sortkey(integer) RETURNS bit varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_keyword_id    alias for $1;
begin
  return tree_sortkey from cr_keywords where keyword_id = p_keyword_id;
end;$_$;


--
-- Name: cr_keywords_tree_insert_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_keywords_tree_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk      varbit default null;
        v_max_value      integer;
begin
        if new.parent_id is null then 
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
              from cr_keywords 
             where parent_id is null;
        else 
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
              from cr_keywords 
             where parent_id = new.parent_id;

            select tree_sortkey into v_parent_sk 
              from cr_keywords 
             where keyword_id = new.parent_id;
        end if;

        new.tree_sortkey := tree_next_key(v_parent_sk, v_max_value);

        return new;

end;$$;


--
-- Name: cr_keywords_tree_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_keywords_tree_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk     varbit default null;
        v_max_value     integer;
        p_id            integer;
        v_rec           record;
        clr_keys_p      boolean default 't';
begin
        if new.keyword_id = old.keyword_id and 
           ((new.parent_id = old.parent_id) or
            (new.parent_id is null and old.parent_id is null)) 
        THEN

           return new;

        end if;

        for v_rec in select keyword_id
                       from cr_keywords 
                      where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey)
                   order by tree_sortkey
        LOOP
            if clr_keys_p then
               update cr_keywords set tree_sortkey = null
               where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);
               clr_keys_p := 'f';
            end if;
            
            select parent_id into p_id
              from cr_keywords 
             where keyword_id = v_rec.keyword_id;

            if p_id is null then 
                select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
                  from cr_keywords 
                 where parent_id is null;
            else 
                select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
                  from cr_keywords 
                 where parent_id = p_id;

                select tree_sortkey into v_parent_sk 
                  from cr_keywords 
                 where keyword_id = p_id;
            end if;

            update cr_keywords 
               set tree_sortkey = tree_next_key(v_parent_sk, v_max_value)
             where keyword_id = v_rec.keyword_id;

        end LOOP;

        return new;

end;$$;


--
-- Name: cr_keywords_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_keywords_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  if old.parent_id <> new.parent_id then
    update acs_objects set context_id = new.parent_id
      where object_id = new.keyword_id;
  end if;

  return new;
end;$$;


--
-- Name: cr_revision_del_rev_ri_trg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_revision_del_rev_ri_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        dummy           integer;
begin
        select 1 into dummy
        from 
          cr_items
        where 
          item_id = old.item_id
        and
          live_revision = old.revision_id;
        
        if FOUND then
          raise EXCEPTION 'Referential Integrity: attempting to delete live_revision: %', old.revision_id;
        end if;
        
        select 1 into dummy
        from 
          cr_items
        where 
          item_id = old.item_id
        and
          latest_revision = old.revision_id;
        
        if FOUND then
          raise EXCEPTION 'Referential Integrity: attempting to delete latest_revision: %', old.revision_id;
        end if;
        
        return old;
end;$$;


--
-- Name: cr_revision_del_ri_trg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_revision_del_ri_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        dummy           integer;
        v_latest        integer;
        v_live          integer;
begin
        select 1 into dummy
        from 
          cr_revisions           
        where 
          revision_id = old.live_revision;
        
        if FOUND then
          raise EXCEPTION 'Referential Integrity: live_revision still exists: %', old.live_revision;
        end if;
        
        select 1 into dummy
        from 
          cr_revisions 
        where 
          revision_id = old.latest_revision;
        
        if FOUND then
          raise EXCEPTION 'Referential Integrity: latest_revision still exists: %', old.latest_revision;
        end if;
        
        return old;
end;$$;


--
-- Name: cr_revision_ins_ri_trg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_revision_ins_ri_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        dummy           integer;
        v_latest        integer;
        v_live          integer;
begin
        select 1 into dummy
        from 
          cr_revisions           
        where 
          revision_id = new.live_revision;
        
        if NOT FOUND and new.live_revision is NOT NULL then
          raise EXCEPTION 'Referential Integrity: live_revision does not exist: %', new.live_revision;
        end if;
        
        select 1 into dummy
        from 
          cr_revisions 
        where 
          revision_id = new.latest_revision;
        
        if NOT FOUND and new.latest_revision is NOT NULL then
          raise EXCEPTION 'Referential Integrity: latest_revision does not exist: %', new.latest_revision;
        end if;

        return new;
end;$$;


--
-- Name: cr_revision_latest_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_revision_latest_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  update cr_items set latest_revision = new.revision_id
  where item_id = new.item_id;
  return new;
end;$$;


--
-- Name: cr_revision_up_ri_trg(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_revision_up_ri_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        dummy           integer;
        v_latest        integer;
        v_live          integer;
begin
        select 1 into dummy
        from 
          cr_revisions           
        where 
          revision_id = new.live_revision;
        
        if NOT FOUND and new.live_revision <> old.live_revision and new.live_revision is NOT NULL then
          raise EXCEPTION 'Referential Integrity: live_revision does not exist: %', new.live_revision;
        end if;
        
        select 1 into dummy
        from 
          cr_revisions 
        where 
          revision_id = new.latest_revision;
        
        if NOT FOUND and new.latest_revision <> old.latest_revision and new.latest_revision is NOT NULL then
          raise EXCEPTION 'Referential Integrity: latest_revision does not exist: %', new.latest_revision;
        end if;
        
        return new;
end;$$;


--
-- Name: cr_scheduled_release_exec(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_scheduled_release_exec() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
  exec__last_exec             timestamptz;
  exec__this_exec             timestamp default now();
  exec__items_released        integer default 0;
  exec__items_expired         integer default 0;
  exec__err_num               integer;  -- sqlcode
  exec__err_msg               varchar;  -- substr(sqlerrm, 1, 500);
  item_rec                    record;
begin

    select last_exec into exec__last_exec from cr_scheduled_release_job;

    for item_rec in select 
                      p.item_id, live_revision
                    from
                      cr_release_periods p, cr_items i
                    where
                      start_when between exec__last_exec and now()
                    and
                      p.item_id = i.item_id 
    LOOP
      -- update publish status
      update cr_items
	set publish_status = 'live'
      where
	item_id = item_rec.item_id;
      exec__items_released := exec__items_released + 1;
    end loop;

    for item_rec in select 
                      p.item_id, live_revision
                    from
                      cr_release_periods p, cr_items i
                    where
                      end_when between exec__last_exec and now()
                    and
                      p.item_id = i.item_id
    LOOP
      -- update publish status
      update cr_items
	set publish_status = 'expired'
      where
	item_id = item_rec.item_id;

      exec__items_expired := exec__items_expired + 1;

    end loop;

  -- exception

  --   when others then
  --    err_num := SQLCODE;
  --    err_msg := substr(SQLERRM, 1, 500);
  -- end;

  -- keep a record of the update

  insert into cr_scheduled_release_log (
    items_released, items_expired, err_num, err_msg
  ) values (
    exec__items_released, exec__items_expired, exec__err_num, 
    exec__err_msg
  );

  -- Table was growing without bound (OpenACS DanW)
  delete from cr_scheduled_release_log
  where exec_date < now() - '4 week'::interval;

  -- Reset the last time of execution to start of processing
  update cr_scheduled_release_job set last_exec = exec__this_exec;

  return 0;
end;$$;


--
-- Name: cr_scheduled_release_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_scheduled_release_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

   raise EXCEPTION '-20000: Inserts are not allowed into cr_scheduled_release_job.';

  return new;
end;$$;


--
-- Name: cr_text_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_text_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

   raise EXCEPTION '-20000: Inserts are not allowed into cr_text.';

   return new;

end;$$;


--
-- Name: cr_type_template_map_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cr_type_template_map_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

  if new.is_default = 't' then
    update
      cr_type_template_map
    set
      is_default = 'f'
    where
      content_type = new.content_type
    and
      use_context = new.use_context
    and 
      template_id <> new.template_id
    and
      is_default = 't';
  end if;

  return new;

end;$$;


--
-- Name: define_function_args(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION define_function_args(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_function		alias for $1;
  p_arg_list		alias for $2;

  v_arg_seq		integer default 1;
  v_arg_name		varchar;
  v_arg_default		varchar;
  v_elem		varchar;
  v_pos			integer;
begin
  delete from acs_function_args where function = upper(p_function);

  v_elem = split(p_arg_list, ',', v_arg_seq);
  while v_elem is not null loop
    
    v_pos = instr(v_elem, ';', 1, 1);
    if v_pos > 0 then
      v_arg_name := substr(v_elem, 1, v_pos-1);
      v_arg_default := substr(v_elem, v_pos+1, length(v_elem) - v_pos);
    else
      v_arg_name := v_elem;
      v_arg_default := NULL;
    end if;

    insert into acs_function_args (function, arg_seq, arg_name, arg_default)
	   values (upper(p_function), v_arg_seq, upper(v_arg_name), v_arg_default);

    v_arg_seq := v_arg_seq + 1;
    v_elem = split(p_arg_list, ',', v_arg_seq);
  end loop;
    
  return 1;
end;$_$;


--
-- Name: doc__get_package_header(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION doc__get_package_header(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  package_name           alias for $1;  
begin

        return '';
   
end;$_$;


--
-- Name: doc__get_proc_header(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION doc__get_proc_header(character varying, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  proc_name              alias for $1;  
  package_name           alias for $2;  
begin
        return definition 
          from acs_func_headers 
         where fname = (package_name || '__' || proc_name)::name 
         limit 1;

end;$_$;


--
-- Name: dow_to_int(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dow_to_int(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       dow_to_int__weekday	alias for $1;
       v_dow			integer;
begin
       -- Brute force (what can I say?).
       select (case trim(upper(dow_to_int__weekday))
	             when 'SUNDAY'    then 1
	             when 'SUN'       then 1
		     when 'MONDAY'    then 2
		     when 'MON'	then 2
		     when 'TUESDAY'	then 3
		     when 'TUES'	then 3
		     when 'TUE'	then 3
		     when 'WEDNESDAY' then 4
		     when 'WED'	then 4
		     when 'WEDS'	then 4
		     when 'THURSDAY'  then 5
		     when 'THURS'	then 5
		     when 'THUR'	then 5
		     when 'THU'	then 5
		     when 'FRIDAY'	then 6
		     when 'FRI'	then 6
		     when 'SATURDAY'	then 7
		     when 'SAT'	then 7
		     else -1
		end) into v_dow
       from dual;
	
       if v_dow < 0 
       then 
	   raise exception 'Day of the week unknown';
       end if;

       return v_dow;

end;$_$;


--
-- Name: download_rep__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION download_rep__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	delete__repository_id		alias for $1;
begin
	delete from acs_objects where context_id = delete__repository_id;

    delete from download_repository
    where repository_id = delete__repository_id;

    PERFORM acs_object__delete( delete__repository_id );

	return 0;
end;$_$;


--
-- Name: download_rep__edit(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION download_rep__edit(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    edit__repository_id			alias for $1;
    edit__title					alias for $2;
	edit__description			alias for $3;
	edit__help_text				alias for $4;
    edit__last_modified			alias for $5;
    edit__modifying_user		alias for $6;
    edit__modifying_ip			alias for $7;
    v_revision_id				integer;
begin
	select into v_revision_id content_revision__new (
		edit__title,
		edit__description,
		now(),					-- publish_date
		'text/plain',			-- mime_type
		null,					-- nls_language
		edit__help_text,
		edit__repository_id,
		null,					-- revision_id
		edit__last_modified,
		edit__modifying_user,
		edit__modifying_ip
    );

	PERFORM content_item__set_live_revision(v_revision_id);

	update acs_objects set 
        last_modified = edit__last_modified,
        modifying_user = edit__modifying_user,
		modifying_ip = edit__modifying_ip
	where object_id = edit__repository_id;

	return 0;
end;$_$;


--
-- Name: download_rep__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION download_rep__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	new__repository_id			alias for $1;
	new__title					alias for $2;
	new__description			alias for $3;
	new__help_text				alias for $4;  -- default null
	new__creation_date			alias for $5;  -- default now()
	new__creation_user			alias for $6;  -- default null
	new__parent_id				alias for $7;  -- default null
	new__context_id				alias for $8;  -- default null
	new__creation_ip			alias for $9;  -- default null
    v_name						cr_items.name%TYPE;
    v_repository_id				integer;
	v_revision_id				integer;
begin
    v_name := 'download_repository' || new__repository_id;
    select into v_repository_id content_item__new (
		v_name,
		new__parent_id,
		new__repository_id,
		null,					-- locale
		new__creation_date,
		new__creation_user,
		new__context_id,
		new__creation_ip,
		'content_item',		-- item_subtype
		'cr_download_rep',
		new__title,
		new__description,
		'text/plain',			-- mime_type
		null,					-- nls_language
		new__help_text,
		'text'				-- storage_type (vk - not sure about this)
	);

    insert into download_repository
     (repository_id)
    values
     (new__repository_id);

	 -- get the latest revision
	 select into v_revision_id content_item__get_latest_revision (v_repository_id);

	 -- make it live
	 select into v_revision_id content_item__set_live_revision ( v_revision_id );

    return v_repository_id;

end;$_$;


--
-- Name: drop_package(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION drop_package(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
       package_name      alias for $1;
       v_rec             record;
       v_drop_cmd        varchar;
       v_pkg_name        varchar;
begin
        raise NOTICE 'DROP PACKAGE: %', package_name;
        v_pkg_name := package_name || '\\_\\_' || '%';

        for v_rec in select proname 
                       from pg_proc 
                      where proname like v_pkg_name 
                   order by proname 
        LOOP
            raise NOTICE 'DROPPING FUNCTION: %', v_rec.proname;
            v_drop_cmd := get_func_drop_command (v_rec.proname::varchar);
            EXECUTE v_drop_cmd;
        end loop;

        if NOT FOUND then 
          raise NOTICE 'PACKAGE: % NOT FOUND', package_name;
        else
          raise NOTICE 'PACKAGE: %: DROPPED', package_name;
        end if;
        
        return null;

end;$_$;


--
-- Name: empty_lob(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION empty_lob() RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	return nextval('lob_sequence');
end;$$;


--
-- Name: etp__create_extlink(integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__create_extlink(integer, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_package_id alias for $1;
  p_url alias for $2;
  p_title alias for $3;
  p_description alias for $4; 
  v_item_id integer;
  v_folder_id integer;
begin
  v_item_id := acs_object__new(null, 'content_extlink');
  v_folder_id := etp__get_folder_id(p_package_id);

  insert into cr_items (
    item_id, parent_id, name, content_type
  ) values (
    v_item_id, v_folder_id, 'extlink ' || etp_auto_page_number_seq.nextval, 'content_extlink'
  );

  insert into cr_extlinks
    (extlink_id, url, label, description)
  values
    (v_item_id, p_url, p_title, p_description);

  return 1;
end;
$_$;


--
-- Name: etp__create_new_revision(integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__create_new_revision(integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_package_id alias for $1;
  p_name alias for $2;
  p_user_id alias for $3;
  v_revision_id integer;
  v_item_id integer;
  v_new_revision_id integer;
  v_content_type varchar;
begin

  select max(r.revision_id)
    into v_revision_id
    from cr_revisions r, cr_items i
   where i.name = p_name
     and i.parent_id = etp__get_folder_id(p_package_id)
     and r.item_id = i.item_id;

  select item_id
    into v_item_id
    from cr_revisions
   where revision_id = v_revision_id;

  select object_type
    into v_content_type
    from acs_objects
   where object_id = v_revision_id;

  -- cannot use acs_object__new because it creates attributes with their
  -- default values, which is not what we want.

  select acs_object_id_seq.nextval
    into v_new_revision_id from dual;

  insert into acs_objects (object_id, object_type, creation_date, creation_user, context_id)
  values (v_new_revision_id, v_content_type, now(), p_user_id, v_item_id);

  insert into cr_revisions (revision_id, item_id, title, description, content, mime_type) 
  select v_new_revision_id, item_id, title, description, content, mime_type
    from cr_revisions r
   where r.revision_id = v_revision_id;

  -- copy extended attributes to the new revision, if there are any
  insert into acs_attribute_values (object_id, attribute_id, attr_value)
  select v_new_revision_id as object_id, attribute_id, attr_value
    from acs_attribute_values
   where object_id = v_revision_id;

  return 1;
end;
$_$;


--
-- Name: etp__create_new_revision(integer, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__create_new_revision(integer, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_package_id alias for $1;
  p_name alias for $2;
  p_user_id alias for $3;
  p_revision_id alias for $4;
  v_revision_id integer;
  v_item_id integer;
  v_content_type varchar;
begin

  select max(r.revision_id)
    into v_revision_id
    from cr_revisions r, cr_items i
   where i.name = p_name
     and i.parent_id = etp__get_folder_id(p_package_id)
     and r.item_id = i.item_id;

  select item_id
    into v_item_id
    from cr_revisions
   where revision_id = v_revision_id;

  select object_type
    into v_content_type
    from acs_objects
   where object_id = v_revision_id;

  -- cannot use acs_object__new because it creates attributes with their
  -- default values, which is not what we want.


  insert into acs_objects (object_id, object_type, creation_date, creation_user, context_id)
  values (p_revision_id, v_content_type, now(), p_user_id, v_item_id);

  insert into cr_revisions (revision_id, item_id, title, description, content, mime_type) 
  select p_revision_id, item_id, title, description, content, mime_type
    from cr_revisions r
   where r.revision_id = v_revision_id;

  -- copy extended attributes to the new revision, if there are any
  insert into acs_attribute_values (object_id, attribute_id, attr_value)
  select p_revision_id as object_id, attribute_id, attr_value
    from acs_attribute_values
   where object_id = v_revision_id;

  return 1;
end;
$_$;


--
-- Name: etp__create_page(integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__create_page(integer, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_package_id alias for $1;
  p_name alias for $2;
  p_title alias for $3;
  p_content_type alias for $4;  -- default null -> use content_revision
  v_item_id integer;
  v_revision_id integer;
  v_folder_id integer;
begin
  v_item_id := acs_object__new(null, 'content_item', now(), null, null, p_package_id);

  v_folder_id := etp__get_folder_id(p_package_id);

-- due to a change in acs_object__delete we can reference the actual
-- object type we want
-- using this we can more easily search, but we will have to create a service
-- contract for each custom content type
-- we define a default etp_page_revision and service contract to go with it
-- make sure to subtype from etp_page_revision for any custom types
-- 2003-01-12 DaveB

  insert into cr_items (
    item_id, parent_id, name, content_type
  ) values (
    v_item_id, v_folder_id, p_name, p_content_type
  );

  v_revision_id := acs_object__new(null, p_content_type, now(), null, null, v_item_id);

  insert into cr_revisions (revision_id, item_id, title, 
                            publish_date, mime_type) 
  values (v_revision_id, v_item_id, p_title, now(), 'text/enhanced');

  update cr_items set live_revision = v_revision_id
                  where item_id = v_item_id;

  return 1;
end;
$_$;


--
-- Name: etp__create_page(integer, integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__create_page(integer, integer, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_item_id alias for $1;	
  p_package_id alias for $2;
  p_name alias for $3;
  p_title alias for $4;
  p_content_type alias for $5;  -- default null -> use content_revision
  v_item_id integer;
  v_revision_id integer;
  v_folder_id integer;
begin
  if p_item_id is null then
      v_item_id := acs_object__new(null, 'content_item', now(), null, null, p_package_id);
  else 
      v_item_id := acs_object__new(p_item_id, 'content_item', now(), null, null, p_package_id);
  end if;

  v_folder_id := etp__get_folder_id(p_package_id);

-- due to a change in acs_object__delete we can reference the actual
-- object type we want
-- using this we can more easily search, but we will have to create a service
-- contract for each custom content type
-- we define a default etp_page_revision and service contract to go with it
-- make sure to subtype from etp_page_revision for any custom types
-- 2003-01-12 DaveB

  insert into cr_items (
    item_id, parent_id, name, content_type
  ) values (
    v_item_id, v_folder_id, p_name, p_content_type
  );

  v_revision_id := acs_object__new(null, p_content_type, now(), null, null, v_item_id);

  insert into cr_revisions (revision_id, item_id, title, 
                            publish_date, mime_type) 
  values (v_revision_id, v_item_id, p_title, now(), 'text/enhanced');

  update cr_items set live_revision = v_revision_id
                  where item_id = v_item_id;

  return 1;
end;
$_$;


--
-- Name: etp__create_symlink(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__create_symlink(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_package_id alias for $1;
  p_target_id alias for $2;
  v_item_id integer;
  v_folder_id integer;
begin
  v_item_id := acs_object__new(null, 'content_symlink');
  v_folder_id := etp__get_folder_id(p_package_id);

  insert into cr_items (
    item_id, parent_id, name, content_type
  ) values (
    v_item_id, v_folder_id, 'symlink ' || etp_auto_page_number_seq.nextval, 'content_symlink'
  );

  insert into cr_symlinks
    (symlink_id, target_id)
  values
    (v_item_id, p_target_id);

  return 1;
end;
$_$;


--
-- Name: etp__get_attribute_value(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__get_attribute_value(integer, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_object_id alias for $1;
  p_attribute_id alias for $2;
  v_value varchar;
begin
  select attr_value
    into v_value
    from acs_attribute_values
   where object_id = p_object_id
     and attribute_id = p_attribute_id;

  if not found then
    v_value := '';
  end if;

  return v_value;
end;
$_$;


--
-- Name: etp__get_description(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__get_description(integer, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_item_id alias for $1;
  p_revision_description alias for $2;
  v_item_id integer;
  v_description varchar;
  v_object_type varchar;
begin
  if p_revision_description is not null then
    return p_revision_description;
  end if;

  select object_type from acs_objects into v_object_type
   where object_id = p_item_id;

  if v_object_type = 'content_folder' then
    select r.description 
      into v_description
      from cr_items i, cr_revisions r
     where i.parent_id = p_item_id
       and i.name = 'index'
       and i.live_revision = r.revision_id
       and i.item_id = r.item_id;
    return v_description;    
  end if;

  if v_object_type = 'content_extlink' then
    select description into v_description
      from cr_extlinks
     where extlink_id = p_item_id;
    return v_description;
  end if;

  if v_object_type = 'content_symlink' then
    select target_id into v_item_id
      from cr_symlinks
     where symlink_id = p_item_id;
    return etp__get_description(v_item_id, null);
  end if;

  if v_object_type = 'content_item' then
    select r.description into v_description
      from cr_items i, cr_revisions r
     where i.item_id = v_item_id
       and i.live_revision = r.revision_id;
    return v_description;
  end if;  

  return null;

end;$_$;


--
-- Name: etp__get_folder_id(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__get_folder_id(integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    p_package_id alias for $1;
    v_folder_id integer;
    v_parent_id integer;
begin
    select folder_id into v_folder_id
      from cr_folders
     where package_id = p_package_id;
    if not found then 
        select parent_id into v_parent_id
          from site_nodes
         where object_id = p_package_id;
        if found and v_parent_id is null then
            v_folder_id := content_item_globals.c_root_folder_id;
        else
            -- This is probably an ETP app instance that
            -- was created through the Site Map; by returning
	    -- 0 we ensure the get_page_attributes query will
	    -- fail and index.vuh will redirect to etp-setup-2.
            v_folder_id := 0;
        end if;
    end if;

    return v_folder_id;
end;
$_$;


--
-- Name: etp__get_relative_url(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__get_relative_url(integer, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_item_id alias for $1;
  p_name alias for $2;
  v_item_id integer;
  v_url varchar;
  v_object_type varchar;
  v_link_rec record;
begin

  select object_type into v_object_type
    from acs_objects
   where object_id = p_item_id;

  if v_object_type = 'content_item' then
    return p_name;
  end if;

  if v_object_type = 'content_folder' then
    select s.name || '/' into v_url
    from cr_folders f, site_nodes s
    where f.folder_id = p_item_id
    and s.object_id = f.package_id;
    return v_url;
  end if;

  if v_object_type = 'content_extlink' then
    select url into v_url
      from cr_extlinks
     where extlink_id = p_item_id;
    return v_url;
  end if;

  if v_object_type = 'content_symlink' then
    select target_id into v_item_id
      from cr_symlinks
     where symlink_id = p_item_id;

    select f.package_id, i.name
      into v_link_rec
      from cr_items i, cr_folders f
     where i.item_id = v_item_id
       and i.parent_id = f.folder_id;

    select site_node__url(s.node_id) into v_url
      from site_nodes s
     where s.object_id = v_link_rec.package_id;

    return v_url || v_link_rec.name;

  end if;

  return null;

end;
$_$;


--
-- Name: etp__get_title(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION etp__get_title(integer, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_item_id alias for $1;
  p_revision_title alias for $2;
  v_item_id integer;
  v_title varchar;
  v_object_type varchar;
begin
  if p_revision_title is not null then
    return p_revision_title;
  end if;

  select object_type from acs_objects into v_object_type
   where object_id = p_item_id;

  if v_object_type = 'content_folder' then
    select r.title 
      into v_title
      from cr_items i, cr_revisions r
     where i.parent_id = p_item_id
       and i.name = 'index'
       and i.live_revision = r.revision_id;
    return v_title;    
  end if;

  if v_object_type = 'content_extlink' then
    select label into v_title
      from cr_extlinks
     where extlink_id = p_item_id;
    return v_title;
  end if;

  if v_object_type = 'content_symlink' then
    select target_id into v_item_id
      from cr_symlinks
     where symlink_id = p_item_id;
    return etp__get_title(v_item_id, null);
  end if;

  if v_object_type = 'content_item' then
    select r.title into v_title
      from cr_items i, cr_revisions r
     where i.item_id = v_item_id
       and i.live_revision = r.revision_id;
    return v_title;
  end if;  
   
  return null;

end;
$_$;


--
-- Name: file_storage__copy_file(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__copy_file(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$  -- cr_revisions.revision_id%TYPE 
declare
        copy_file__file_id           alias for $1;
        copy_file__target_folder_id  alias for $2;
        copy_file__creation_user     alias for $3;
        copy_file__creation_ip       alias for $4;
        v_name                      cr_items.name%TYPE;
        v_live_revision              cr_items.live_revision%TYPE;
        v_filename                   cr_revisions.title%TYPE;
        v_description                cr_revisions.description%TYPE;
        v_mime_type                  cr_revisions.mime_type%TYPE;
        v_content_length             cr_revisions.content_length%TYPE;
        v_lob_id                     cr_revisions.lob%TYPE;
        v_new_lob_id                 cr_revisions.lob%TYPE;
        v_file_path                  cr_revisions.content%TYPE;
        v_new_file_id                cr_items.item_id%TYPE;
        v_new_version_id                     cr_revisions.revision_id%TYPE;
        v_indb_p                     boolean;
begin

        -- We copy only the title from the file being copied, and attributes of the
        -- live revision
        select i.name,i.live_revision,r.title,r.description,r.mime_type,r.content_length,
               (case when i.storage_type = 'lob'
                     then true
                     else false
                end)
               into v_name,v_live_revision,v_filename,v_description,v_mime_type,v_content_length,v_indb_p
        from cr_items i, cr_revisions r
        where r.item_id = i.item_id
        and   r.revision_id = i.live_revision
        and   i.item_id = copy_file__file_id;

        -- We should probably use the copy functions of CR
        -- when we optimize this function
        v_new_file_id := file_storage__new_file(
                             v_name,                     -- name
                             copy_file__target_folder_id, -- folder_id
                             copy_file__creation_user,    -- creation_user
                             copy_file__creation_ip,      -- creation_ip
                             v_indb_p                     -- indb_p
                             );

        v_new_version_id := file_storage__new_version (
                             v_filename,                  -- title
                             v_description,               -- description
                             v_mime_type,                 -- mime_type
                             v_new_file_id,               -- item_id
                             copy_file__creation_user,    -- creation_user
                             copy_file__creation_ip       -- creation_ip
                             );
                             
        if v_indb_p
        then

                -- Lob to copy from
                select lob into v_lob_id
                from cr_revisions
                where revision_id = v_live_revision;

                -- New lob id
                v_new_lob_id := empty_lob();

                -- copy the blob
                perform lob_copy(v_lob_id,v_new_lob_id);

                -- Update the lob id on the new version
                update cr_revisions
                set lob = v_new_lob_id,
                    content_length = v_content_length
                where revision_id = v_new_version_id;

        else

                -- For now, we simply copy the file name
                select content into v_file_path
                from cr_revisions
                where revision_id = v_live_revision;

                -- Update the file path
                update cr_revisions
                set content = v_file_path,
                    content_length = v_content_length
                where revision_id = v_new_version_id;

        end if;

        perform acs_object__update_last_modified(copy_file__target_folder_id,copy_file__creation_user,copy_file__creation_ip);

        return v_new_version_id;

end;$_$;


--
-- Name: file_storage__delete_file(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__delete_file(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        delete_file__file_id    alias for $1;
begin

        return content_item__delete(delete_file__file_id);

end;$_$;


--
-- Name: file_storage__delete_folder(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__delete_folder(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$  -- 0 for success
declare
        delete_folder__folder_id        alias for $1; 
begin

        return file_storage__delete_folder(
                    delete_folder__folder_id,  -- folder_id
                    'f'
                    );

end;$_$;


--
-- Name: file_storage__delete_folder(integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__delete_folder(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$  -- 0 for success
declare
        delete_folder__folder_id        alias for $1; 
        delete_folder__cascade_p        alias for $2;
begin

        return content_folder__delete(
                    delete_folder__folder_id,  -- folder_id
                    delete_folder__cascade_p
                    );

end;$_$;


--
-- Name: file_storage__delete_version(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__delete_version(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ -- cr_items.parent_id%TYPE
declare
        delete_version__file_id         alias for $1;
        delete_version__version_id      alias for $2;
        v_parent_id                     cr_items.parent_id%TYPE;
        v_deleted_last_version_p        boolean;
begin

        if delete_version__version_id = content_item__get_live_revision(delete_version__file_id) 
        then
            PERFORM content_revision__delete(delete_version__version_id);
            PERFORM content_item__set_live_revision(
                        content_item__get_latest_revision(delete_version__file_id)
                        );
        else
            PERFORM content_revision__delete(delete_version__version_id);
        end if;

        -- If the live revision is null, we have deleted the last version above
        select (case when live_revision is null
                     then parent_id
                     else 0
                end)
          into v_parent_id 
        from cr_items
        where item_id = delete_version__file_id;

        -- Unfortunately, due to PostgreSQL behavior with regards referential integrity,
        -- we cannot delete the content_item entry if there are no more revisions.
        return v_parent_id;

end;$_$;


--
-- Name: file_storage__get_content_type(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__get_content_type(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$  -- cr_items.content_type%TYPE
declare
        get_content_type__file_id       alias for $1;
begin
        return content_item__get_content_type(
                          get_content_type__file_id
                          );

end;$_$;


--
-- Name: file_storage__get_folder_name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__get_folder_name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$  -- cr_folders.label%TYPE 
declare
        get_folder_name__folder_id      alias for $1;
begin
        return content_folder__get_label(
                          get_folder_name__folder_id
                          );

end;$_$;


--
-- Name: file_storage__get_package_id(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__get_package_id(integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$          -- fs_root_folders.package_id%TYPE
declare
    get_package_id__item_id     alias for $1;
    v_package_id                fs_root_folders.package_id%TYPE;
    v_tree_sortkey              cr_items.tree_sortkey%TYPE;
begin

    select fs_root_folders.package_id
    into v_package_id
    from fs_root_folders,
        (select cr_items.item_id 
           from (select tree_ancestor_keys(cr_items_get_tree_sortkey(get_package_id__item_id)) as tree_sortkey) parents,
             cr_items
          where cr_items.tree_sortkey = parents.tree_sortkey) this
    where fs_root_folders.folder_id = this.item_id;

    if NOT FOUND then
        return null;
    else
        return v_package_id;
    end if;

end;$_$;


--
-- Name: file_storage__get_parent_id(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__get_parent_id(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ -- cr_items.item_id%TYPE
     declare 
         get_parent_id__item_id alias for $1;
         v_parent_id          cr_items.item_id%TYPE;
     begin

         select parent_id
         into v_parent_id
         from cr_items
         where item_id = get_parent_id__item_id;

       return v_parent_id;

end;$_$;


--
-- Name: file_storage__get_root_folder(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__get_root_folder(integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$  -- fs_root_folders.folder_id%TYPE 
declare
        get_root_folder__package_id  alias for $1;
        v_folder_id                  fs_root_folders.folder_id%TYPE;
begin
        select folder_id into v_folder_id 
        from fs_root_folders
        where package_id = get_root_folder__package_id;

        return v_folder_id;

end;$_$;


--
-- Name: file_storage__get_title(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__get_title(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ 
declare
  get_title__item_id                 alias for $1;  
  v_title                            cr_revisions.title%TYPE;
  v_content_type                     cr_items.content_type%TYPE;
begin
  
  select content_type into v_content_type 
  from cr_items 
  where item_id = get_title__item_id;

  if v_content_type = 'content_folder' 
  then
      select label into v_title 
      from cr_folders 
      where folder_id = get_title__item_id;
  else if v_content_type = 'content_symlink' 
       then
         select label into v_title from cr_symlinks 
         where symlink_id = get_title__item_id;
       else
         select title into v_title
         from cr_revisions, cr_items
         where revision_id=live_revision
	 and cr_items.item_id=get_title__item_id;
       end if;
  end if;

  return v_title;

end;$_$;


--
-- Name: file_storage__move_file(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__move_file(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$  -- 0 for success 
declare
        move_file__file_id              alias for $1;
        move_file__target_folder_id     alias for $2;
        move_file__creation_user        alias for $3;
        move_file__creation_ip          alias for $4;
begin

        perform content_item__move(
               move_file__file_id,              -- item_id
               move_file__target_folder_id      -- target_folder_id
               );

        perform acs_object__update_last_modified(move_file__target_folder_id,move_file__creation_user,move_file__creation_ip);

        return 0;
end;$_$;


--
-- Name: file_storage__move_file(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__move_file(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$  -- 0 for success 
declare
        move_file__file_id              alias for $1;
        move_file__target_folder_id     alias for $2;
        move_file__creation_user        alias for $3;
        move_file__creation_ip          alias for $4;
begin

        perform content_item__move(
               move_file__file_id,              -- item_id
               move_file__target_folder_id      -- target_folder_id
               );

        perform acs_object__update_last_modified(move_file__target_folder_id,move_file__creation_user,move_file__creation_ip);

        return 0;
end;$_$;


--
-- Name: file_storage__new_file(character varying, integer, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__new_file(character varying, integer, integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ -- cr_items.item_id%TYPE
declare
        new_file__name                  alias for $1;
        new_file__folder_id             alias for $2;
        new_file__user_id               alias for $3;
        new_file__creation_ip           alias for $4;
        new_file__indb_p                alias for $5;
begin

        return file_storage__new_file(
             new_file__name,
             new_file__folder_id,
             new_file__user_id,
             new_file__creation_ip,
             new_file__indb_p,
             null
        );

end;$_$;


--
-- Name: file_storage__new_file(character varying, integer, integer, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__new_file(character varying, integer, integer, character varying, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ -- cr_items.item_id%TYPE
declare
        new_file__name                  alias for $1;
        new_file__folder_id             alias for $2;
        new_file__user_id               alias for $3;
        new_file__creation_ip           alias for $4;
        new_file__indb_p                alias for $5;
        new_file__package_id            alias for $6;
begin
        return file_storage__new_file(
             new_file__name,            -- name
             new_file__folder_id,       -- parent_id
             new_file__user_id,         -- creation_user
             new_file__creation_ip,     -- creation_ip
             new_file__indb_p,          -- storage_type
             null,                      -- item_id
             new_file__package_id       -- pacakge_id
        );

end;$_$;


--
-- Name: file_storage__new_file(character varying, integer, integer, character varying, boolean, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__new_file(character varying, integer, integer, character varying, boolean, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ -- cr_items.item_id%TYPE
declare
        new_file__name                 alias for $1;
        new_file__folder_id             alias for $2;
        new_file__user_id               alias for $3;
        new_file__creation_ip           alias for $4;
        new_file__indb_p                alias for $5;
        new_file__item_id               alias for $6;
        new_file__package_id            alias for $7;
        v_item_id                       integer;
begin

        if new_file__indb_p
        then 
            v_item_id := content_item__new (
                        new_file__name,            -- name
                        new_file__folder_id,      -- parent_id
                        new_file__item_id,        -- item_id (default)
                        null,                       -- locale (default)
                        now(),              -- creation_date (default)
                        new_file__user_id,        -- creation_user
                        new_file__folder_id,      -- context_id
                        new_file__creation_ip,    -- creation_ip
                        'content_item',         -- item_subtype (default)
                        'file_storage_object',  -- content_type (needed by site-wide search)
                        null,                       -- title (default)
                        null,                       -- description
                        'text/plain',     -- mime_type (default)
                        null,                       -- nls_language (default)
                        null,                       -- data (default)
                        new_file__package_id        -- package_id
                    );
        else
            v_item_id := content_item__new (
                        new_file__name,            -- name
                        new_file__folder_id,        -- parent_id
                        new_file__item_id,          -- item_id (default)
                        null,                       -- locale (default)
                        now(),              -- creation_date (default)
                        new_file__user_id,          -- creation_user
                        new_file__folder_id,        -- context_id
                        new_file__creation_ip,    -- creation_ip
                        'content_item',         -- item_subtype (default)
                        'file_storage_object',  -- content_type (needed by site-wide search)
                        null,                       -- title (default)
                        null,                       -- description
                        'text/plain',     -- mime_type (default)
                        null,                       -- nls_language (default)
                        null,                       -- text (default)
                        'file',                   -- storage_type
                        new_file__package_id        -- package_id
                    );

        end if;

        perform acs_object__update_last_modified(new_file__folder_id,new_file__user_id,new_file__creation_ip);

        return v_item_id;

end;$_$;


--
-- Name: file_storage__new_folder(character varying, character varying, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__new_folder(character varying, character varying, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$  -- cr_folders.folder_id%TYPE
declare
        new_folder__name              alias for $1;
        new_folder__folder_name       alias for $2;
        new_folder__parent_id         alias for $3;
        new_folder__creation_user     alias for $4;
        new_folder__creation_ip       alias for $5;
        v_folder_id                   cr_folders.folder_id%TYPE;
begin

        -- Create a new folder
        v_folder_id := content_folder__new (
                            new_folder__name,           -- name
                            new_folder__folder_name,    -- label
                            null,                       -- description
                            new_folder__parent_id,      -- parent_id
                            null,                       -- context_id (default)
                            null,                       -- folder_id (default)
                            now(),                      -- creation_date
                            new_folder__creation_user,  -- creation_user
                            new_folder__creation_ip     -- creation_ip
                            );

        -- register the standard content types
        -- JS: Note that we need to set include_subtypes 
        -- JS: to true since we created a new subtype.
        PERFORM content_folder__register_content_type(
                        v_folder_id,            -- folder_id
                        'content_revision',   -- content_type
                        't');                 -- include_subtypes (default)

        PERFORM content_folder__register_content_type(
                        v_folder_id,            -- folder_id
                        'content_folder',     -- content_type
                        't'                   -- include_subtypes (default)
                        );                      

        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_extlink',    -- content_types
                't'                   -- include_subtypes 
                );

        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_symlink',    -- content_types
                't'                   -- include_subtypes 
                );

        -- Give the creator admin privileges on the folder
        PERFORM acs_permission__grant_permission (
                     v_folder_id,                -- object_id
                     new_folder__creation_user,  -- grantee_id
                     'admin'                   -- privilege
                     );

        return v_folder_id;

end;$_$;


--
-- Name: file_storage__new_root_folder(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__new_root_folder(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$    --  fs_root_folders.folder_id%TYPE
declare
        new_root_folder__package_id         alias for $1;
        new_root_folder__folder_name        alias for $2;
        new_root_folder__description        alias for $3;
        v_folder_id                         fs_root_folders.folder_id%TYPE;
        v_package_name                      apm_packages.instance_name%TYPE;
        v_package_key                       apm_packages.package_key%TYPE;
        v_folder_name                       cr_folders.label%TYPE;
        v_description                       cr_folders.description%TYPE;
begin

        select instance_name, package_key 
        into v_package_name, v_package_key
        from apm_packages
        where package_id = new_root_folder__package_id;

        if new_root_folder__folder_name is null
        then
            v_folder_name := v_package_name || ' Root Folder ';
        else
            v_folder_name := new_root_folder__folder_name;
        end if;

        if new_root_folder__description is null
        then
            v_description := 'Root folder for the file-storage system.  All other folders in file storage are subfolders of this one.';
        else
            v_description := new_root_folder__description;
        end if;

        v_folder_id := content_folder__new (
            v_package_key || '_' || new_root_folder__package_id, -- name
            v_folder_name, -- label
            v_description, -- description
            null                                  -- parent_id (default)
        );

        insert into fs_root_folders 
        (package_id, folder_id)
        values 
        (new_root_folder__package_id, v_folder_id);

        -- allow child items to be added
        -- JS: Note that we need to set include_subtypes to 
        -- JS: true since we created a new subtype.
        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_revision',   -- content_types
                't'                   -- include_subtypes 
                );
        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_folder',     -- content_types
                't'                   -- include_subtypes 
                );

        -- set up default permissions
        PERFORM acs_permission__grant_permission (
                v_folder_id,                          -- object_id
                acs__magic_object_id('the_public'), -- grantee_id 
                'read'                              -- privilege
                );

        PERFORM acs_permission__grant_permission (
                v_folder_id,                                -- object_id 
                acs__magic_object_id('registered_users'), -- grantee_id
                'write'                                   -- privilege
                );

        return v_folder_id;

end;$_$;


--
-- Name: file_storage__new_root_folder(integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__new_root_folder(integer, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$    --  fs_root_folders.folder_id%TYPE
declare
        new_root_folder__package_id         alias for $1;
        new_root_folder__folder_name        alias for $2;
	new_root_folder__url	            alias for $3;
        new_root_folder__description        alias for $4;
        v_folder_id                         fs_root_folders.folder_id%TYPE;
begin


        v_folder_id := content_folder__new (
            new_root_folder__url, -- name
            new_root_folder__folder_name, -- label
	    new_root_folder__description, -- description
            null,  -- parent_id (default)
	    new_root_folder__package_id, --context_id
	    null, --folder_id
	    null, --creation_date
	    null, --creation_user
	    null, --creation_ip
            new_root_folder__package_id --package_id
	);

        insert into fs_root_folders 
        (package_id, folder_id)
        values 
        (new_root_folder__package_id, v_folder_id);

        -- allow child items to be added
        -- JS: Note that we need to set include_subtypes to 
        -- JS: true since we created a new subtype.
        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_revision',   -- content_types
                't'                   -- include_subtypes 
                );
        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_folder',     -- content_types
                't'                   -- include_subtypes 
                );
        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_symlink',    -- content_types
                't'                   -- include_subtypes 
                );
        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_extlink',    -- content_types
                't'                   -- include_subtypes 
                );

        return v_folder_id;

end;$_$;


--
-- Name: file_storage__new_version(character varying, character varying, character varying, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__new_version(character varying, character varying, character varying, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$  -- cr_revisions.revision_id 
declare
        new_version__filename           alias for $1;
        new_version__description        alias for $2;
        new_version__mime_type          alias for $3;
        new_version__item_id            alias for $4;
        new_version__creation_user      alias for $5;
        new_version__creation_ip        alias for $6;
        v_revision_id                   cr_revisions.revision_id%TYPE;
        v_folder_id                     cr_items.parent_id%TYPE;
begin
        -- Create a revision
        v_revision_id := content_revision__new (
                          new_version__filename,        -- title
                          new_version__description,     -- description
                          now(),                        -- publish_date
                          new_version__mime_type,       -- mime_type
                          null,                         -- nls_language
                          null,                         -- data (default)
                          new_version__item_id,         -- item_id
                          null,                         -- revision_id
                          now(),                        -- creation_date
                          new_version__creation_user,   -- creation_user
                          new_version__creation_ip      -- creation_ip
                          );

        -- Make live the newly created revision
        perform content_item__set_live_revision(v_revision_id);

        select cr_items.parent_id
        into v_folder_id
        from cr_items
        where cr_items.item_id = new_version__item_id;

        perform acs_object__update_last_modified(v_folder_id,new_version__creation_user,new_version__creation_ip);
	perform acs_object__update_last_modified(new_version__item_id,new_version__creation_user,new_version__creation_ip);
	return v_revision_id;

end;$_$;


--
-- Name: file_storage__rename_file(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION file_storage__rename_file(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        rename_file__file_id    alias for $1;
        rename_file__name      alias for $2;

begin

        return content_item__edit_name(
               rename_file__file_id,  -- item_id
               rename_file__name     -- name
               );

end;$_$;


--
-- Name: forums_forum__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_forum__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_forum_id                      alias for $1;
begin
    perform acs_object__delete(p_forum_id);
    return 0;
end;
$_$;


--
-- Name: forums_forum__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_forum__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_forum_id                      alias for $1;
begin
    return name from forums_forums where forum_id = p_forum_id;
end;
$_$;


--
-- Name: forums_forum__new(integer, character varying, character varying, character varying, character varying, character varying, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_forum__new(integer, character varying, character varying, character varying, character varying, character varying, integer, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_forum_id                      alias for $1;
    p_object_type                   alias for $2;
    p_name                          alias for $3;
    p_charter                       alias for $4;
    p_presentation_type             alias for $5;
    p_posting_policy                alias for $6;
    p_package_id                    alias for $7;
    p_creation_date                 alias for $8;
    p_creation_user                 alias for $9;
    p_creation_ip                   alias for $10;
    p_context_id                    alias for $11;
    v_forum_id                      integer;
begin
    v_forum_id:= acs_object__new(
        p_forum_id,
        p_object_type,
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        coalesce(p_context_id, p_package_id),
        't',
        p_name,
        p_package_id
    );

    insert into forums_forums
    (forum_id, name, charter, presentation_type, posting_policy, package_id)
    values
    (v_forum_id, p_name, p_charter, p_presentation_type, p_posting_policy, p_package_id);

    return v_forum_id;
end;
$_$;


--
-- Name: forums_mess_insert_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_mess_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
    v_max_child_sortkey             forums_forums.max_child_sortkey%TYPE;
    v_parent_sortkey                forums_messages.tree_sortkey%TYPE;
begin

    if new.parent_id is null
    then

        select '', max_child_sortkey
        into v_parent_sortkey, v_max_child_sortkey
        from forums_forums
        where forum_id = new.forum_id
        for update;

        v_max_child_sortkey := tree_increment_key(v_max_child_sortkey);

        update forums_forums
        set max_child_sortkey = v_max_child_sortkey
        where forum_id = new.forum_id;

    else

        select coalesce(tree_sortkey, ''), max_child_sortkey
        into v_parent_sortkey, v_max_child_sortkey
        from forums_messages
        where message_id = new.parent_id
        for update;

        v_max_child_sortkey := tree_increment_key(v_max_child_sortkey);

        update forums_messages
        set max_child_sortkey = v_max_child_sortkey
        where message_id = new.parent_id;

    end if;

    new.tree_sortkey := v_parent_sortkey || v_max_child_sortkey;

    return new;
end;$$;


--
-- Name: forums_message__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_message__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_message_id      alias for $1;    
  v_cur             record;
begin

  -- Maintain the forum thread counts

  select into v_cur *
  from forums_messages
  where message_id = p_message_id;

  if v_cur.parent_id is null then
    if v_cur.state = 'approved' then
      update forums_forums
      set thread_count = thread_count - 1,
        approved_thread_count = approved_thread_count - 1
      where forum_id=v_cur.forum_id;
    else
      update forums_forums
      set thread_count = thread_count - 1
      where forum_id=v_cur.forum_id;
    end if;
  elsif v_cur.state = 'approved' then
    update forums_messages
    set approved_reply_count = approved_reply_count - 1,
      reply_count = reply_count - 1
    where message_id = forums_message__root_message_id(v_cur.message_id);
  else
    update forums_messages
    set reply_count = reply_count - 1
    where message_id = forums_message__root_message_id(v_cur.message_id);
  end if;

  perform acs_object__delete(p_message_id);
  return 0;
end;$_$;


--
-- Name: forums_message__delete_thread(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_message__delete_thread(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id                    alias for $1;
    v_forum_id                      forums_messages.forum_id%TYPE;
    v_sortkey                       forums_messages.tree_sortkey%TYPE;
    v_message                       RECORD;
begin
    select forum_id, tree_sortkey
    into v_forum_id, v_sortkey
    from forums_messages
    where message_id = p_message_id;
           
    -- if it is already deleted
    if v_forum_id is null
    then return 0;
    end if;

    -- delete all children
    -- order by tree_sortkey desc to guarantee
    -- that we never delete a parent before its child
    -- sortkeys are beautiful
    for v_message in select *
                     from forums_messages
                     where forum_id = v_forum_id
                     and tree_sortkey between tree_left(v_sortkey) and tree_right(v_sortkey)
                     order by tree_sortkey desc
    loop
        -- Avoid the count bookkeeping down in forums_message__delete
        perform forums_message__delete(v_message.message_id);
    end loop;

    -- delete the message itself
    perform forums_message__delete(p_message_id);

    return 0;
end;$_$;


--
-- Name: forums_message__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_message__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id                    alias for $1;
begin
    return subject from forums_messages where message_id = p_message_id;
end;
$_$;


--
-- Name: forums_message__new(integer, character varying, integer, character varying, text, character, integer, character varying, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_message__new(integer, character varying, integer, character varying, text, character, integer, character varying, integer, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id                    alias for $1;
    p_object_type                   alias for $2;
    p_forum_id                      alias for $3;
    p_subject                       alias for $4;
    p_content                       alias for $5;
    p_format                        alias for $6;
    p_user_id                       alias for $7;
    p_state                         alias for $8;
    p_parent_id                     alias for $9;
    p_creation_date                 alias for $10;
    p_creation_user                 alias for $11;
    p_creation_ip                   alias for $12;
    p_context_id                    alias for $13;
    v_message_id                    integer;
    v_forum_policy                  forums_forums.posting_policy%TYPE;
    v_state                         forums_messages.state%TYPE;
    v_posting_date                  forums_messages.posting_date%TYPE;
    v_package_id                    acs_objects.package_id%TYPE;
begin

    select package_id into v_package_id from forums_forums where forum_id = p_forum_id;

    if v_package_id is null then
        raise exception 'forums_message__new: forum_id % not found', p_forum_id;
    end if;

    v_message_id := acs_object__new(
        p_message_id,
        p_object_type,
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        coalesce(p_context_id, p_forum_id),
        't',
        p_subject,
        v_package_id
    );

    if p_state is null then
        select posting_policy
        into v_forum_policy
        from forums_forums
        where forum_id = p_forum_id;

        if v_forum_policy = 'moderated'
        then v_state := 'pending';
        else v_state := 'approved';
        end if;
    else
        v_state := p_state;
    end if;

    insert into forums_messages
    (message_id, forum_id, subject, content, format, user_id, parent_id, state, last_child_post, last_poster)
    values
    (v_message_id, p_forum_id, p_subject, p_content, p_format, p_user_id, p_parent_id,
     v_state, current_timestamp, p_user_id);

    update forums_forums
    set last_post = current_timestamp
    where forum_id = p_forum_id;

    if p_parent_id is null then
      if v_state = 'approved' then
        update forums_forums
        set thread_count = thread_count + 1,
          approved_thread_count = approved_thread_count + 1
        where forum_id=p_forum_id;
      else
        update forums_forums
        set thread_count = thread_count + 1
        where forum_id=p_forum_id;
      end if;
    else
      if v_state = 'approved' then
        update forums_messages
        set approved_reply_count = approved_reply_count + 1,
          reply_count = reply_count + 1,
          last_poster = p_user_id,
          last_child_post = current_timestamp
        where message_id = forums_message__root_message_id(v_message_id);
      else
        -- dont update last_poster, last_child_post when not approved
        update forums_messages
        set reply_count = reply_count + 1
        where message_id = forums_message__root_message_id(v_message_id);
      end if;
    end if;

    return v_message_id;

end;$_$;


--
-- Name: forums_message__new(integer, character varying, integer, character varying, text, character, integer, timestamp with time zone, character varying, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_message__new(integer, character varying, integer, character varying, text, character, integer, timestamp with time zone, character varying, integer, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id                    alias for $1;
    p_object_type                   alias for $2;
    p_forum_id                      alias for $3;
    p_subject                       alias for $4;
    p_content                       alias for $5;
    p_html_p                        alias for $6;
    p_user_id                       alias for $7;
    p_posting_date                  alias for $8;
    p_state                         alias for $9;
    p_parent_id                     alias for $10;
    p_creation_date                 alias for $11;
    p_creation_user                 alias for $12;
    p_creation_ip                   alias for $13;
    p_context_id                    alias for $14;
    v_message_id                    integer;
    v_forum_policy                  forums_forums.posting_policy%TYPE;
    v_state                         forums_messages.state%TYPE;
    v_posting_date                  forums_messages.posting_date%TYPE;
    v_package_id                    acs_objects.package_id%TYPE;
begin

    select package_id into v_package_id from forums_forums where forum_id = p_forum_id;

    if v_package_id is null then
        raise exception 'forums_message__new: forum_id % not found', p_forum_id;
    end if;

    v_message_id := acs_object__new(
        p_message_id,
        p_object_type,
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        coalesce(p_context_id, p_forum_id),
        't',
        p_subject,
        v_package_id
    );

    if p_state is null then
        select posting_policy
        into v_forum_policy
        from forums_forums
        where forum_id = p_forum_id;
             
        if v_forum_policy = 'moderated'
        then v_state := 'pending';
        else v_state := 'approved';
        end if;
    else
        v_state := p_state;
    end if;

    if p_posting_date is null then
        v_posting_date = now();
    else
        v_posting_date = p_posting_date;
    end if;

    insert into forums_messages
    (message_id, forum_id, subject, content, html_p, user_id, posting_date, parent_id, state)
    values
    (v_message_id, p_forum_id, p_subject, p_content, p_html_p, p_user_id, v_posting_date, p_parent_id, v_state);

    update forums_forums
    set last_post = v_posting_date
    where forum_id = p_forum_id;

    update forums_messages
    set last_child_post = v_posting_date
    where message_id = forums_message__root_message_id(v_message_id);
 
    return v_message_id;

end;
$_$;


--
-- Name: forums_message__root_message_id(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_message__root_message_id(integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
    p_message_id                    alias for $1;
    v_message_id                    forums_messages.message_id%TYPE;
    v_forum_id                      forums_messages.forum_id%TYPE;
    v_sortkey                       forums_messages.tree_sortkey%TYPE;
begin
    select forum_id, tree_sortkey
    into v_forum_id, v_sortkey
    from forums_messages
    where message_id = p_message_id;

    select message_id
    into v_message_id
    from forums_messages
    where forum_id = v_forum_id
    and tree_sortkey = tree_ancestor_key(v_sortkey, 1);

    return v_message_id;
end;
$_$;


--
-- Name: forums_message__set_state(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_message__set_state(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_message_id      alias for $1;
  p_state           alias for $2;
  v_cur             record;
begin

  select into v_cur *
  from forums_messages
  where message_id = p_message_id;

  if v_cur.parent_id is null then
    if p_state = 'approved' and v_cur.state <> 'approved' then
      update forums_forums
      set approved_thread_count = approved_thread_count + 1
      where forum_id=v_cur.forum_id;
    elsif p_state <> 'approved' and v_cur.state = 'approved' then
      update forums_forums
      set approved_thread_count = approved_thread_count - 1
      where forum_id=v_cur.forum_id;
    end if;
  else
    if p_state = 'approved' and v_cur.state <> 'approved' then
      update forums_messages
      set approved_reply_count = approved_reply_count + 1, 
        last_poster = (case when v_cur.posting_date > last_child_post then v_cur.user_id else last_poster end),
        last_child_post = (case when v_cur.posting_date > last_child_post then v_cur.posting_date else last_child_post end)
      where message_id = forums_message__root_message_id(v_cur.message_id);
    elsif p_state <> 'approved' and v_cur.state = 'approved' then
      update forums_messages
      set approved_reply_count = approved_reply_count - 1
      where message_id = forums_message__root_message_id(v_cur.message_id);
    end if;
  end if;

  update forums_messages
  set state = p_state
  where message_id = p_message_id;

  return 0;

end;$_$;


--
-- Name: forums_message__thread_close(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_message__thread_close(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id                    alias for $1;
    v_forum_id                      forums_messages.forum_id%TYPE;
    v_sortkey                       forums_messages.tree_sortkey%TYPE;
begin
    select forum_id, tree_sortkey
    into v_forum_id, v_sortkey
    from forums_messages
    where message_id = p_message_id;

    update forums_messages
    set open_p = 'f'
    where tree_sortkey between tree_left(v_sortkey) and tree_right(v_sortkey)
    and forum_id = v_forum_id;

    update forums_messages
    set open_p = 'f'
    where message_id = p_message_id;

    return 0;
end;
$_$;


--
-- Name: forums_message__thread_open(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forums_message__thread_open(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_message_id                    alias for $1;
    v_forum_id                      forums_messages.forum_id%TYPE;
    v_sortkey                       forums_messages.tree_sortkey%TYPE;
begin
    select forum_id, tree_sortkey
    into v_forum_id, v_sortkey
    from forums_messages
    where message_id = p_message_id;

    update forums_messages
    set open_p = 't'
    where tree_sortkey between tree_left(v_sortkey) and tree_right(v_sortkey)
    and forum_id = v_forum_id;

    update forums_messages
    set open_p = 't'
    where message_id = p_message_id;

    return 0;
end;
$_$;


--
-- Name: fs_package_items_delete_trig(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fs_package_items_delete_trig() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare

        v_rec   record;
begin

        for v_rec in
        
                -- We want to delete all cr_items entries, starting from the leaves all
                --  the way up the root folder (old.folder_id).
                select c1.item_id, c1.content_type
                from cr_items c1, cr_items c2
                where c2.item_id = old.folder_id
                  and c1.tree_sortkey between c2.tree_sortkey and tree_right(c2.tree_sortkey)
                  and c1.item_id <> old.folder_id
                order by c1.tree_sortkey desc
        loop

                -- DRB: Why can't we just use object delete here?


                -- We delete the item. On delete cascade should take care
                -- of deletion of revisions.
                if v_rec.content_type = 'file_storage_object'
                then
                    raise notice 'Deleting item_id = %',v_rec.item_id;
                    PERFORM content_item__delete(v_rec.item_id);
                end if;

                -- Instead of doing an if-else, we make sure we are deleting a folder.
                if v_rec.content_type = 'content_folder'
                then
                    raise notice 'Deleting folder_id = %',v_rec.item_id;
                    PERFORM content_folder__delete(v_rec.item_id);
                end if;

                -- Instead of doing an if-else, we make sure we are deleting a folder.
                if v_rec.content_type = 'content_symlink'
                then
                    raise notice 'Deleting symlink_id = %',v_rec.item_id;
                    PERFORM content_symlink__delete(v_rec.item_id);
                end if;

                -- Instead of doing an if-else, we make sure we are deleting a folder.
                if v_rec.content_type = 'content_extlink'
                then
                    raise notice 'Deleting folder_id = %',v_rec.item_id;
                    PERFORM content_extlink__delete(v_rec.item_id);
                end if;

        end loop;

        -- We need to return something for the trigger to be activated
        return old;

end;$$;


--
-- Name: fs_root_folder_delete_trig(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fs_root_folder_delete_trig() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	PERFORM content_folder__delete(old.folder_id);
	return null;

end;$$;


--
-- Name: fs_simple_object__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fs_simple_object__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_object_id             alias for $1;
BEGIN
        PERFORM acs_object__delete(p_object_id);

        return 0;
END;
$_$;


--
-- Name: fs_simple_object__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fs_simple_object__name(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id                     alias for $1;
begin
    return name
    from fs_simple_objects
    where object_id = p_object_id;
end;
$_$;


--
-- Name: fs_simple_object__new(integer, character varying, integer, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fs_simple_object__new(integer, character varying, integer, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_object_id             alias for $1;
        p_object_type           alias for $2;
        p_folder_id             alias for $3;
        p_name                  alias for $4;
        p_description           alias for $5;
        p_creation_date         alias for $6;
        p_creation_user         alias for $7;
        p_creation_ip           alias for $8;
        p_context_id            alias for $9;
        v_object_id             integer;
BEGIN
        v_object_id:= acs_object__new (
              p_object_id,
              p_object_type,
              p_creation_date,
              p_creation_user,
              p_creation_ip,
              p_context_id
        );

        insert into fs_simple_objects
        (object_id, folder_id, name, description) values
        (v_object_id, p_folder_id, p_name, p_description);

        PERFORM acs_object__update_last_modified(p_folder_id);

        return v_object_id;

END;
$_$;


--
-- Name: fs_url__copy(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fs_url__copy(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_url_id                alias for $1;
        p_target_folder_id      alias for $2;
        v_new_url_id            integer;
        v_url                   varchar;
        v_name                  varchar;
        v_description           varchar;
        v_creation_user         integer;
        v_creation_ip           varchar;
BEGIN
        select url
        into v_url
        from fs_urls
        where url_id = p_url_id;

        select name
        into v_name
        from fs_simple_objects
        where object_id = p_url_id;

        select description
        into v_description
        from fs_simple_objects
        where object_id = p_url_id;

        select creation_user
        into v_creation_user
        from acs_objects
        where object_id = p_url_id;

        select creation_ip
        into v_creation_ip
        from acs_objects
        where object_id = p_url_id;

        v_new_url_id:= fs_url__new (
            NULL,
            'fs_url',
            v_url,
            p_target_folder_id,
            v_name,
            v_description,
            NULL,
            v_creation_user,
            v_creation_ip,
            p_target_folder_id
        );

        return v_new_url_id;
END;
$_$;


--
-- Name: fs_url__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fs_url__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_url_id                alias for $1;
BEGIN
        delete from fs_urls where url_id= p_url_id;

        PERFORM fs_simple_object__delete(p_url_id);

        return 0;
END;
$_$;


--
-- Name: fs_url__new(integer, character varying, character varying, integer, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fs_url__new(integer, character varying, character varying, integer, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_url_id                alias for $1;
        p_object_type           alias for $2;
        p_url                   alias for $3;
        p_folder_id             alias for $4;
        p_name                  alias for $5;
        p_description           alias for $6;
        p_creation_date         alias for $7;
        p_creation_user         alias for $8;
        p_creation_ip           alias for $9;
        p_context_id            alias for $10;
        v_url_id                integer;
BEGIN
        v_url_id:= fs_simple_object__new (
            p_url_id,
            p_object_type,
            p_folder_id,
            p_name,
            p_description,
            p_creation_date,
            p_creation_user,
            p_creation_ip,
            p_context_id
        );

        insert into fs_urls
        (url_id, url) values
        (v_url_id, p_url);

        return v_url_id;
END;
$_$;


--
-- Name: get_func_definition(character varying, oidvector); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_func_definition(character varying, oidvector) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
        fname           alias for $1;
        args            alias for $2;
        nargs           integer default 0;
        v_pos           integer;
        v_funcdef       text default '';
        v_args          varchar;
        v_one_arg       varchar;
        v_one_type      varchar;
        v_nargs         integer;
        v_src           text;
        v_rettype       varchar;
begin
        select proargtypes, pronargs, number_src(prosrc), 
               (select typname from pg_type where oid = p.prorettype)
          into v_args, v_nargs, v_src, v_rettype
          from pg_proc p 
         where proname = fname::name
           and proargtypes = args;

         v_funcdef := v_funcdef || '
create function ' || fname || '(';

         v_pos := position(' ' in v_args);

         while nargs < v_nargs loop
             nargs := nargs + 1;
             if nargs = v_nargs then 
                 v_one_arg := v_args;
                 v_args    := '';
             else
                 v_one_arg := substr(v_args, 1, v_pos - 1);
                 v_args    := substr(v_args, v_pos + 1);
                 v_pos     := position(' ' in v_args);            
             end if;
             select case when nargs = 1 
                           then typname 
                           else ',' || typname 
                         end into v_one_type 
               from pg_type 
              where oid = v_one_arg;
             v_funcdef := v_funcdef || v_one_type;
         end loop;
         v_funcdef := v_funcdef || ') returns ' || v_rettype || ' as \'\n' || v_src || '\' language \'plpgsql\';';

        return v_funcdef;

end;$_$;


--
-- Name: get_func_drop_command(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_func_drop_command(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
        fname           alias for $1;
        nargs           integer default 0;
        v_pos           integer;
        v_funcdef       text;
        v_args          varchar;
        v_one_arg       varchar;
        v_one_type      varchar;
        v_nargs         integer;
begin
        v_funcdef := 'drop function ' || fname || '(';

        select proargtypes, pronargs
          into v_args, v_nargs
          from pg_proc 
         where proname = fname::name;

        v_pos := position(' ' in v_args);
        
        while nargs < v_nargs loop
              nargs := nargs + 1;
              if nargs = v_nargs then 
                 v_one_arg := v_args;
                 v_args    := '';
              else
                 v_one_arg := substr(v_args, 1, v_pos - 1);
                 v_args    := substr(v_args, v_pos + 1);
                 v_pos     := position(' ' in v_args);            
              end if;
              select case when nargs = 1 
                            then typname 
                            else ',' || typname 
                          end into v_one_type 
                from pg_type 
               where oid = v_one_arg;
              v_funcdef := v_funcdef || v_one_type;            
        end loop;
        v_funcdef := v_funcdef || ')';

        return v_funcdef;

end;$_$;


--
-- Name: get_func_header(character varying, oidvector); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_func_header(character varying, oidvector) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
        fname   alias for $1;
        args    alias for $2;
        v_src   text;
        pos     integer;
begin
        v_src := get_func_definition(fname,args);
        pos := position('begin' in lower(v_src));

        return substr(v_src, 1, pos + 4);

end;$_$;


--
-- Name: group_contains_p(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION group_contains_p(integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare 
        group_contains_p__group_id        alias for $1;
        group_contains_p__component_id    alias for $2;
        group_contains_p__rel_id          alias for $3;
        map                               record;
begin
  if group_contains_p__group_id = group_contains_p__component_id then
    return 't';
  else
    if group_contains_p__rel_id is null then
      for map in  select *
                  from group_component_map
                  where component_id = group_contains_p__component_id
                  and group_id = container_id 
      LOOP
        if group_contains_p(group_contains_p__group_id, map.group_id, null) = 't' then
          return 't';
        end if;
      end loop;
    else
      for map in  select *
                  from group_component_map
                  where component_id = group_contains_p__component_id
                  and rel_id = group_contains_p__rel_id
                  and group_id = container_id 
      LOOP
        if group_contains_p(group_contains_p__group_id, map.group_id, null) = 't' then
          return 't';
        end if;
      end loop;
    end if;
    return 'f';
  end if;
end;$_$;


--
-- Name: image__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION image__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  v_item_id		alias for $1;
begin

    -- This should take care of deleting revisions, too.
    PERFORM content_item__delete (v_item_id);
    return 0;

end; $_$;


--
-- Name: image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, boolean, timestamp with time zone, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, boolean, timestamp with time zone, character varying, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    new__name		alias for $1;
    new__parent_id	alias for $2; -- default null
    new__item_id	alias for $3; -- default null
    new__revision_id	alias for $4; -- default null
    new__mime_type	alias for $5; -- default jpeg
    new__creation_user  alias for $6; -- default null
    new__creation_ip    alias for $7; -- default null
    new__relation_tag	alias for $8; -- default null
    new__title          alias for $9; -- default null
    new__description    alias for $10; -- default null
    new__is_live        alias for $11; -- default f
    new__publish_date	alias for $12; -- default now()
    new__path   	alias for $13; 
    new__file_size   	alias for $14; 
    new__height    	alias for $15;
    new__width		alias for $16; 
  begin
    return image__new(new__name,
                      new__parent_id,
                      new__item_id,
                      new__revision_id,
                      new__mime_type,
                      new__creation_user,
                      new__creation_ip,
                      new__relation_tag,
                      new__title,
                      new__description,
                      new__is_live,
                      new__publish_date,
                      new__path,
                      new__file_size,
                      new__height,
                      new__width,
                      null
    );
end; $_$;


--
-- Name: image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    p_name              alias for $1;
    p_parent_id         alias for $2; -- default null
    p_item_id           alias for $3; -- default null
    p_revision_id       alias for $4; -- default null
    p_mime_type         alias for $5; -- default jpeg
    p_creation_user     alias for $6; -- default null
    p_creation_ip       alias for $7; -- default null
    p_title             alias for $8; -- default null
    p_description       alias for $9; -- default null
    p_storage_type      alias for $10;
    p_content_type      alias for $11;
    p_nls_language      alias for $12;
    p_publish_date      alias for $13;
    p_height            alias for $14;
    p_width             alias for $15;
  begin
    return image__new(p_name,
                      p_parent_id,
                      p_item_id,
                      p_revision_id,
                      p_mime_type,
                      p_creation_user,
                      p_creation_ip,
                      p_title,
                      p_description,
                      p_storage_type,
                      p_content_type,
                      p_nls_language,
                      p_publish_date,
                      p_height,
                      p_width,
                      null
    );
end; $_$;


--
-- Name: image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, boolean, timestamp with time zone, character varying, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, boolean, timestamp with time zone, character varying, integer, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    new__name		alias for $1;
    new__parent_id	alias for $2; -- default null
    new__item_id	alias for $3; -- default null
    new__revision_id	alias for $4; -- default null
    new__mime_type	alias for $5; -- default jpeg
    new__creation_user  alias for $6; -- default null
    new__creation_ip    alias for $7; -- default null
    new__relation_tag	alias for $8; -- default null
    new__title          alias for $9; -- default null
    new__description    alias for $10; -- default null
    new__is_live        alias for $11; -- default f
    new__publish_date	alias for $12; -- default now()
    new__path   	alias for $13; 
    new__file_size   	alias for $14; 
    new__height    	alias for $15;
    new__width		alias for $16; 
    new__package_id     alias for $17; -- default null

    new__locale          varchar default null;
    new__nls_language	 varchar default null;
    new__creation_date	 timestamptz default current_timestamp;
    new__context_id      integer;	

    v_item_id		 cr_items.item_id%TYPE;
    v_package_id	 acs_objects.package_id%TYPE;
    v_revision_id	 cr_revisions.revision_id%TYPE;
  begin
    new__context_id := new__parent_id;

    if new__package_id is null then
      v_package_id := acs_object__package_id(new__parent_id);
    else
      v_package_id := new__package_id;
    end if;

    v_item_id := content_item__new (
      new__name,
      new__parent_id,
      new__item_id,
      new__locale,
      new__creation_date,
      new__creation_user,	
      new__context_id,
      new__creation_ip,
      'content_item',
      'image',
      null,
      new__description,
      new__mime_type,
      new__nls_language,
      null,
      'file', -- storage_type
      v_package_id
    );

    -- update cr_child_rels to have the correct relation_tag
    update cr_child_rels
    set relation_tag = new__relation_tag
    where parent_id = new__parent_id
    and child_id = new__item_id
    and relation_tag = content_item__get_content_type(new__parent_id) || '-' || 'image';

    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      null,
      v_item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip,
      v_package_id
    );

    insert into images
    (image_id, height, width)
    values
    (v_revision_id, new__height, new__width);

    -- update revision with image file info
    update cr_revisions
    set content_length = new__file_size,
    content = new__path
    where revision_id = v_revision_id;

    -- is_live => 't' not used as part of content_item.new
    -- because content_item.new does not let developer specify revision_id,
    -- revision_id is determined in advance 

    if new__is_live = 't' then
       PERFORM content_item__set_live_revision (v_revision_id);
    end if;

    return v_item_id;
end; $_$;


--
-- Name: image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    p_name              alias for $1;
    p_parent_id         alias for $2; -- default null
    p_item_id           alias for $3; -- default null
    p_revision_id       alias for $4; -- default null
    p_mime_type         alias for $5; -- default jpeg
    p_creation_user     alias for $6; -- default null
    p_creation_ip       alias for $7; -- default null
    p_title             alias for $8; -- default null
    p_description       alias for $9; -- default null
    p_storage_type      alias for $10;
    p_content_type      alias for $11;
    p_nls_language      alias for $12;
    p_publish_date      alias for $13;
    p_height            alias for $14;
    p_width             alias for $15;
    p_package_id        alias for $16; -- default null

    v_item_id		 cr_items.item_id%TYPE;
    v_revision_id	 cr_revisions.revision_id%TYPE;
    v_package_id	 acs_objects.package_id%TYPE;
  begin

     if content_item__is_subclass(p_content_type, 'image') = 'f' then
       raise EXCEPTION '-20000: image__new can only be called for an image type'; 
     end if;

    if p_package_id is null then
      v_package_id := acs_object__package_id(p_parent_id);
    else
      v_package_id := p_package_id;
    end if;

    v_item_id := content_item__new (
      p_name,
      p_parent_id,
      p_item_id,
      null,
      current_timestamp,
      p_creation_user,	
      p_parent_id,
      p_creation_ip,
      'content_item',
      p_content_type,
      null,
      null,
      null,
      null,
      null,
      p_storage_type,
      v_package_id
    );

    -- We will let the caller fill in the LOB data or file path.

    v_revision_id := content_revision__new (
      p_title,
      p_description,
      p_publish_date,
      p_mime_type,
      p_nls_language,
      null,
      v_item_id,
      p_revision_id,
      current_timestamp,
      p_creation_user,
      p_creation_ip,
      v_package_id
    );

    insert into images
    (image_id, height, width)
    values
    (v_revision_id, p_height, p_width);

    return v_item_id;
end; $_$;


--
-- Name: image__new_revision(integer, integer, character varying, character varying, timestamp with time zone, character varying, character varying, integer, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION image__new_revision(integer, integer, character varying, character varying, timestamp with time zone, character varying, character varying, integer, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
   p_item_id          alias for $1;
   p_revision_id      alias for $2;
   p_title            alias for $3;
   p_description      alias for $4;
   p_publish_date     alias for $5;
   p_mime_type        alias for $6;
   p_nls_language     alias for $7;
   p_creation_user    alias for $8;
   p_creation_ip      alias for $9;
   p_height           alias for $10;
   p_width            alias for $11;
   v_revision_id      integer;
begin
   return image__new_revision(p_item_id,
                              p_revision_id,
                              p_title,
                              p_description,
                              p_publish_date,
                              p_mime_type,
                              p_nls_language,
                              p_creation_user,
                              p_creation_ip,
                              p_height,
                              p_width,
                              p_revision_id,
                              null
   );

end;$_$;


--
-- Name: image__new_revision(integer, integer, character varying, character varying, timestamp with time zone, character varying, character varying, integer, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION image__new_revision(integer, integer, character varying, character varying, timestamp with time zone, character varying, character varying, integer, character varying, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
   p_item_id          alias for $1;
   p_revision_id      alias for $2;
   p_title            alias for $3;
   p_description      alias for $4;
   p_publish_date     alias for $5;
   p_mime_type        alias for $6;
   p_nls_language     alias for $7;
   p_creation_user    alias for $8;
   p_creation_ip      alias for $9;
   p_height           alias for $10;
   p_width            alias for $11;
   p_package_id       alias for $12;
   v_revision_id      integer;
   v_package_id       acs_objects.package_id%TYPE;
begin
    -- We will let the caller fill in the LOB data or file path.

    if p_package_id is null then
      v_package_id := acs_object__package_id(p_item_id);
    else
      v_package_id := p_package_id;
    end if;

    v_revision_id := content_revision__new (
      p_title,
      p_description,
      p_publish_date,
      p_mime_type,
      p_nls_language,
      null,
      p_item_id,
      p_revision_id,
      current_timestamp,
      p_creation_user,
      p_creation_ip,
      v_package_id
    );

    insert into images
    (image_id, height, width)
    values
    (v_revision_id, p_height, p_width);

    return v_revision_id;
end;$_$;


--
-- Name: instr(character varying, character, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION instr(character varying, character, integer, integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
        str             alias for $1;
        pat             alias for $2;
        dir             alias for $3;
        cnt             alias for $4;
        v_len           integer;
        v_i             integer;
        v_c             char;
        v_cnt           integer;
        v_inc           integer;
begin
        v_len := length(str);
        v_cnt := 0;
        
        if dir < 0 then
           v_inc := -1;
           v_i   := v_len;
        else 
           v_inc := 1;
           v_i   := 1;
        end if;
           
        while v_i > 0 and v_i <= v_len LOOP
          v_c := substr(str,v_i,1);
          if v_c::char = pat::char then 
            v_cnt := v_cnt + 1;
            if v_cnt = cnt then 
              return v_i;
            end if;
          end if;
          v_i := v_i + v_inc;
        end loop;

        return 0;

end;$_$;


--
-- Name: instr(character varying, character, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION instr(character varying, character, integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
        str             alias for $1;
        pat             alias for $2;
        dir             alias for $3;
begin
        return instr(str,pat,dir,1);
end;$_$;


--
-- Name: instr(character varying, character); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION instr(character varying, character) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
        str             alias for $1;
        pat             alias for $2;
begin
        return instr(str,pat,1,1);
end;$_$;


--
-- Name: int_to_tree_key(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION int_to_tree_key(integer) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$

-- Convert an integer into the bit string format used to store
-- tree sort keys.   Using 4 bytes for the long keys requires
-- using -2^31 rather than 2^31 to avoid a twos-complement 
-- "integer out of range" error in PG - if for some reason you
-- want to use a smaller value use positive powers of two!

-- There was an "out of range" check in here when I was using 15
-- bit long keys but the only check that does anything with the long
-- keys is to check for negative numbers.

declare
  p_intkey        alias for $1;
begin
  if p_intkey < 0 then
    raise exception 'int_to_tree_key: key must be a positive integer';
  end if;

  if p_intkey < 128 then
    return substring(bitfromint4(p_intkey), 25, 8);
  else
    return substring(bitfromint4(cast (-2^31 + p_intkey as int4)), 1, 32);
  end if;

end;$_$;


--
-- Name: journal_entry__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION journal_entry__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__journal_id             alias for $1;  
begin
	delete from journal_entries where journal_id = delete__journal_id;
	PERFORM acs_object__delete(delete__journal_id);

        return 0; 
end;$_$;


--
-- Name: journal_entry__delete_for_object(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION journal_entry__delete_for_object(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete_for_object__object_id          alias for $1;  
  journal_rec                           record;
begin
        for journal_rec in select journal_id 
                             from journal_entries 
                            where object_id = delete_for_object__object_id  
        LOOP
	    PERFORM journal_entry__delete(journal_rec.journal_id);
	end loop;

        return 0; 
end;$_$;


--
-- Name: journal_entry__new(integer, integer, character varying, character varying, timestamp with time zone, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION journal_entry__new(integer, integer, character varying, character varying, timestamp with time zone, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__journal_id             alias for $1;  -- default null  
  new__object_id              alias for $2;  
  new__action                 alias for $3;  
  new__action_pretty          alias for $4;  -- default null
  new__creation_date          alias for $5;  -- default now()
  new__creation_user          alias for $6;  -- default null
  new__creation_ip            alias for $7;  -- default null
  new__msg                    alias for $8;  -- default null
  v_journal_id                journal_entries.journal_id%TYPE;
begin
	v_journal_id := acs_object__new (
	  new__journal_id,
	  'journal_entry',
	  new__creation_date,
	  new__creation_user,
	  new__creation_ip,
	  new__object_id,
          't',
          new__action,
          null
	);

        insert into journal_entries (
            journal_id, object_id, action, action_pretty, msg
        ) values (
            v_journal_id, new__object_id, new__action, 
            new__action_pretty, new__msg
        );

        return v_journal_id;
     
end;$_$;


--
-- Name: last_day(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION last_day(timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
declare
       last_day__somedate	alias for $1;
       v_month			integer;
       v_targetmonth		integer;
       v_date			timestamptz;
       v_targetdate		timestamptz;
begin
	
       -- Initial values
       v_targetdate := last_day__somedate;
       v_targetmonth := extract(month from last_day__somedate);

       -- Add up to 31 days to the given date, stop if month changes.
       FOR i IN 1..31 LOOP

	    v_date := last_day__somedate + to_interval(i,'days');
	    v_month := extract(month from v_date);

	    if v_month != v_targetmonth
	    then
		exit;
	    else
	       v_targetdate := v_date;
	    end if;

       END LOOP;
	
       return v_targetdate;

end;$_$;


--
-- Name: lob_copy(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lob_copy(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        from_id         alias for $1;
        to_id           alias for $2;
begin
	if from_id is null then 
	    raise exception 'lob_copy: attempt to copy null from_id to % to_id',to_id;
        end if;

        insert into lobs (lob_id,refcount) values (to_id,0);

        insert into lob_data
             select to_id as lob_id, segment, byte_len, data
               from lob_data
              where lob_id = from_id;

        return null;

end;$_$;


--
-- Name: lob_get_data(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lob_get_data(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
        p_lob_id alias for $1;
        v_rec   record;
        v_data  text default '';
begin
        for v_rec in select data, segment from lob_data where lob_id = p_lob_id order by segment 
        loop
            v_data := v_data || v_rec.data;
        end loop;

        return v_data;

end;$_$;


--
-- Name: lob_length(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lob_length(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        id  alias for $1;
begin
        return sum(byte_len) from lob_data where lob_id = id;
end;$_$;


--
-- Name: logger_entry__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION logger_entry__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_entry_id      alias for $1;
begin
        -- The row in the entries table will cascade
        -- acs_object__delete should delete permissions for us but this change is not on cvs head yet
        delete from acs_permissions where object_id = p_entry_id;
        perform acs_object__delete(p_entry_id);

        return 0;
end; $_$;


--
-- Name: logger_entry__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION logger_entry__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
      p_entry_id      alias for $1;

      v_name          varchar;  
begin
      select description into v_name
      from logger_entries
      where entry_id = p_entry_id;

      return v_name;
end; $_$;


--
-- Name: logger_entry__new(integer, integer, integer, real, timestamp with time zone, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION logger_entry__new(integer, integer, integer, real, timestamp with time zone, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_entry_id            alias for $1;
        p_project_id          alias for $2;
        p_variable_id         alias for $3;
        p_value               alias for $4;
        p_time_stamp          alias for $5;
        p_description         alias for $6;
        p_creation_user       alias for $7;
        p_creation_ip         alias for $8;

        v_entry_id            integer;
begin

    v_entry_id := acs_object__new(
        p_entry_id,             -- object_id
        'logger_entry',       -- object_type
        current_timestamp,      -- creation_date
        p_creation_user,        -- creation_user
        p_creation_ip,          -- creation_ip
        p_project_id,           -- context_id
        't'                   -- security_inherit_p
    ); 
    
    insert into logger_entries (entry_id, 
                                project_id, 
                                variable_id, 
                                value, 
                                time_stamp, 
                                description)
                        values (v_entry_id, 
                                p_project_id, 
                                p_variable_id, 
                                p_value, 
                                p_time_stamp, 
                                p_description);

    return v_entry_id;  
end; $_$;


--
-- Name: logger_project__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION logger_project__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_project_id          alias for $1;

    v_rec                 record;
begin
        -- Delete all entries in the project
        for v_rec in select entry_id
                      from logger_entries
                      where project_id = p_project_id                     
        loop
          perform logger_entry__del(v_rec.entry_id);
        end loop;        

        -- Delete all variables only mapped to this project.
        for v_rec in select variable_id
                      from  logger_variables
                      where package_id is not null
                      and   exists (select 1
                                    from logger_project_pkg_map
                                    where project_id = p_project_id
                                   )
                      and   not exists (select 1 
                                        from logger_project_pkg_map 
                                        where project_id <> p_project_id
                                       )
        loop
            perform logger_variable__del(v_rec.variable_id);
        end loop;                                 

        -- Delete the project acs object. This will cascade the row in the logger_projects table
        -- as well as all projections in the project
        -- acs_object__delete should delete permissions for us but this change is not on cvs head yet
        delete from acs_permissions where object_id = p_project_id;
        perform acs_object__delete(p_project_id);

        return 0;
end; $_$;


--
-- Name: logger_project__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION logger_project__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
      p_project_id      alias for $1;

      v_name            varchar;
begin
      select name
      into   v_name
      from   logger_projects
      where  project_id = p_project_id;

      return v_name;
end; $_$;


--
-- Name: logger_project__new(integer, character varying, character varying, integer, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION logger_project__new(integer, character varying, character varying, integer, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_project_id          alias for $1;
    p_name                alias for $2;
    p_description         alias for $3;
    p_project_lead        alias for $4;
    p_creation_user       alias for $5;
    p_creation_ip         alias for $6;
    p_package_id          alias for $7;

    v_project_id          integer;
begin
       v_project_id := acs_object__new(
           p_project_id,             -- object_id
           'logger_project',           -- object_type
           current_timestamp,      -- creation_date
           p_creation_user,        -- creation_user
           p_creation_ip,          -- creation_ip
           p_package_id,           -- context_id
           't'                   -- security_inherit_p
       ); 
       
       insert into logger_projects (project_id, name, description, project_lead)
           values (v_project_id, p_name, p_description, p_project_lead);

       insert into logger_project_pkg_map (project_id, package_id)
                values (v_project_id, p_package_id);

       return v_project_id;  
end; $_$;


--
-- Name: logger_variable__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION logger_variable__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_variable_id      alias for $1;
begin
        -- Everything should be set up to cascade
        -- acs_object__delete should delete permissions for us but this change is not on cvs head yet
        delete from acs_permissions where object_id = p_variable_id;
        perform acs_object__delete(p_variable_id);

        return 0;
end; $_$;


--
-- Name: logger_variable__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION logger_variable__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
      p_variable_id      alias for $1;

      v_name          varchar;  
begin
      select description into v_name
      from logger_entries
      where variable_id = p_variable_id;

      return v_name;
end; $_$;


--
-- Name: logger_variable__new(integer, character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION logger_variable__new(integer, character varying, character varying, character varying, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_variable_id      alias for $1;
        p_name             alias for $2;
        p_unit             alias for $3;
        p_type             alias for $4;
        p_creation_user    alias for $5;
        p_creation_ip      alias for $6;
        p_package_id       alias for $7;

        v_variable_id      integer;
begin
       v_variable_id := acs_object__new(
           p_variable_id,             -- object_id
           'logger_variable',           -- object_type
           current_timestamp,      -- creation_date
           p_creation_user,        -- creation_user
           p_creation_ip,          -- creation_ip
           p_package_id,           -- context_id
           't'                   -- security_inherit_p
       ); 

       insert into logger_variables (variable_id, name, unit, type, package_id)
           values (v_variable_id, p_name, p_unit, p_type, p_package_id);

       return v_variable_id;  
end; $_$;


--
-- Name: membership_rel__approve(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__approve(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  approve__rel_id               alias for $1;  
begin
    update membership_rels
    set member_state = 'approved'
    where rel_id = approve__rel_id;

    return 0; 
end;$_$;


--
-- Name: membership_rel__ban(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__ban(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  ban__rel_id           alias for $1;  
begin
    update membership_rels
    set member_state = 'banned'
    where rel_id = ban__rel_id;

    return 0; 
end;$_$;


--
-- Name: membership_rel__check_index(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__check_index(integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  check_index__group_id               alias for $1;  
  check_index__member_id              alias for $2;  
  check_index__container_id           alias for $3;  
  result                              boolean;       
  n_rows                              integer;       
  row                                 record;
begin

    select count(*) into n_rows
    from group_member_index
    where group_id = check_index__group_id
    and member_id = check_index__member_id
    and container_id = check_index__container_id;

    if n_rows = 0 then
      result := 'f';
      PERFORM acs_log__error('membership_rel.check_representation',
                    'Row missing from group_member_index: ' ||
                    'group_id = ' || check_index__group_id || ', ' ||
                    'member_id = ' || check_index__member_id || ', ' ||
                    'container_id = ' || check_index__container_id || '.');
    end if;

    for row in  select r.object_id_one as container_id
                from acs_rels r, composition_rels c
                where r.rel_id = c.rel_id
                and r.object_id_two = check_index__group_id  
    LOOP
      if membership_rel__check_index(row.container_id, check_index__member_id, check_index__container_id) = 'f' then
        result := 'f';
      end if;
    end loop;

    return result;
   
end;$_$;


--
-- Name: membership_rel__check_representation(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__check_representation(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  check_representation__rel_id  alias for $1;  
  group_id                      groups.group_id%TYPE;
  member_id                     parties.party_id%TYPE;
  result                        boolean;  
  row                           record;     
begin
    result := 't';

    if acs_object__check_representation(check_representation__rel_id) = 'f' then
      result := 'f';
    end if;

    select r.object_id_one, r.object_id_two
    into group_id, member_id
    from acs_rels r, membership_rels m
    where r.rel_id = m.rel_id
    and m.rel_id = check_representation__rel_id;

    if membership_rel__check_index(group_id, member_id, group_id) = 'f' then
      result := 'f';
    end if;

    for row in  select *
                from group_member_index
                where rel_id = check_representation__rel_id 
    LOOP
      if composition_rel__check_path_exists_p(row.container_id,
                                             row.group_id) = 'f' then
        result := 'f';
        PERFORM acs_log__error('membership_rel.check_representation',
                      'Extra row in group_member_index: ' ||
                      'group_id = ' || row.group_id || ', ' ||
                      'member_id = ' || row.member_id || ', ' ||
                      'container_id = ' || row.container_id || '.');
      end if;
    end loop;

    return result;
   
end;$_$;


--
-- Name: membership_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  rel_id                 alias for $1;  
begin
    PERFORM acs_rel__delete(rel_id);

    return 0; 
end;$_$;


--
-- Name: membership_rel__deleted(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__deleted(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  deleted__rel_id               alias for $1;  
begin
    update membership_rels
    set member_state = 'deleted'
    where rel_id = deleted__rel_id;

    return 0; 
end;$_$;


--
-- Name: membership_rel__merge(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__merge(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  merge__rel_id                alias for $1;  
begin
    update membership_rels
    set member_state = 'merged'
    where rel_id = merge__rel_id;

    return 0; 
end;$_$;


--
-- Name: membership_rel__new(integer, character varying, integer, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__new(integer, character varying, integer, integer, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__rel_id            alias for $1;  -- default null  
  rel_type               alias for $2;  -- default 'membership_rel'
  object_id_one          alias for $3;  
  object_id_two          alias for $4;  
  new__member_state      alias for $5;  -- default 'approved'
  creation_user          alias for $6;  -- default null
  creation_ip            alias for $7;  -- default null
  v_rel_id               integer;       
begin
    v_rel_id := acs_rel__new (
      new__rel_id,
      rel_type,
      object_id_one,
      object_id_two,
      object_id_one,
      creation_user,
      creation_ip
    );

    insert into membership_rels
     (rel_id, member_state)
    values
     (v_rel_id, new__member_state);

    return v_rel_id;
   
end;$_$;


--
-- Name: membership_rel__new(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__new(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  object_id_one          alias for $1;  
  object_id_two          alias for $2;  
begin
        return membership_rel__new(null,
                                   'membership_rel',
                                   object_id_one,
                                   object_id_two,
                                   'approved',
                                   null,
                                   null);
end;$_$;


--
-- Name: membership_rel__reject(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__reject(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  reject__rel_id                alias for $1;  
begin
    update membership_rels
    set member_state = 'rejected'
    where rel_id = reject__rel_id;

    return 0; 
end;$_$;


--
-- Name: membership_rel__unapprove(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rel__unapprove(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  unapprove__rel_id             alias for $1;  
begin
    update membership_rels
    set member_state = 'need approval'
    where rel_id = unapprove__rel_id;

    return 0; 
end;$_$;


--
-- Name: membership_rels_del_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rels_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  v_error text;
  map             record;
begin
  -- First check if removing this relation would violate any relational constraints
  v_error := rel_constraint__violation_if_removed(old.rel_id);
  if v_error is not null then
      raise EXCEPTION '-20000: %', v_error;
  end if;

  for map in select group_id, element_id, rel_type
             from group_element_index
             where rel_id = old.rel_id
  loop
    perform party_approved_member__remove(map.group_id, map.element_id, old.rel_id, map.rel_type);
  end loop;

  delete from group_element_index
  where rel_id = old.rel_id;

  return old;

end;$$;


--
-- Name: membership_rels_in_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rels_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  v_object_id_one acs_rels.object_id_one%TYPE;
  v_object_id_two acs_rels.object_id_two%TYPE;
  v_rel_type      acs_rels.rel_type%TYPE;
  v_error         text;
  map             record;
begin
  
  -- First check if added this relation violated any relational constraints
  v_error := rel_constraint__violation(new.rel_id);
  if v_error is not null then
      raise EXCEPTION '-20000: %', v_error;
  end if;

  select object_id_one, object_id_two, rel_type
  into v_object_id_one, v_object_id_two, v_rel_type
  from acs_rels
  where rel_id = new.rel_id;

  -- Insert a row for me in the group_element_index.
  insert into group_element_index
   (group_id, element_id, rel_id, container_id, 
    rel_type, ancestor_rel_type)
  values
   (v_object_id_one, v_object_id_two, new.rel_id, v_object_id_one, 
    v_rel_type, 'membership_rel');

  if new.member_state = 'approved' then
    perform party_approved_member__add(v_object_id_one, v_object_id_two, new.rel_id, v_rel_type);
  end if;

  -- For all groups of which I am a component, insert a
  -- row in the group_element_index.
  for map in select distinct group_id
      from group_component_map
      where component_id = v_object_id_one 
  loop

    insert into group_element_index
     (group_id, element_id, rel_id, container_id,
      rel_type, ancestor_rel_type)
    values
     (map.group_id, v_object_id_two, new.rel_id, v_object_id_one,
      v_rel_type, 'membership_rel');

    if new.member_state = 'approved' then
      perform party_approved_member__add(map.group_id, v_object_id_two, new.rel_id, v_rel_type);
    end if;

  end loop;

  return new;

end;$$;


--
-- Name: membership_rels_up_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION membership_rels_up_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  map             record;
begin

  if new.member_state = old.member_state then
    return new;
  end if;

  for map in select group_id, element_id, rel_type
             from group_element_index
             where rel_id = new.rel_id
  loop
    if new.member_state = 'approved' then
      perform party_approved_member__add(map.group_id, map.element_id, new.rel_id, map.rel_type);
    else
      perform party_approved_member__remove(map.group_id, map.element_id, new.rel_id, map.rel_type);
    end if;
  end loop;

  return new;

end;$$;


--
-- Name: na_aggregator__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_aggregator__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_aggregator_id   alias for $1;
begin

        delete from acs_permissions
                where object_id = p_aggregator_id;

        delete from na_subscriptions
                where aggregator_id = p_aggregator_id;
	
	update na_user_preferences
		set default_aggregator = null
		where default_aggregator = p_aggregator_id;

	delete from na_purges
		where aggregator_id = p_aggregator_id;

	delete from na_saved_items
		where aggregator_id = p_aggregator_id;
	
        delete from na_aggregators
                where aggregator_id = p_aggregator_id;

        PERFORM acs_object__delete(p_aggregator_id);

        return 0;

end;$_$;


--
-- Name: na_aggregator__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_aggregator__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_aggregator_id      alias for $1;
    v_aggregator_name    na_aggregators.aggregator_name%TYPE;
begin
        select aggregator_name 
        into   v_aggregator_name
        from   na_aggregators
        where  aggregator_id = p_aggregator_id;

    return v_aggregator_name;

end;$_$;


--
-- Name: na_aggregator__new(integer, character varying, character varying, integer, boolean, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_aggregator__new(integer, character varying, character varying, integer, boolean, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_aggregator_id     alias for $1;
    p_aggregator_name   alias for $2;
    p_description       alias for $3;
    p_package_id        alias for $4;
    p_public_p          alias for $5;
    p_creation_user     alias for $6;
    p_creation_ip       alias for $7;
    v_aggregator_id          integer;
    v_max_item_id	     integer;
begin
        v_aggregator_id := acs_object__new (
                             p_aggregator_id,
                             'na_aggregator',
                             current_timestamp,
                             p_creation_user,
                             p_creation_ip,
                             p_package_id
        );

	select max(item_id) into v_max_item_id
		from na_items;
        
        insert into na_aggregators (
                aggregator_id, 
                aggregator_name,
                description,
                maintainer_id,
                package_id,
                public_p,
		aggregator_bottom
        ) values (
                v_aggregator_id,
                p_aggregator_name,
                p_description,
                p_creation_user,
                p_package_id,
                p_public_p,
		v_max_item_id
        );
        
        PERFORM acs_permission__grant_permission(
                    v_aggregator_id,
                    p_creation_user,
                    'admin'
        );

        return v_aggregator_id;

end;$_$;


--
-- Name: na_item__new(integer, character varying, character varying, character varying, timestamp with time zone, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_item__new(integer, character varying, character varying, character varying, timestamp with time zone, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_source_id                 alias for $1;
    p_link                      alias for $2;
    p_title                     alias for $3;
    p_description               alias for $4;
    p_creation_date             alias for $5;
    p_deleted_p                 alias for $6;
begin

        insert into na_items
          (source_id, link, title, description, creation_date, deleted_p)
        values
          (p_source_id, p_link, p_title, p_description, p_creation_date, p_deleted_p);

          return 1;

end;$_$;


--
-- Name: na_item__new(integer, character varying, character varying, character varying, boolean, character varying, character varying, character varying, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_item__new(integer, character varying, character varying, character varying, boolean, character varying, character varying, character varying, character varying, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_source_id                 alias for $1;
    p_link                      alias for $2;
    p_guid                      alias for $3;
    p_original_guid             alias for $4;
    p_permalink_p               alias for $5;
    p_title                     alias for $6;
    p_description               alias for $7;
    p_content_encoded           alias for $8;
    p_author                    alias for $9;
    p_pub_date                  alias for $10;
begin

        insert into na_items (
           source_id,
           link, 
           guid,
           original_guid,
           permalink_p,
           title, 
           description,
           content_encoded,
           author,
           pub_date, 
           creation_date
        ) values (
           p_source_id,
           p_link, 
           p_guid,
           p_original_guid,
           p_permalink_p,
           p_title, 
           p_description,
           p_content_encoded,
           p_author,
           p_pub_date,
           current_timestamp
        );

        return 1;

end;$_$;


--
-- Name: na_source__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_source__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_source_id   alias for $1;
begin

        delete from acs_permissions
                   where object_id = p_source_id;
	
	delete from na_purges
		where (top in (select item_id
				from na_items
				where source_id = p_source_id)
		    or bottom in (select item_id
		    		from na_items
				where source_id = p_source_id));

        delete from na_items
                where source_id = p_source_id;

        delete from na_subscriptions
                where source_id = p_source_id;
	
        delete from na_sources
                   where source_id = p_source_id;

        PERFORM acs_object__delete(p_source_id);

        return 0;

end;$_$;


--
-- Name: na_source__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_source__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_source_id      alias for $1;
    v_source_name    na_sources.title%TYPE;
begin
        select title 
        into   v_source_name
        from   na_sources
        where  source_id = p_source_id;

    return v_source_name;
end;
$_$;


--
-- Name: na_source__new(integer, integer, integer, character varying, character varying, character varying, character varying, integer, timestamp with time zone, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_source__new(integer, integer, integer, character varying, character varying, character varying, character varying, integer, timestamp with time zone, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_source_id         alias for $1;
    p_package_id        alias for $2;
    p_owner_id          alias for $3;
    p_feed_url          alias for $4;
    p_link              alias for $5;
    p_title             alias for $6;
    p_description       alias for $7;
    p_updates           alias for $8;
    p_last_scanned      alias for $9;
    p_last_modified     alias for $10;
    p_object_type       alias for $11;
    p_creation_user     alias for $12;
    p_creation_ip       alias for $13;
    v_source_id         integer;
begin
        v_source_id := acs_object__new (
                             p_source_id,
                             p_object_type,
                             current_timestamp,
                             p_creation_user,
                             p_creation_ip,
                             p_package_id
        );

        insert into na_sources (
                source_id, 
                package_id, 
                owner_id, 
                feed_url, 
                link, 
                title, 
                description, 
                updates, 
                last_scanned, 
                last_modified
        ) values (
                v_source_id,
                p_package_id, 
                p_owner_id, 
                p_feed_url, 
                p_link, 
                p_title, 
                p_description, 
                p_updates, 
                p_last_scanned, 
                p_last_modified
        );

          PERFORM acs_permission__grant_permission(
          v_source_id,
          p_owner_id,
          'admin'
          );

        return v_source_id;

end;$_$;


--
-- Name: na_source__new(integer, character varying, character varying, character varying, character varying, character varying, boolean, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_source__new(integer, character varying, character varying, character varying, character varying, character varying, boolean, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_source_id         alias for $1;
    p_feed_url          alias for $2;
    p_link              alias for $3;
    p_title             alias for $4;
    p_description       alias for $5;
    p_last_modified     alias for $6;
    p_listed_p          alias for $7;
    p_creation_user     alias for $8;
    p_creation_ip       alias for $9;
    v_source_id         integer;
begin
        v_source_id := acs_object__new (
                             p_source_id,
                             'na_source',
                             current_timestamp,
                             p_creation_user,
                             p_creation_ip,
                             null
        );

        insert into na_sources (
                source_id, 
                feed_url, 
                link, 
                title, 
                description, 
                last_scanned, 
                last_modified,
                listed_p
        ) values (
                v_source_id,
                p_feed_url, 
                p_link, 
                p_title, 
                p_description,
                current_timestamp, 
                p_last_modified,
                p_listed_p
        );

        return v_source_id;

end;$_$;


--
-- Name: na_source__title(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_source__title(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_source_id      alias for $1;
    v_source_title    na_sources.title%TYPE;
begin
        select title 
        into   v_source_title
        from   na_sources
        where  source_id = p_source_id;

    return v_source_title;
end;
$_$;


--
-- Name: na_subscription__new(integer, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_subscription__new(integer, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_aggregtor_id                      alias for $1;
    p_source_id                         alias for $2;
    p_creation_date                     alias for $3;
begin

        insert into na_subscriptions (
           aggregator_id,
           source_id,
           creation_date
        ) values (
           p_aggregator_id,
           p_source_id,
           p_creation_date
        );

        return 1;

end;$_$;


--
-- Name: na_weblog__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_weblog__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_weblog_id alias for $1;
begin
    delete from na_weblogs
        where weblog_id = p_weblog_id;

    PERFORM acs_object__delete(p_weblog_id);
    return 0;
end;
$_$;


--
-- Name: na_weblog__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_weblog__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_weblog_id         alias for $1;
    v_name              varchar;
begin
    select weblog_name into v_name
        from na_weblogs
        where weblog_id = p_weblog_id;
    return v_name;
end;
$_$;


--
-- Name: na_weblog__new(integer, integer, character varying, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION na_weblog__new(integer, integer, character varying, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_weblog_id               alias for $1;
    p_package_id           alias for $2;
    p_blog_type		alias for $3;
    p_weblog_name                 alias for $4;
    p_base_url           alias for $5;
    p_creation_user        alias for $6;
    p_creation_ip          alias for $7;
    v_weblog_id          integer;
begin
    v_weblog_id := acs_object__new (
        p_weblog_id,
        'na_weblog',
        current_timestamp,
        p_creation_user,
        p_creation_ip,
        p_package_id
    );

    insert into na_weblogs (
      weblog_id, 
      package_id,
      blog_type,
      weblog_name,
      base_url,
      user_id
    ) values (
      v_weblog_id, 
      p_package_id,
      p_blog_type,
      p_weblog_name,
      p_base_url,
      p_creation_user
    );

    return v_weblog_id;   
end;
$_$;


--
-- Name: news__archive(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__archive(integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_item_id alias for $1;
    p_archive_date alias for $2; -- default current_timestamp
begin
    update cr_news  
    set    archive_date = p_archive_date
    where  news_id = content_item__get_live_revision(p_item_id);

    return 0;
end;
$_$;


--
-- Name: news__archive(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__archive(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_item_id alias for $1;
    -- p_archive_date alias for $2; -- default current_timestamp
begin
    return news__archive (p_item_id, current_timestamp);
end;
$_$;


--
-- Name: news__clone(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__clone(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
 p_old_package_id   alias for $1;   --default null,
 p_new_package_id   alias for $2;   --default null
 one_news		record;	 
begin
        for one_news in select
                            publish_date,
                            cr.content as text,
                            cr.nls_language,
                            cr.title as title,
                            cr.mime_type,
                            cn.package_id,
                            archive_date,
                            approval_user,
                            approval_date,
                            approval_ip,
                            ao.creation_date,
                            ao.creation_ip,
                            ao.creation_user,
			    ci.locale,
			    ci.live_revision,
			    cr.revision_id,
			    cn.lead
                        from 
                            cr_items ci, 
                            cr_revisions cr,
                            cr_news cn,
                            acs_objects ao
                        where
			    cn.package_id = p_old_package_id
                        and ((ci.item_id = cr.item_id
                            and ci.live_revision = cr.revision_id 
                            and cr.revision_id = cn.news_id 
                            and cr.revision_id = ao.object_id)
                        or (ci.live_revision is null 
                            and ci.item_id = cr.item_id
                            and cr.revision_id = content_item__get_latest_revision(ci.item_id)
                            and cr.revision_id = cn.news_id
                            and cr.revision_id = ao.object_id))

        loop
            perform news__new(
						null,
						one_news.locale,
                				one_news.publish_date,
                				one_news.text,
                				one_news.nls_language,
                				one_news.title,
                				one_news.mime_type,
                				p_new_package_id,
                				one_news.archive_date,
                				one_news.approval_user,
                				one_news.approval_date,
                				one_news.approval_ip,
						null,
                				one_news.creation_ip,
                				one_news.creation_user,
						one_news.live_revision = one_news.revision_id,
						one_news.lead
            );

        end loop;
 return 0;
end;
$_$;


--
-- Name: news__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_item_id alias for $1;
    v_item_id cr_items.item_id%TYPE;
    v_cm RECORD;
begin
    v_item_id := p_item_id;
    -- dbms_output.put_line('Deleting associated comments...');
    -- delete acs_messages, images, comments to news item

    FOR v_cm IN
        select message_id from acs_messages am, acs_objects ao
        where  am.message_id = ao.object_id
        and    ao.context_id = v_item_id
    LOOP
        -- images
        delete from images
            where image_id in (select latest_revision
                               from cr_items 
                               where parent_id = v_cm.message_id);
        PERFORM acs_message__delete(v_cm.message_id);
        delete from general_comments
            where comment_id = v_cm.message_id;
    END LOOP;
    delete from cr_news 
    where news_id in (select revision_id 
                      from   cr_revisions 
                      where  item_id = v_item_id);
    PERFORM content_item__delete(v_item_id);
    return 0;
end;
$_$;


--
-- Name: news__make_permanent(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__make_permanent(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_item_id alias for $1;
begin
    update cr_news
    set    archive_date = null
    where  news_id = content_item__get_live_revision(p_item_id);

    return 0;
end;
$_$;


--
-- Name: news__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_news_id alias for $1;
    v_news_title cr_revisions.title%TYPE;
begin
    select title 
    into v_news_title
    from cr_revisions
    where revision_id = p_news_id;

    return v_news_title;
end;
$_$;


--
-- Name: news__new(integer, character varying, timestamp with time zone, text, character varying, character varying, character varying, integer, timestamp with time zone, integer, timestamp with time zone, character varying, character varying, character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__new(integer, character varying, timestamp with time zone, text, character varying, character varying, character varying, integer, timestamp with time zone, integer, timestamp with time zone, character varying, character varying, character varying, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_item_id       alias for $1;  -- default null
    --
    p_locale        alias for $2;  -- default null,
    --
    p_publish_date  alias for $3;  -- default null
    p_text          alias for $4;  -- default null
    p_nls_language  alias for $5;  -- default null
    p_title         alias for $6;  -- default null
    p_mime_type     alias for $7;  -- default 'text/plain'
    --
    p_package_id    alias for $8;  -- default null,     
    p_archive_date  alias for $9;  -- default null
    p_approval_user alias for $10; -- default null
    p_approval_date alias for $11; -- default null
    p_approval_ip   alias for $12; -- default null,     
    --
    p_relation_tag  alias for $13; -- default null
    --
    -- REMOVED: p_item_subtype  alias for $14; -- default 'content_revision'
    -- REMOVED: p_content_type  alias for $15; -- default 'news'
    -- REMOVED: p_creation_date alias for $16; -- default current_timestamp
    p_creation_ip   alias for $14; -- default null
    p_creation_user alias for $15; -- default null
    --
    p_is_live_p     alias for $16; -- default 'f'

    v_news_id       integer;
    v_item_id       integer;
    v_id            integer;
    v_revision_id   integer;
    v_parent_id     integer;
    v_name          varchar;
    v_log_string    varchar;
begin
    select content_item__get_id('news',null,'f') 
    into   v_parent_id 
    from   dual;    
    --
    -- this will be used for 2xClick protection
    if p_item_id is null then
        select acs_object_id_seq.nextval 
        into   v_id 
        from   dual;
    else 
        v_id := p_item_id;
    end if; 
    --
    select 'news' || to_char(current_timestamp,'YYYYMMDD') || v_id 
    into   v_name 
    from   dual;    
    -- 
    v_log_string := 'initial submission'; 
    -- 
    v_item_id := content_item__new(
        v_name,               -- name
        v_parent_id,          -- parent_id
        v_id,                 -- item_id
        p_locale,             -- locale
        current_timestamp,    -- creation_date
        p_creation_user,      -- creation_user
	null,                 -- context_id
        p_creation_ip,        -- creation_ip
        'content_item',     -- item_subtype
        'news',             -- content_type
	null,                 -- title
	null,                 -- description
        p_mime_type,          -- mime_type
        p_nls_language,       -- nls_language
	null,                 -- data
	'text'	      -- storage_type
        -- relation tag is not used by any callers or any
        -- implementations of content_item__new
    );
    v_revision_id := content_revision__new(
        p_title,           -- title
        v_log_string,      -- description
        p_publish_date,    -- publish_date
        p_mime_type,       -- mime_type
        p_nls_language,    -- nls_language
        p_text,            -- data
        v_item_id,         -- item_id
	null,              -- revision_id
        current_timestamp, -- creation_date
        p_creation_user,   -- creation_user
        p_creation_ip      -- creation_ip
    );
    insert into cr_news 
        (news_id, 
         package_id, 
         archive_date,
         approval_user, 
         approval_date, 
         approval_ip)
    values
        (v_revision_id, 
         p_package_id, 
         p_archive_date,
         p_approval_user, 
         p_approval_date, 
         p_approval_ip);
    -- make this revision live when immediately approved
    if p_is_live_p = 't' then
        update 
            cr_items
        set
            live_revision = v_revision_id,
            publish_status = 'ready'
        where 
            item_id = v_item_id;
    end if;
    v_news_id := v_revision_id;
    return v_news_id;
end;
$_$;


--
-- Name: news__new(integer, character varying, timestamp with time zone, text, character varying, character varying, character varying, integer, timestamp with time zone, integer, timestamp with time zone, character varying, character varying, character varying, integer, boolean, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__new(integer, character varying, timestamp with time zone, text, character varying, character varying, character varying, integer, timestamp with time zone, integer, timestamp with time zone, character varying, character varying, character varying, integer, boolean, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_item_id       alias for $1;  -- default null
    --
    p_locale        alias for $2;  -- default null,
    --
    p_publish_date  alias for $3;  -- default null
    p_text          alias for $4;  -- default null
    p_nls_language  alias for $5;  -- default null
    p_title         alias for $6;  -- default null
    p_mime_type     alias for $7;  -- default 'text/plain'
    --
    p_package_id    alias for $8;  -- default null
    p_archive_date  alias for $9;  -- default null
    p_approval_user alias for $10; -- default null
    p_approval_date alias for $11; -- default null
    p_approval_ip   alias for $12; -- default null
    --
    p_relation_tag  alias for $13; -- default null
    --
    -- REMOVED: p_item_subtype  alias for $14; -- default 'content_revision'
    -- REMOVED: p_content_type  alias for $15; -- default 'news'
    -- REMOVED: p_creation_date alias for $16; -- default current_timestamp
    p_creation_ip   alias for $14; -- default null
    p_creation_user alias for $15; -- default null
    --
    p_is_live_p     alias for $16; -- default 'f'
    p_lead          alias for $17;

    v_news_id       integer;
    v_item_id       integer;
    v_id            integer;
    v_revision_id   integer;
    v_parent_id     integer;
    v_name          varchar;
    v_log_string    varchar;
begin
    select content_item__get_id('news',null,'f')
    into   v_parent_id
    from   dual;
    --
    -- this will be used for 2xClick protection
    if p_item_id is null then
        select acs_object_id_seq.nextval
        into   v_id
        from   dual;
    else
        v_id := p_item_id;
    end if;
    --
    v_name := 'news-' || to_char(current_timestamp,'YYYYMMDD') || '-' || v_id;
    --
    v_log_string := 'initial submission';
    --
    v_item_id := content_item__new(
        v_name,               -- name
        v_parent_id,          -- parent_id
        v_id,                 -- item_id
        p_locale,             -- locale
        current_timestamp,    -- creation_date
        p_creation_user,      -- creation_user
	p_package_id,         -- context_id
        p_creation_ip,        -- creation_ip
        'content_item',     -- item_subtype
        'news',             -- content_type
        p_title,              -- title
	null,                 -- description
        p_mime_type,          -- mime_type
        p_nls_language,       -- nls_language
        null,                 -- text
	null,                 -- data
        null,                 -- relation_tag
        p_is_live_p,           -- live_p
	'text',	      -- storage_type
        p_package_id          -- package_id
    );

    v_revision_id := content_revision__new(
        p_title,           -- title
        v_log_string,      -- description
        p_publish_date,    -- publish_date
        p_mime_type,       -- mime_type
        p_nls_language,    -- nls_language
        p_text,            -- data
        v_item_id,         -- item_id
	null,              -- revision_id
        current_timestamp, -- creation_date
        p_creation_user,   -- creation_user
        p_creation_ip      -- creation_ip
    );

    insert into cr_news
        (news_id,
         lead,
         package_id,
         archive_date,
         approval_user,
         approval_date,
         approval_ip)
    values
        (v_revision_id,
         p_lead,
         p_package_id,
         p_archive_date,
         p_approval_user,
         p_approval_date,
         p_approval_ip);
    -- make this revision live when immediately approved
    if p_is_live_p = 't' then
        update
            cr_items
        set
            live_revision = v_revision_id,
            publish_status = 'ready'
        where
            item_id = v_item_id;
    end if;
    v_news_id := v_revision_id;
    return v_news_id;
end;
$_$;


--
-- Name: news__revision_delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__revision_delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_revision_id alias for $1;
begin
    -- delete from cr_news table
    delete from cr_news
    where  news_id = p_revision_id;

    -- delete revision
    PERFORM content_revision__delete(
        p_revision_id -- revision_id
    );

    return 0;
end;
$_$;


--
-- Name: news__revision_new(integer, timestamp with time zone, text, character varying, text, character varying, integer, timestamp with time zone, integer, timestamp with time zone, character varying, timestamp with time zone, character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__revision_new(integer, timestamp with time zone, text, character varying, text, character varying, integer, timestamp with time zone, integer, timestamp with time zone, character varying, timestamp with time zone, character varying, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_item_id                alias for $1;
    --
    p_publish_date           alias for $2;  -- default null
    p_text                   alias for $3;  -- default null
    p_title                  alias for $4;
    --
    -- here goes the revision log
    p_description            alias for $5;
    --
    p_mime_type              alias for $6;  -- default 'text/plain'
    p_package_id             alias for $7;  -- default null
    p_archive_date           alias for $8;  -- default null
    p_approval_user          alias for $9;  -- default null
    p_approval_date          alias for $10; -- default null
    p_approval_ip            alias for $11; -- default null
    --
    p_creation_date          alias for $12; -- default current_timestamp
    p_creation_ip            alias for $13; -- default null
    p_creation_user          alias for $14; -- default null
    --
    p_make_active_revision_p alias for $15; -- default 'f'

    v_revision_id    integer;
begin
    -- create revision
    v_revision_id := content_revision__new(
        p_title,         -- title
        p_description,   -- description
        p_publish_date,  -- publish_date
        p_mime_type,     -- mime_type
        null,            -- nls_language
        p_text,          -- text
        p_item_id,       -- item_id
        null,            -- revision_id
        p_creation_date, -- creation_date
        p_creation_user, -- creation_user
        p_creation_ip    -- creation_ip
    );
    -- create new news entry with new revision
    insert into cr_news
        (news_id, 
         package_id,
         archive_date, 
         approval_user, 
         approval_date, 
         approval_ip)
    values
        (v_revision_id, 
         p_package_id,
         p_archive_date, 
         p_approval_user, 
         p_approval_date,
         p_approval_ip);
    -- make active revision if indicated
    if p_make_active_revision_p = 't' then
        PERFORM news__revision_set_active(v_revision_id);
    end if;
    return v_revision_id;
end;
$_$;


--
-- Name: news__revision_new(integer, timestamp with time zone, text, character varying, text, character varying, integer, timestamp with time zone, integer, timestamp with time zone, character varying, timestamp with time zone, character varying, integer, boolean, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__revision_new(integer, timestamp with time zone, text, character varying, text, character varying, integer, timestamp with time zone, integer, timestamp with time zone, character varying, timestamp with time zone, character varying, integer, boolean, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_item_id                alias for $1;
    --
    p_publish_date           alias for $2;  -- default null
    p_text                   alias for $3;  -- default null
    p_title                  alias for $4;
    --
    -- here goes the revision log
    p_description            alias for $5;
    --
    p_mime_type              alias for $6;  -- default 'text/plain'
    p_package_id             alias for $7;  -- default null
    p_archive_date           alias for $8;  -- default null
    p_approval_user          alias for $9;  -- default null
    p_approval_date          alias for $10; -- default null
    p_approval_ip            alias for $11; -- default null
    --
    p_creation_date          alias for $12; -- default current_timestamp
    p_creation_ip            alias for $13; -- default null
    p_creation_user          alias for $14; -- default null
    --
    p_make_active_revision_p alias for $15; -- default 'f'
    p_lead                   alias for $16;

    v_revision_id    integer;
begin
    -- create revision
    v_revision_id := content_revision__new(
        p_title,         -- title
        p_description,   -- description
        p_publish_date,  -- publish_date
        p_mime_type,     -- mime_type
        null,            -- nls_language
        p_text,          -- text
        p_item_id,       -- item_id
        null,            -- revision_id
        p_creation_date, -- creation_date
        p_creation_user, -- creation_user
        p_creation_ip    -- creation_ip
    );
    -- create new news entry with new revision
    insert into cr_news
        (news_id, 
         lead,
         package_id,
         archive_date, 
         approval_user, 
         approval_date, 
         approval_ip)
    values
        (v_revision_id, 
         p_lead,
         p_package_id,
         p_archive_date, 
         p_approval_user, 
         p_approval_date,
         p_approval_ip);
    -- make active revision if indicated
    if p_make_active_revision_p = 't' then
        PERFORM news__revision_set_active(v_revision_id);
    end if;
    return v_revision_id;
end;
$_$;


--
-- Name: news__revision_set_active(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__revision_set_active(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_revision_id alias for $1;
    v_news_item_p boolean;
    v_item_id cr_items.item_id%TYPE;
    v_title acs_objects.title%TYPE;
    -- could be used to check if really a 'news' item
begin

    select item_id, title into v_item_id, v_title
    from cr_revisions
    where revision_id = p_revision_id;

    update cr_items
    set live_revision = p_revision_id,
        publish_status = 'ready'
    where item_id = v_item_id;

    -- We update the acs_objects title as well.

    update acs_objects set title = v_title
    where object_id = v_item_id and (title != v_title or title is null);

    return 0;
end;
$_$;


--
-- Name: news__set_approve(integer, character varying, timestamp with time zone, timestamp with time zone, integer, timestamp with time zone, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__set_approve(integer, character varying, timestamp with time zone, timestamp with time zone, integer, timestamp with time zone, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_revision_id     alias for $1;
    p_approve_p       alias for $2; -- default 't'
    p_publish_date    alias for $3; -- default null
    p_archive_date    alias for $4; -- default null
    p_approval_user   alias for $5; -- default null
    p_approval_date   alias for $6; -- default current_timestamp
    p_approval_ip     alias for $7; -- default null
    p_live_revision_p alias for $8; -- default 't'
    v_item_id         cr_items.item_id%TYPE;
begin
    select item_id into v_item_id
    from   cr_revisions 
    where  revision_id = p_revision_id;
    -- unapprove an revision (does not mean to knock out active revision)
    if p_approve_p = 'f' then
        update  cr_news 
        set     approval_date = null,
                approval_user = null,
                approval_ip   = null,
                archive_date  = null
        where   news_id = p_revision_id;
        --
        update  cr_revisions
        set     publish_date = null
        where   revision_id  = p_revision_id;
    else
    -- approve a revision
        update  cr_revisions
        set     publish_date  = p_publish_date
        where   revision_id   = p_revision_id;
        --  
        update  cr_news 
        set archive_date  = p_archive_date,
            approval_date = p_approval_date,
            approval_user = p_approval_user,
            approval_ip   = p_approval_ip
        where news_id     = p_revision_id;
        -- 
        -- cannot use content_item.set_live_revision because it sets publish_date to sysdate
        if p_live_revision_p = 't' then
            update  cr_items
            set     live_revision = p_revision_id,
                    publish_status = 'ready'
            where   item_id = v_item_id;
        end if;
        --
    end if;

    return 0;
end;
$_$;


--
-- Name: news__status(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION news__status(timestamp with time zone, timestamp with time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_publish_date alias for $1;
    p_archive_date alias for $2;
begin
    if p_publish_date is not null then
        if p_publish_date > current_timestamp then
            -- Publishing in the future
            if p_archive_date is null then 
                return 'going_live_no_archive';
            else 
                return 'going_live_with_archive';
            end if;  
        else
            -- Published in the past
            if p_archive_date is null then
                 return 'published_no_archive';
            else
                if p_archive_date > current_timestamp then
                     return 'published_with_archive';
                else 
                    return 'archived';
                end if;
            end if;
        end if;
    else
        -- publish_date null
        return 'unapproved';
    end if;
end;
$_$;


--
-- Name: next_day(timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION next_day(timestamp with time zone, character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
declare
       next_day__somedate	alias for $1;
       next_day__weekday	alias for $2;
       v_dow			integer;
       v_ref_dow		integer;
       v_add_days		integer;
begin
	-- I cant find a function that converts days of the week to
	-- the corresponding integer value, so I roll my own (above)
	-- We avoid extract(dow from timestamp) because of incompatible output with to_char.
	v_ref_dow := dow_to_int(next_day__weekday);
	v_dow := to_number(to_char(next_day__somedate,'D'),'9');
	
	-- If next_day___weekday is the same day of the week as
	-- next_day__somedate, we add a full week.
	if v_dow < v_ref_dow
	then
	     v_add_days := v_ref_dow - v_dow;
        else
	     v_add_days := v_ref_dow - v_dow + 7;
	end if;

	-- Do date math
	return next_day__somedate + to_interval(v_add_days,'days');

end;$_$;


--
-- Name: notification__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_notification_id               alias for $1;
begin
    delete from notifications where notification_id = p_notification_id;
    perform acs_object__delete(p_notification_id);
    return 0;
end;
$_$;


--
-- Name: notification__new(integer, integer, integer, timestamp with time zone, integer, integer, character varying, text, text, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification__new(integer, integer, integer, timestamp with time zone, integer, integer, character varying, text, text, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_notification_id               alias for $1;
    p_type_id                       alias for $2;
    p_object_id                     alias for $3;
    p_notif_date                    alias for $4;
    p_response_id                   alias for $5;
    p_notif_user                    alias for $6;
    p_notif_subject                 alias for $7;
    p_notif_text                    alias for $8;
    p_notif_html                    alias for $9;
    p_creation_date                 alias for $10;
    p_creation_user                 alias for $11;
    p_creation_ip                   alias for $12;
    p_context_id                    alias for $13;
    v_notification_id               integer;
    v_notif_date                    notifications.notif_date%TYPE;
begin
    v_notification_id := acs_object__new(
        p_notification_id,
        'notification',
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        p_context_id
    );

    if p_notif_date is null then
        v_notif_date := now();
    else
        v_notif_date := p_notif_date;
    end if;

    insert
    into notifications
    (notification_id, type_id, object_id, notif_date, response_id, notif_user, notif_subject, notif_text, notif_html)
    values
    (v_notification_id, p_type_id, p_object_id, v_notif_date, p_response_id, p_notif_user, p_notif_subject, p_notif_text, p_notif_html);

    return v_notification_id;
end;
$_$;


--
-- Name: notification_delivery_method__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_delivery_method__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_delivery_method_id            alias for $1;
BEGIN
        perform acs_object__delete(p_delivery_method_id);
        return 0;
END;
$_$;


--
-- Name: notification_delivery_method__new(integer, integer, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_delivery_method__new(integer, integer, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_delivery_method_id            alias for $1;
    p_sc_impl_id                    alias for $2;
    p_short_name                    alias for $3;
    p_pretty_name                   alias for $4;
    p_creation_date                 alias for $5;
    p_creation_user                 alias for $6;
    p_creation_ip                   alias for $7;
    p_context_id                    alias for $8;
    v_delivery_method_id            integer;
begin
    v_delivery_method_id := acs_object__new(
        p_delivery_method_id,
        'notification_delivery_method',
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        p_context_id
    );

    insert
    into notification_delivery_methods
    (delivery_method_id, sc_impl_id, short_name, pretty_name)
    values
    (v_delivery_method_id, p_sc_impl_id, p_short_name, p_pretty_name);

    return v_delivery_method_id;
end;
$_$;


--
-- Name: notification_interval__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_interval__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_interval_id                   alias for $1;
begin
    perform acs_object__delete(p_interval_id);
    return 0;
end;
$_$;


--
-- Name: notification_interval__new(integer, character varying, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_interval__new(integer, character varying, integer, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_interval_id                   alias for $1;
    p_name                          alias for $2;
    p_n_seconds                     alias for $3;
    p_creation_date                 alias for $4;
    p_creation_user                 alias for $5;
    p_creation_ip                   alias for $6;
    p_context_id                    alias for $7;
    v_interval_id                   integer;
begin
    v_interval_id := acs_object__new(
        p_interval_id,
        'notification_interval',
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        p_context_id
    );

    insert
    into notification_intervals
    (interval_id, name, n_seconds)
    values
    (v_interval_id, p_name, p_n_seconds);

    return v_interval_id;
end;
$_$;


--
-- Name: notification_reply__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_reply__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_reply_id              alias for $1;
BEGIN
        perform acs_object__delete(p_reply_id);
        return (0);
END;
$_$;


--
-- Name: notification_reply__new(integer, integer, integer, integer, character varying, text, timestamp with time zone, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_reply__new(integer, integer, integer, integer, character varying, text, timestamp with time zone, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_reply_id                      alias for $1;
        p_object_id                     alias for $2;
        p_type_id                       alias for $3;
        p_from_user                     alias for $4;
        p_subject                       alias for $5;
        p_content                       alias for $6;
        p_reply_date                    alias for $7;
        p_creation_date                 alias for $8;
        p_creation_user                 alias for $9;
        p_creation_ip                   alias for $10;
        p_context_id                    alias for $11;
        v_reply_id                      integer;        
BEGIN
        v_reply_id:= acs_object__new (
                                    p_reply_id,
                                    'notification_reply',
                                    p_creation_date,
                                    p_creation_user,
                                    p_creation_ip,
                                    p_context_id
                                    );

        insert into notification_replies
        (reply_id, object_id, type_id, from_user, subject, content, reply_date)
        values
        (v_reply_id, p_object_id, p_type_id, p_from_user, p_subject, p_content, p_reply_date);


        return v_reply_id;
END;
$_$;


--
-- Name: notification_request__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_request__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_request_id                    alias for $1;
    v_notifications record;
begin
    for v_notifications in select notification_id
                           from notifications n, notification_requests nr
                           where n.response_id = nr.object_id
                             and nr.request_id = p_request_id
    loop
      perform acs_object__delete(v_notifications.notification_id);
    end loop;

    perform acs_object__delete(p_request_id);
    return 0;
end;
$_$;


--
-- Name: notification_request__delete_all(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_request__delete_all(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id                     alias for $1;
    v_request                       RECORD;
begin
    for v_request in select request_id
                     from notification_requests
                     where object_id= p_object_id
    loop
        perform notification_request__delete(v_request.request_id);
    end loop;

    return 0;
end;
$_$;


--
-- Name: notification_request__new(integer, character varying, integer, integer, integer, integer, integer, character varying, boolean, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_request__new(integer, character varying, integer, integer, integer, integer, integer, character varying, boolean, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE
        p_request_id                            alias for $1;
        p_object_type                           alias for $2;
        p_type_id                               alias for $3;
        p_user_id                               alias for $4;
        p_object_id                             alias for $5;
        p_interval_id                           alias for $6;
        p_delivery_method_id                    alias for $7;
        p_format                                alias for $8;
        p_dynamic_p                             alias for $9;
        p_creation_date                         alias for $10;
        p_creation_user                         alias for $11;
        p_creation_ip                           alias for $12;
        p_context_id                            alias for $13;
        v_request_id                            integer;
BEGIN
        v_request_id:= acs_object__new (
                                       p_request_id,
                                       p_object_type,
                                       p_creation_date,
                                       p_creation_user,
                                       p_creation_ip,
                                       p_context_id);

      insert into notification_requests
      (request_id, type_id, user_id, object_id, interval_id, delivery_method_id, format, dynamic_p) values
      (v_request_id, p_type_id, p_user_id, p_object_id, p_interval_id, p_delivery_method_id, p_format, p_dynamic_p);

      return v_request_id;                          

END;
$_$;


--
-- Name: notification_type__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_type__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_type_id                       alias for $1;
begin
    perform acs_object__delete(p_type_id);
    return 0;
end;
$_$;


--
-- Name: notification_type__new(integer, integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION notification_type__new(integer, integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_type_id                       alias for $1;
        p_sc_impl_id                    alias for $2;
        p_short_name                    alias for $3;
        p_pretty_name                   alias for $4;
        p_description                   alias for $5;
        p_creation_date                 alias for $6;
        p_creation_user                 alias for $7;
        p_creation_ip                   alias for $8;
        p_context_id                    alias for $9;
        v_type_id                       integer;
BEGIN
        v_type_id:= acs_object__new (
                                    p_type_id,
                                    'notification_type',
                                    p_creation_date,
                                    p_creation_user,
                                    p_creation_ip,
                                    p_context_id);

      insert into notification_types
      (type_id, sc_impl_id, short_name, pretty_name, description) values
      (v_type_id, p_sc_impl_id, p_short_name, p_pretty_name, p_description);
      
      return v_type_id;
END;
$_$;


--
-- Name: number_src(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION number_src(text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
        v_src   alias for $1;
        v_pos   integer;
        v_ret   text default '';
        v_tmp   text;
        v_cnt   integer default -1;
begin
        if v_src is null then 
	     return null;
        end if;
        v_tmp := v_src;
        LOOP
            v_pos := position('
' in v_tmp);
            v_cnt := v_cnt + 1;

            exit when v_pos = 0;

            if v_cnt != 0 then
              v_ret := v_ret || rpad(v_cnt,10) || substr(v_tmp,1,v_pos);
            end if;
            v_tmp := substr(v_tmp,v_pos + 1);
        end LOOP;

        return v_ret || rpad(v_cnt,10) || v_tmp;

end;$_$;


--
-- Name: on_lob_ref(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION on_lob_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	if TG_OP = 'UPDATE' then
		if new.lob = old.lob then
			return new;
		end if;
	end if;

	if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
		if new.lob is not null then
			insert into lobs select new.lob, 0
				where 0 = (select count(*) from lobs where lob_id = new.lob);
			update lobs set refcount = refcount + 1 where lob_id = new.lob;
		end if;
	end if;

	if TG_OP <> 'INSERT' then
		if old.lob is not null then
			update lobs set refcount = refcount - 1 where lob_id = old.lob;
			delete from lobs where lob_id = old.lob and refcount = 0;
		end if;
	end if;

	if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then return new;
	else return old;
	end if;

end;$$;


--
-- Name: on_lobs_delete(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION on_lobs_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	delete from lob_data where lob_id = old.lob_id;
	return old;
end;$$;


--
-- Name: parties_del_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION parties_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

  delete from party_approved_member_map
  where party_id = old.party_id
    and member_id = old.party_id;

  return old;

end;$$;


--
-- Name: parties_in_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION parties_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

  insert into party_approved_member_map
    (party_id, member_id, tag)
  values
    (new.party_id, new.party_id, 0);

  return new;

end;$$;


--
-- Name: party__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION party__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  party_id               alias for $1;  
begin
  PERFORM acs_object__delete(party_id);

  return 0; 
end;$_$;


--
-- Name: party__email(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION party__email(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  email__party_id		alias for $1;
begin

  return email from parties where party_id = email__party_id;

end;$_$;


--
-- Name: party__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION party__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  party_id               alias for $1;  
begin
  if party_id = -1 then
   return 'The Public';
  else
   return null;
  end if;
  
end;$_$;


--
-- Name: party__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION party__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__party_id               alias for $1;  -- default null  
  new__object_type            alias for $2;  -- default 'party'
  new__creation_date          alias for $3;  -- default now()
  new__creation_user          alias for $4;  -- default null
  new__creation_ip            alias for $5;  -- default null
  new__email                  alias for $6;  
  new__url                    alias for $7;  -- default null
  new__context_id             alias for $8;  -- default null
  v_party_id                  parties.party_id%TYPE;
begin
  v_party_id :=
   acs_object__new(new__party_id, new__object_type, new__creation_date, 
                   new__creation_user, new__creation_ip, new__context_id,
                   't', new__email, null);

  insert into parties
   (party_id, email, url)
  values
   (v_party_id, lower(new__email), new__url);

  return v_party_id;
  
end;$_$;


--
-- Name: party_approved_member__add(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION party_approved_member__add(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_party_id alias for $1;
  p_member_id alias for $2;
  p_rel_id alias for $3;
  p_rel_type alias for $4;
  v_segments record;
begin

  perform party_approved_member__add_one(p_party_id, p_member_id, p_rel_id);

  -- if the relation type is mapped to relational segments unmap them too

  for v_segments in select segment_id
                  from rel_segments s, acs_object_types o1, acs_object_types o2
                  where 
                    o1.object_type = p_rel_type
                    and o1.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey)
                    and s.rel_type = o2.object_type
                    and s.group_id = p_party_id
  loop
    perform party_approved_member__add_one(v_segments.segment_id, p_member_id, p_rel_id);
  end loop;

  return 1;

end;$_$;


--
-- Name: party_approved_member__add_one(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION party_approved_member__add_one(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_party_id alias for $1;
  p_member_id alias for $2;
  p_rel_id alias for $3;
begin

  insert into party_approved_member_map
    (party_id, member_id, tag)
  values
    (p_party_id, p_member_id, p_rel_id);

  return 1;

end;$_$;


--
-- Name: party_approved_member__remove(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION party_approved_member__remove(integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_party_id alias for $1;
  p_member_id alias for $2;
  p_rel_id alias for $3;
  p_rel_type alias for $4;
  v_segments record;
begin

  perform party_approved_member__remove_one(p_party_id, p_member_id, p_rel_id);

  -- if the relation type is mapped to relational segments unmap them too

  for v_segments in select segment_id
                  from rel_segments s, acs_object_types o1, acs_object_types o2
                  where 
                    o1.object_type = p_rel_type
                    and o1.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey)
                    and s.rel_type = o2.object_type
                    and s.group_id = p_party_id
  loop
    perform party_approved_member__remove_one(v_segments.segment_id, p_member_id, p_rel_id);
  end loop;

  return 1;

end;$_$;


--
-- Name: party_approved_member__remove_one(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION party_approved_member__remove_one(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_party_id alias for $1;
  p_member_id alias for $2;
  p_rel_id alias for $3;
begin

  delete from party_approved_member_map
  where party_id = p_party_id
    and member_id = p_member_id
    and tag = p_rel_id;

  return 1;

end;$_$;


--
-- Name: person__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION person__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__person_id     alias for $1;  
begin
  delete from persons
  where person_id = delete__person_id;

  PERFORM party__delete(delete__person_id);

  return 0; 
end;$_$;


--
-- Name: person__first_names(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION person__first_names(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  first_names__person_id        alias for $1;  
begin
  return first_names
  from persons
  where person_id = first_names__person_id;
  
end;$_$;


--
-- Name: person__last_name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION person__last_name(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  last_name__person_id        alias for $1;  
begin
  return last_name
  from persons
  where person_id = last_name__person_id;

end;$_$;


--
-- Name: person__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION person__name(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  name__person_id        alias for $1;
begin
return first_names || ' ' || substr(last_name,1,1)
from persons
where person_id = name__person_id;
end;$_$;


--
-- Name: person__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION person__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__person_id              alias for $1;  -- default null  
  new__object_type            alias for $2;  -- default 'person'
  new__creation_date          alias for $3;  -- default now()
  new__creation_user          alias for $4;  -- default null
  new__creation_ip            alias for $5;  -- default null
  new__email                  alias for $6;  
  new__url                    alias for $7;  -- default null
  new__first_names            alias for $8; 
  new__last_name              alias for $9;  
  new__context_id             alias for $10; -- default null 
  v_person_id                 persons.person_id%TYPE;
begin
  v_person_id :=
   party__new(new__person_id, new__object_type,
             new__creation_date, new__creation_user, new__creation_ip,
             new__email, new__url, new__context_id);

  update acs_objects
  set title = new__first_names || ' ' || new__last_name
  where object_id = v_person_id;

  insert into persons
   (person_id, first_names, last_name)
  values
   (v_person_id, new__first_names, new__last_name);

  return v_person_id;
  
end;$_$;


--
-- Name: pinds_blog_category__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pinds_blog_category__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id alias for $1;
begin
    update pinds_blog_entries
        set category_id = null
        where category_id = p_category_id;

    delete from pinds_blog_categories
        where category_id = p_category_id;

    PERFORM acs_object__delete(p_category_id);
    return 0;
end;
$_$;


--
-- Name: pinds_blog_category__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pinds_blog_category__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id     alias for $1;
    v_name            varchar;
begin
    select name into v_name
        from pinds_blog_categories
        where category_id = p_category_id;
    return v_name;
end;
$_$;


--
-- Name: pinds_blog_category__new(integer, integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pinds_blog_category__new(integer, integer, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id          alias for $1;
    p_package_id           alias for $2;
    p_name                 alias for $3;
    p_short_name           alias for $4;
    p_creation_user        alias for $5;
    p_creation_ip          alias for $6;
    v_category_id          integer;
begin
    v_category_id := acs_object__new (
        p_category_id,
        'pinds_blog_category',
        current_timestamp,
        p_creation_user,
        p_creation_ip,
        p_package_id
    );

    insert into pinds_blog_categories (
      category_id, 
      package_id,
      name,
      short_name
    ) values (
      v_category_id, 
      p_package_id,
      p_name,
      p_short_name
    );

    return v_category_id;   
end;
$_$;


--
-- Name: pinds_blog_entry__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pinds_blog_entry__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_entry_id alias for $1;
    comment_rec         record;
begin
    -- delete comments associated with this entry
    for comment_rec in select gc.comment_id 
                         from general_comments gc
                         where gc.object_id = p_entry_id loop
        perform acs_message__delete(comment_rec.comment_id);
    end loop;

    delete from pinds_blog_entries
        where entry_id = p_entry_id;
    PERFORM acs_object__delete(p_entry_id);
    return 0;
end;
$_$;


--
-- Name: pinds_blog_entry__new(integer, integer, character varying, character varying, integer, character varying, character varying, timestamp with time zone, character, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pinds_blog_entry__new(integer, integer, character varying, character varying, integer, character varying, character varying, timestamp with time zone, character, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_entry_id             alias for $1;
    p_package_id           alias for $2;
    p_title                alias for $3;
    p_title_url            alias for $4;
    p_category_id          alias for $5;
    p_content              alias for $6;
    p_content_format       alias for $7;
    p_entry_date           alias for $8;
    p_draft_p              alias for $9;
    p_creation_user        alias for $10;
    p_creation_ip          alias for $11;
    v_entry_id             integer;
begin
    v_entry_id := acs_object__new (
        p_entry_id,
        'pinds_blog_entry',
        current_timestamp,
        p_creation_user,
        p_creation_ip,
        p_package_id
    );

    insert into pinds_blog_entries (
      entry_id, 
      package_id,
      title,
      title_url,
      category_id,
      content,
      content_format,
      entry_date,
      draft_p,
      deleted_p
    ) values (
      v_entry_id, 
      p_package_id,
      p_title,
      p_title_url,
      p_category_id,
      p_content,
      p_content_format,
      p_entry_date,
      p_draft_p,
      'f'
    );

    PERFORM acs_permission__grant_permission(
        v_entry_id,
	p_creation_user,
	'admin'
    );

    return v_entry_id;   
end;
$_$;


--
-- Name: pinds_blog_entry__title(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pinds_blog_entry__title(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_entry_id        alias for $1;
    v_title           varchar;
begin
    select title into v_title
        from pinds_blog_entries
        where entry_id = p_entry_id;
    return v_title;
end;
$_$;


--
-- Name: plpgsql_call_handler(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION plpgsql_call_handler() RETURNS language_handler
    LANGUAGE c
    AS '$libdir/plpgsql', 'plpgsql_call_handler';


--
-- Name: plpgsql_validator(oid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION plpgsql_validator(oid) RETURNS void
    LANGUAGE c
    AS '$libdir/plpgsql', 'plpgsql_validator';


--
-- Name: priv_recurse_subtree(bit varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION priv_recurse_subtree(bit varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        nkey            alias for $1;
        child_priv      alias for $2;
        new_value       integer;
        v_rec           record;
        new_key         varbit;
begin

        -- now iterate over all of the children of the 
        -- previous node.
        
        for v_rec in select privilege, child_privilege
                       from acs_privilege_hierarchy
                      where privilege = child_priv

        LOOP

            -- calculate the next key for this level and parent

            select max(tree_leaf_key_to_int(tree_sortkey)) into new_value
              from acs_privilege_hierarchy_index
             where tree_sortkey between nkey and tree_right(nkey)
               and tree_level(tree_sortkey) = tree_level(nkey) + 1;

            new_key := tree_next_key(nkey, new_value);

            -- insert the new child node.

            insert into acs_privilege_hierarchy_index
                        (privilege, child_privilege, tree_sortkey)
                        values
                        (v_rec.privilege, v_rec.child_privilege, new_key);

            -- keep recursing down until no more children are found

            PERFORM priv_recurse_subtree(new_key, v_rec.child_privilege);

        end LOOP;

        -- no children found, so insert the child node as its own separate 
        -- node.

        if NOT FOUND then
           insert into acs_privilege_hierarchy_index
                       (privilege, child_privilege, tree_sortkey)
                       values 
                       (child_priv, child_priv, tree_next_key(nkey, null));
        end if;

        return null;

end;$_$;


--
-- Name: rawtohex(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rawtohex(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
        arg     alias for $1;
begin
        raise exception 'not implemented yet: depends on java code in acs classic';
        return '';
end;$_$;


--
-- Name: rdbms_date(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rdbms_date(character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  p_raw_date alias for $1;
begin
  return "timestamptz" (p_raw_date || '+00');
end;$_$;


--
-- Name: recurrence__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION recurrence__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
       delete__recurrence_id alias for $1; 
begin

       delete from recurrences
       where  recurrence_id = delete__recurrence_id;

       return 0;

end;$_$;


--
-- Name: recurrence__new(character varying, integer, character varying, timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION recurrence__new(character varying, integer, character varying, timestamp with time zone, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- recurrences.recurrence_id%TYPE
declare
       new__interval_name	  alias for $1; 
       new__every_nth_interval   alias for $2;
       new__days_of_week         alias for $3; -- default null,
       new__recur_until          alias for $4; -- default null,
       new__custom_func          alias for $5; -- default null
       v_recurrence_id		  recurrences.recurrence_id%TYPE;
       v_interval_type_id	  recurrence_interval_types.interval_type%TYPE;
begin

       select recurrence_seq.nextval into v_recurrence_id from dual;
        
       select interval_type
       into   v_interval_type_id 
       from   recurrence_interval_types
       where  interval_name = new__interval_name;
        
       insert into recurrences
            (recurrence_id, 
             interval_type, 
             every_nth_interval, 
             days_of_week,
             recur_until, 
             custom_func)
       values
            (v_recurrence_id, 
             v_interval_type_id, 
             new__every_nth_interval, 
             new__days_of_week,
             new__recur_until, 
             new__custom_func);
         
       return v_recurrence_id;

end;$_$;


--
-- Name: rel_constraint__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_constraint__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  constraint_id          alias for $1;  
begin
    PERFORM acs_object__delete(constraint_id);

    return 0; 
end;$_$;


--
-- Name: rel_constraint__get_constraint_id(integer, character, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_constraint__get_constraint_id(integer, character, integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get_constraint_id__rel_segment            alias for $1;  
  get_constraint_id__rel_side               alias for $2;  
  get_constraint_id__required_rel_segment   alias for $3;  
  v_constraint_id                           rel_constraints.constraint_id%TYPE;
begin
    return constraint_id
    from rel_constraints
    where rel_segment = get_constraint_id__rel_segment
      and rel_side = get_constraint_id__rel_side
      and required_rel_segment = get_constraint_id__required_rel_segment;

end;$_$;


--
-- Name: rel_constraint__new(character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_constraint__new(character varying, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        nam     alias for $1;
        sid1    alias for $2;
        side    alias for $3;
        sid2    alias for $4;
begin
        return rel_constraint__new(null,
                                   'rel_constraint',
                                   nam,
                                   sid1,
                                   side,
                                   sid2,
                                   null,
                                   null,
                                   null
                                   );                                   
end;$_$;


--
-- Name: rel_constraint__new(integer, character varying, character varying, integer, character, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_constraint__new(integer, character varying, character varying, integer, character, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__constraint_id          alias for $1;  -- default null  
  new__constraint_type        alias for $2;  -- default 'rel_constraint'
  new__constraint_name        alias for $3;  
  new__rel_segment            alias for $4;  
  new__rel_side               alias for $5;  -- default 'two'
  new__required_rel_segment   alias for $6;  
  new__context_id             alias for $7;  -- default null
  new__creation_user          alias for $8;  -- default null
  new__creation_ip            alias for $9;  -- default null
  v_constraint_id             rel_constraints.constraint_id%TYPE;
begin
    v_constraint_id := acs_object__new (
      new__constraint_id,
      new__constraint_type,
      now(),
      new__creation_user,
      new__creation_ip,
      new__context_id,
      't',
      new__constraint_name,
      null
    );

    insert into rel_constraints
     (constraint_id, constraint_name, 
      rel_segment, rel_side, required_rel_segment)
    values
     (v_constraint_id, new__constraint_name, 
      new__rel_segment, new__rel_side, new__required_rel_segment);

     return v_constraint_id;
   
end;$_$;


--
-- Name: rel_constraint__violation(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_constraint__violation(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  violation__rel_id                 alias for $1;  
  v_error                           text; 
  constraint_violated               record;
begin

    v_error := null;

    for constraint_violated in
     select constraint_id, constraint_name
       from rel_constraints_violated_one
       where rel_id = violation__rel_id
       LIMIT 1 
    LOOP

	  v_error := coalesce(v_error,'') || 
                     'Relational Constraint Violation: ' ||
                     constraint_violated.constraint_name || 
                     ' (constraint_id=' ||
                     constraint_violated.constraint_id || '). ';

          return v_error;
    end loop;

    for constraint_violated in
     select constraint_id, constraint_name
       from rel_constraints_violated_two
      where rel_id = violation__rel_id
      LIMIT 1 
    LOOP

           v_error := coalesce(v_error,'') || 
                      'Relational Constraint Violation: ' ||
                      constraint_violated.constraint_name || 
                      ' (constraint_id=' ||
                      constraint_violated.constraint_id || '). ';

           return v_error;
    end loop;

    return v_error;
   
end;$_$;


--
-- Name: rel_constraint__violation_if_re(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_constraint__violation_if_re(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  violation_if_removed__rel_id                 alias for $1;  
  v_count                                      integer;       
  v_error                                      text; 
  constraint_violated                          record;
begin
    v_error := null;

    select count(*) into v_count
      from dual
     where exists (select 1 
                     from rc_violations_by_removing_rel r 
                    where r.rel_id = violation_if_removed__rel_id);

    if v_count > 0 then
      -- some other relation depends on this one. Lets build up a string
      -- of the constraints we are violating
      for constraint_violated in select constraint_id, constraint_name
                                   from rc_violations_by_removing_rel r
                                  where r.rel_id = violation_if_removed__rel_id 
      LOOP

          v_error := v_error || 'Relational Constraint Violation: ' ||
                     constraint_violated.constraint_name || 
                     ' (constraint_id=' ||
                     constraint_violated.constraint_id || '). ';

      end loop;

    end if;

    return v_error;

   
end;$_$;


--
-- Name: rel_constraint__violation_if_removed(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_constraint__violation_if_removed(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  violation_if_removed__rel_id                 alias for $1;  
  v_count                                      integer;       
  v_error                                      text; 
  constraint_violated                          record;
begin
    v_error := null;

    select count(*) into v_count
      from dual
     where exists (select 1 
                     from rc_violations_by_removing_rel r 
                    where r.rel_id = violation_if_removed__rel_id);

    if v_count > 0 then
      -- some other relation depends on this one. Lets build up a string
      -- of the constraints we are violating
      for constraint_violated in select constraint_id, constraint_name
                                   from rc_violations_by_removing_rel r
                                  where r.rel_id = violation_if_removed__rel_id 
      LOOP

          v_error := v_error || 'Relational Constraint Violation: ' ||
                     constraint_violated.constraint_name || 
                     ' (constraint_id=' ||
                     constraint_violated.constraint_id || '). ';

      end loop;

    end if;

    return v_error;

   
end;$_$;


--
-- Name: rel_constraints_del_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_constraints_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_rec   record;
begin

        -- now update the rel_segments that depend on this segment
        
        for v_rec in select rel_segment 
                       from rc_segment_required_seg_map
                      where required_rel_segment = old.rel_segment 
                        and rel_side = old.rel_side
        LOOP

                delete from rc_segment_required_seg_map
                      where rel_segment = v_rec.rel_segment
                        and rel_side = old.rel_side
                        and required_rel_segment 
                            in (select required_rel_segment
                                  from rc_segment_required_seg_map
                                 where rel_segment = old.rel_segment
                                   and rel_side = old.rel_side);
                
        end LOOP;

        -- delete dependencies

        delete from rc_segment_required_seg_map
              where rel_segment = old.rel_segment
                and rel_side = old.rel_side
                and required_rel_segment 
                    in (select required_rel_segment
                          from rc_segment_required_seg_map
                         where rel_segment = old.required_rel_segment
                           and rel_side = old.rel_side);

        -- delete the constraint

        delete from rc_segment_required_seg_map
              where rel_segment = old.rel_segment
                and rel_side = old.rel_side 
                and required_rel_segment = old.required_rel_segment;

        return old;

end;$$;


--
-- Name: rel_constraints_ins_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_constraints_ins_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_rec   record;
begin
        -- insert the constraint

        insert into rc_segment_required_seg_map
               (rel_segment, rel_side, required_rel_segment)
               values
               (new.rel_segment, new.rel_side, new.required_rel_segment);

        -- add dependencies

        insert into rc_segment_required_seg_map
             select new.rel_segment, new.rel_side, required_rel_segment
               from rc_segment_required_seg_map
              where rel_segment = new.required_rel_segment
                and rel_side = new.rel_side;

        -- now update the rel_segments that depend on this segment
        
        for v_rec in select rel_segment 
                       from rc_segment_required_seg_map
                      where required_rel_segment = new.rel_segment 
                        and rel_side = new.rel_side
        LOOP
                insert into rc_segment_required_seg_map
                     select v_rec.rel_segment, new.rel_side, 
                            required_rel_segment
                       from rc_segment_required_seg_map
                      where rel_segment = new.rel_segment
                        and rel_side = new.rel_side;
                
        end LOOP;

        return new;

end;$$;


--
-- Name: rel_segment__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_segment__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__segment_id            alias for $1;  
  row                           record;
begin

   -- remove all constraints on this segment
   for row in  select constraint_id 
                 from rel_constraints 
                where rel_segment = delete__segment_id 
   LOOP

       PERFORM rel_constraint__delete(row.constraint_id);

   end loop;

   PERFORM party__delete(delete__segment_id);

   return 0; 
end;$_$;


--
-- Name: rel_segment__get(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_segment__get(integer, character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  get__group_id         alias for $1;  
  get__rel_type         alias for $2;  
begin

   return min(segment_id)
   from rel_segments
   where group_id = get__group_id
     and rel_type = get__rel_type;
  
end;$_$;


--
-- Name: rel_segment__get_or_new(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_segment__get_or_new(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        gid     alias for $1;
        typ     alias for $2;
begin
        return rel_segment__get_or_new(gid,typ,null);
end;$_$;


--
-- Name: rel_segment__get_or_new(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_segment__get_or_new(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  get_or_new__group_id          alias for $1;  
  get_or_new__rel_type          alias for $2;  
  segment_name                  alias for $3;  -- default null
  v_segment_id                  rel_segments.segment_id%TYPE;
  v_segment_name                rel_segments.segment_name%TYPE;
begin

   v_segment_id := rel_segment__get(get_or_new__group_id,get_or_new__rel_type);

   if v_segment_id is null then

      if segment_name is not null then
         v_segment_name := segment_name;
      else
         select groups.group_name || ' - ' || acs_object_types.pretty_name ||
                  ' segment'
         into v_segment_name
         from groups, acs_object_types
         where groups.group_id = get_or_new__group_id
           and acs_object_types.object_type = get_or_new__rel_type;

      end if;

      v_segment_id := rel_segment__new (
          null,
          'rel_segment',
          now(),
          null,
          null,
          null,
          null,
          v_segment_name,
          get_or_new__group_id,
          get_or_new__rel_type,
          get_or_new__group_id
      );

   end if;

   return v_segment_id;

  
end;$_$;


--
-- Name: rel_segment__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_segment__name(integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  name__segment_id             alias for $1;  
  name__segment_name           varchar(200);  
begin
  return segment_name
  from rel_segments
  where segment_id = name__segment_id;

end;$_$;


--
-- Name: rel_segment__new(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_segment__new(character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__segment_name      alias for $1;
  new__group_id          alias for $2;
  new__rel_type          alias for $3;
  v_segment_id           rel_segments.segment_id%TYPE;
begin

   v_segment_id := rel_segment__new(null, 'rel_segment', now(), null, null, null, null, new__segment_name, new__group
_id, new__rel_type, null);

   return v_segment_id;

end;$_$;


--
-- Name: rel_segment__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_segment__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__segment_id        alias for $1;  -- default null  
  object_type            alias for $2;  -- default 'rel_segment'
  creation_date          alias for $3;  -- default now()
  creation_user          alias for $4;  -- default null
  creation_ip            alias for $5;  -- default null
  email                  alias for $6;  -- default null
  url                    alias for $7;  -- default null
  new__segment_name      alias for $8;  
  new__group_id          alias for $9;  
  new__rel_type          alias for $10; 
  context_id             alias for $11; -- default null
  v_segment_id           rel_segments.segment_id%TYPE;
begin
  v_segment_id :=
   party__new(new__segment_id, object_type, creation_date, creation_user,
             creation_ip, email, url, context_id);

  update acs_objects
  set title = new__segment_name
  where object_id = v_segment_id;

  insert into rel_segments
   (segment_id, segment_name, group_id, rel_type)
  values
   (v_segment_id, new__segment_name, new__group_id, new__rel_type);

  return v_segment_id;
  
end;$_$;


--
-- Name: rel_segments_del_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_segments_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

  delete from party_approved_member_map
  where party_id = old.segment_id
    and member_id in (select element_id
                      from group_element_index
                      where group_id = old.group_id
                        and rel_type = old.rel_type);

  return old;

end;$$;


--
-- Name: rel_segments_in_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rel_segments_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

  insert into party_approved_member_map
    (party_id, member_id, tag)
  select new.segment_id, element_id, rel_id
    from group_element_index
    where group_id = new.group_id
      and rel_type = new.rel_type;

  return new;

end;$$;


--
-- Name: rl_resource__delete_item(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rl_resource__delete_item(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_resource_item_id                      alias for $1;
begin
        raise NOTICE 'Deleting rl_resource...';

	delete from acs_permissions
		where object_id = p_resource_item_id;

        delete from rl_resource_category_map where resource_item_id = p_resource_item_id;
        
        delete from rl_resources_revisions where resource_revision_id in (select revision_id from cr_revisions where item_id = p_resource_item_id);

	delete from rl_resources
		where resource_item_id = p_resource_item_id;

        PERFORM content_item__delete(p_resource_item_id);
        return 0;
end;$_$;


--
-- Name: rl_resource__get_root_folder(integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rl_resource__get_root_folder(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_package_id		alias for $1;
        p_create_if_not_present_p alias for $2;

	v_folder_id		cr_folders.folder_id%TYPE;
	v_count			integer;
begin

        -- raise notice 'in get root folder p_create_if_not_present_p = %',p_create_if_not_present_p;

	select count(*) into v_count
	from cr_folders
	where package_id = p_package_id;

        -- raise notice 'count is % for package_id %', v_count, p_package_id;

	if v_count > 1 then
                raise exception 'More than one repository for this application instance';
	elsif v_count = 1 then
                select folder_id into v_folder_id
                from cr_folders 
                where package_id = p_package_id;
	else
                if p_create_if_not_present_p = true then
        		-- Must be a new instance.  Create a new root folder.
                        raise notice 'creating a new root repository folder';
	        	v_folder_id := rl_resource__new_root_folder(p_package_id);
                else
                        -- raise notice 'setting to null';
                        v_folder_id := null;
                end if;
        end if;

        -- raise notice 'v_folder_id is %', v_folder_id;

	return v_folder_id;

end; $_$;


--
-- Name: rl_resource__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rl_resource__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_rl_resource_item_id    alias for $1;
begin
    return p_rl_resource_item_id;
end;
$_$;


--
-- Name: rl_resource__new_item(integer, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rl_resource__new_item(integer, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_resource_item_id                      alias for $1;
	p_resource_name				alias for $2;
	p_description				alias for $3;
	p_creation_date				alias for $4;
	p_creation_user				alias for $5;
	p_creation_ip				alias for $6;
	p_package_id				alias for $7;

	v_item_id		cr_items.item_id%TYPE;
	v_revision_id		cr_revisions.revision_id%TYPE;
	v_id			cr_items.item_id%TYPE;
	v_resource_item_id      integer;
	v_resource_number       cr_items.item_id%TYPE;
	v_parent_id		cr_items.parent_id%TYPE;
begin
	select acs_object_id_seq.nextval into v_id from dual;

        v_parent_id := rl_resource__get_root_folder (p_package_id, 't');

        -- raise notice 'v_parent_id (%) p_parent_id (%)', v_parent_id, p_parent_id;

	v_item_id := content_item__new (
		v_id::varchar,	        -- name
		v_parent_id,		-- parent_id
		v_id,			-- item_id
		null,			-- locale
		now(),			-- creation_date
		p_creation_user,	-- creation_user
		v_parent_id,		-- context_id
		p_creation_ip,		-- creation_ip
		'content_item',	-- item_subtype
		'rl_resource',        -- content_type
		p_resource_name,        -- title
		p_description,		-- description
		'text/plain',		-- mime_type
		null,			-- nls_language
		null			-- data
	);

	v_revision_id := content_revision__new (
		p_resource_name,        -- title
		p_description,          -- description
		now(),			-- publish_date
		'text/plain',		-- mime_type
		NULL,			-- nls_language
		NULL,			-- data
		v_item_id,		-- item_id
		NULL,			-- revision_id
		now(),			-- creation_date
		p_creation_user,	-- creation_user
		p_creation_ip		-- creation_ip
	);

	PERFORM content_item__set_live_revision (v_revision_id);

        -- select nextval('rl_resources_number_seq.nextval') into v_resource_number from dual;

	insert into rl_resources (
		resource_item_id, resource_number, approved_p)
	values (
		v_item_id, v_id, 'f');

	insert into rl_resources_revisions (
		resource_revision_id) 
	values (
                v_revision_id);

	PERFORM acs_permission__grant_permission(
		v_revision_id,
		p_creation_user,
		'admin'
	);

	return v_revision_id;
end;$_$;


--
-- Name: rl_resource__new_name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rl_resource__new_name(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	p_package_id		alias for $1;

	v_name			cr_items.name%TYPE;
	v_package_key		apm_packages.package_key%TYPE;
	v_id			integer;
begin
	select package_key into v_package_key from apm_packages
	    where package_id = p_package_id;

	select acs_object_id_seq.nextval into v_id from dual;

	-- Set the name
	select v_package_key || '_' || 
	    to_char(current_timestamp, 'YYYYMMDD') || '_' ||
	    v_id into v_name;

	return v_name;
end;$_$;


--
-- Name: rl_resource__new_revision(integer, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rl_resource__new_revision(integer, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_resource_item_id                      alias for $1;
	p_resource_name	                        alias for $2;
	p_description				alias for $3;
	p_creation_date				alias for $4;
	p_creation_user				alias for $5;
	p_creation_ip				alias for $6;
	p_package_id				alias for $7;

	v_revision_id		cr_revisions.revision_id%TYPE;
begin

        -- the item_id is the resource_id

	v_revision_id := content_revision__new (
		p_resource_name,        -- title
		p_description,		-- description
		now(),			-- publish_date
		'text/plain',		-- mime_type
		NULL,			-- nls_language
		NULL,			-- data
		p_resource_item_id,     -- item_id
		NULL,			-- revision_id
		now(),			-- creation_date
		p_creation_user,	-- creation_user
		p_creation_ip		-- creation_ip
	);

	PERFORM content_item__set_live_revision (v_revision_id);

	insert into rl_resources_revisions (
		resource_revision_id) 
	values (
                v_revision_id);

	PERFORM acs_permission__grant_permission(
		v_revision_id,
		p_creation_user,
		'admin'
	);

	return v_revision_id;
end;$_$;


--
-- Name: rl_resource__new_root_folder(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rl_resource__new_root_folder(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_package_id            alias for $1;

        v_folder_id             cr_folders.folder_id%TYPE;
        v_folder_name           cr_items.name%TYPE;
begin

        raise notice 'in new root folder';

        -- Set the folder name
        v_folder_name := rl_resource__new_name (p_package_id);

        v_folder_id := content_folder__new (
            v_folder_name,                              -- name
            'Resources',                              -- label
            'Resources Repository',                   -- description
            null,                                       -- parent_id
            p_package_id,                               -- context_id
            null,                                       -- folder_id
            null,                                       -- creation_date
            null,                                       -- creation_user
            null                                        -- creation_ip
        );

        -- Register the standard content types
        PERFORM content_folder__register_content_type (
                v_folder_id,            -- folder_id
                'rl_resource',        -- content_type
                'f'                   -- include_subtypes
        );

        -- there is no facility in the API for adding in the package_id,
        -- so we have to do it ourselves

        update cr_folders 
        set package_id = p_package_id 
        where folder_id = v_folder_id;

        -- TODO: Handle Permissions here for this folder.

        return v_folder_id;
end;$_$;


--
-- Name: rss_gen_subscr__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rss_gen_subscr__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_subscr_id     alias for $1;
begin
	delete from acs_permissions
		   where object_id = p_subscr_id;

	delete from rss_gen_subscrs
		   where subscr_id = p_subscr_id;

	raise NOTICE 'Deleting subscription...';
	PERFORM acs_object__delete(p_subscr_id);

	return 0;

end;$_$;


--
-- Name: rss_gen_subscr__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rss_gen_subscr__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_subscr_id     alias for $1;
begin
  return rss_gen_subscr__del (p_subscr_id);
end;$_$;


--
-- Name: rss_gen_subscr__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rss_gen_subscr__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_subscr_id				alias for $1;
begin
	return 'RSS Generation Subscription #' || p_subscr_id;
end;$_$;


--
-- Name: rss_gen_subscr__new(integer, integer, character varying, integer, timestamp with time zone, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rss_gen_subscr__new(integer, integer, character varying, integer, timestamp with time zone, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_subscr_id			alias for $1;
  p_impl_id			alias for $2;
  p_summary_context_id		alias for $3;
  p_timeout			alias for $4;
  p_lastbuild			alias for $5;
  p_object_type			alias for $6;           -- default 'rss_gen_subscr'
  p_creation_date		alias for $7;		-- default now()
  p_creation_user		alias for $8;		-- default null
  p_creation_ip			alias for $9;		-- default null
  p_context_id			alias for $10;		-- default null
  v_subscr_id			rss_gen_subscrs.subscr_id%TYPE;
  v_summary_context_id  rss_gen_subscrs.summary_context_id%TYPE;
begin
	v_subscr_id := acs_object__new (
		p_subscr_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);

        if p_summary_context_id is null then
          v_summary_context_id := v_subscr_id;
        else
          v_summary_context_id := p_summary_context_id;
        end if;

	insert into rss_gen_subscrs
	  (subscr_id, impl_id, summary_context_id, timeout, lastbuild)
	values
	  (v_subscr_id, p_impl_id, v_summary_context_id, p_timeout, p_lastbuild);

	return v_subscr_id;

end;$_$;


--
-- Name: rule_exists(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rule_exists(character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
declare
        rule_name       alias for $1;
        table_name      alias for $2;
begin
        return count(*) = 1
          from pg_rules
         where tablename::varchar = lower(table_name)
           and rulename::varchar = lower(rule_name);

end;$_$;


--
-- Name: search_observer__dequeue(integer, timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION search_observer__dequeue(integer, timestamp with time zone, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id                 alias for $1;
    p_event_date                alias for $2;
    p_event                     alias for $3;
begin

    delete from search_observer_queue
    where object_id = p_object_id
    and event = p_event
    and event_date = p_event_date;

    return 0;

end;$_$;


--
-- Name: search_observer__enqueue(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION search_observer__enqueue(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id			alias for $1;
    p_event			alias for $2;
begin
    insert into search_observer_queue (
	object_id,
	event
    ) values (
        p_object_id,
	p_event
    );

    return 0;

end;$_$;


--
-- Name: site_node__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__node_id                alias for $1;  
begin
    delete from site_nodes
    where node_id = delete__node_id;

    PERFORM acs_object__delete(delete__node_id);

    return 0; 
end;$_$;


--
-- Name: site_node__find_pattern(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node__find_pattern(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  find_pattern__node_id         alias for $1;  
  v_pattern_p                   site_nodes.pattern_p%TYPE;
  v_parent_id                   site_nodes.node_id%TYPE;
begin
    if find_pattern__node_id is null then
--      raise no_data_found;
        raise exception 'NO DATA FOUND';
    end if;

    select pattern_p, parent_id into v_pattern_p, v_parent_id
    from site_nodes
    where node_id = find_pattern__node_id;

    if v_pattern_p = 't' then
      return find_pattern__node_id;
    else
      return site_node__find_pattern(v_parent_id);
    end if;
   
end;$_$;


--
-- Name: site_node__new(integer, integer, character varying, integer, boolean, boolean, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node__new(integer, integer, character varying, integer, boolean, boolean, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__node_id                alias for $1;  -- default null  
  new__parent_id              alias for $2;  -- default null    
  new__name                   alias for $3;  
  new__object_id              alias for $4;   -- default null   
  new__directory_p            alias for $5;  
  new__pattern_p              alias for $6;   -- default 'f' 
  new__creation_user          alias for $7;   -- default null   
  new__creation_ip            alias for $8;   -- default null   
  v_node_id                   site_nodes.node_id%TYPE;
  v_directory_p               site_nodes.directory_p%TYPE;
begin
    if new__parent_id is not null then
      select directory_p into v_directory_p
      from site_nodes
      where node_id = new__parent_id;

      if v_directory_p = 'f' then
        raise EXCEPTION '-20000: Node % is not a directory', new__parent_id;
      end if;
    end if;

    v_node_id := acs_object__new (
      new__node_id,
      'site_node',
      now(),
      new__creation_user,
      new__creation_ip,
      null,
      't',
      new__name,
      new__object_id
    );

    insert into site_nodes
     (node_id, parent_id, name, object_id, directory_p, pattern_p)
    values
     (v_node_id, new__parent_id, new__name, new__object_id,
      new__directory_p, new__pattern_p);

     return v_node_id;
   
end;$_$;


--
-- Name: site_node__node_id(character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node__node_id(character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  node_id__url           alias for $1;  
  node_id__parent_id     alias for $2;  -- default null  
  v_pos                  integer;       
  v_first                site_nodes.name%TYPE;
  v_rest                 text; 
  v_node_id              integer;       
  v_pattern_p            site_nodes.pattern_p%TYPE;
  v_url                  text; 
  v_directory_p          site_nodes.directory_p%TYPE;
  v_trailing_slash_p     boolean;       
begin
    v_url := node_id__url;

    if substr(v_url, length(v_url), 1) = '/' then
      -- It ends with a / so it must be a directory.
      v_trailing_slash_p := 't';
      v_url := substr(v_url, 1, length(v_url) - 1);
    end if;

    v_pos := 1;

    while v_pos <= length(v_url) and substr(v_url, v_pos, 1) <> '/' loop
      v_pos := v_pos + 1;
    end loop;

    if v_pos = length(v_url) then
      v_first := v_url;
      v_rest := null;
    else
      v_first := substr(v_url, 1, v_pos - 1);
      v_rest := substr(v_url, v_pos + 1);
    end if;

    -- begin
      -- Is there a better way to do these freaking null compares?
      select node_id, directory_p into v_node_id, v_directory_p
      from site_nodes
      where coalesce(parent_id, 3.14) = coalesce(node_id__parent_id, 3.14)
      and coalesce(name, chr(10)) = coalesce(v_first, chr(10));
    if NOT FOUND then 
        return site_node__find_pattern(node_id__parent_id);
    end if;

    if v_rest is null then
      if v_trailing_slash_p = 't' and v_directory_p = 'f' then
        return site_node__find_pattern(node_id__parent_id);
      else
        return v_node_id;
      end if;
    else
      return site_node__node_id(v_rest, v_node_id);
    end if;


end;$_$;


--
-- Name: site_node__url(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node__url(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  url__node_id           alias for $1;  
  v_parent_id            site_nodes.node_id%TYPE;
  v_name                 site_nodes.name%TYPE;
  v_directory_p          site_nodes.directory_p%TYPE;
begin
    if url__node_id is null then
      return '';
    end if;

    select parent_id, name, directory_p into
           v_parent_id, v_name, v_directory_p
    from site_nodes
    where node_id = url__node_id;

    if v_directory_p = 't' then
      return site_node__url(v_parent_id) || v_name || '/';
    else
      return site_node__url(v_parent_id) || v_name;
    end if;
   
end;$_$;


--
-- Name: site_node_get_tree_sortkey(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node_get_tree_sortkey(integer) RETURNS bit varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_node_id         alias for $1;
begin
  return tree_sortkey from site_nodes where node_id = p_node_id;
end;$_$;


--
-- Name: site_node_insert_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk     varbit default null;
        v_max_value     integer;
begin
        if new.parent_id is null then
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
              from site_nodes 
             where parent_id is null;
        else
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
              from site_nodes 
             where parent_id = new.parent_id;

            select tree_sortkey into v_parent_sk 
              from site_nodes 
             where node_id = new.parent_id;
        end if;

        new.tree_sortkey := tree_next_key(v_parent_sk, v_max_value);

        return new;

end;$$;


--
-- Name: site_node_object_map__del(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node_object_map__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id                     alias for $1;
begin
    delete
    from site_node_object_mappings
    where object_id = p_object_id;

    return 0;
end;
$_$;


--
-- Name: site_node_object_map__new(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node_object_map__new(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_object_id                     alias for $1;
    p_node_id                       alias for $2;
begin
    perform site_node_object_map__del(p_object_id);

    insert
    into site_node_object_mappings
    (object_id, node_id)
    values
    (p_object_id, p_node_id);

    return 0;
end;
$_$;


--
-- Name: site_node_update_tr(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION site_node_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_parent_sk     varbit default null;
        v_max_value     integer;
        p_id            integer;
        v_rec           record;
        clr_keys_p      boolean default 't';
begin
        if new.node_id = old.node_id and 
           ((new.parent_id = old.parent_id) or 
            (new.parent_id is null and old.parent_id is null)) then

           return new;

        end if;

        for v_rec in select node_id
                       from site_nodes 
                      where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey)
                   order by tree_sortkey
        LOOP
            if clr_keys_p then
               update site_nodes set tree_sortkey = null
               where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);
               clr_keys_p := 'f';
            end if;
            
            select parent_id into p_id
              from site_nodes 
             where node_id = v_rec.node_id;

            if p_id is null then
                select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
                  from site_nodes
                 where parent_id is null;
            else
                select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
                  from site_nodes 
                 where parent_id = p_id;

                select tree_sortkey into v_parent_sk 
                  from site_nodes 
                 where node_id = p_id;
            end if;

            update site_nodes 
               set tree_sortkey = tree_next_key(v_parent_sk, v_max_value)
             where node_id = v_rec.node_id;

        end LOOP;

        return new;

end;$$;


--
-- Name: split(character varying, character, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION split(character varying, character, integer) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
  p_string		alias for $1;
  p_split_char		alias for $2;
  p_element		alias for $3;

  v_left_split		integer;
  v_right_split		integer;
  v_len			integer;
begin
  v_len = length(p_string);
  if v_len = 0 or p_string is null or p_element <= 0 then
    return NULL;
  end if;
  if p_element = 1 then
    v_left_split := 0;
  else
    v_left_split := instr(p_string, p_split_char, 1, p_element-1);
  end if;
  v_right_split := instr(p_string, p_split_char, 1, p_element);
  if v_right_split = 0 then
    v_right_split = v_len + 1;
  end if;
  if v_left_split = 0 and v_right_split = v_len+1 and p_element <> 1 then
    return null;
  end if;
  return substr(p_string, v_left_split+1, (v_right_split - v_left_split - 1));
end;$_$;


--
-- Name: subsite_callback__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION subsite_callback__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__callback_id		alias for $1;
begin
      delete from subsite_callbacks where callback_id = delete__callback_id;
      return 0;
end;$_$;


--
-- Name: subsite_callback__new(integer, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION subsite_callback__new(integer, character varying, character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__callback_id         alias for $1; -- default null,
  new__event_type          alias for $2;
  new__object_type         alias for $3;
  new__callback		   alias for $4;
  new__callback_type       alias for $5;
  new__sort_order          alias for $6; -- default null
  v_callback_id		   subsite_callbacks.callback_id%TYPE;
  v_sort_order		   subsite_callbacks.sort_order%TYPE;
begin

    if new__callback_id is null then
       select acs_object_id_seq.nextval into v_callback_id;
    else
       v_callback_id := new__callback_id;
    end if;
   
    if new__sort_order is null then
       -- Make this the next event for this object_type/event_type combination
       select coalesce(max(sort_order),0) + 1 into v_sort_order
         from subsite_callbacks
        where object_type = new__object_type
          and event_type = new__event_type;
    else
       v_sort_order := new__sort_order;
    end if;

--    begin 
      insert into subsite_callbacks
      (callback_id, event_type, object_type, callback, callback_type, sort_order)
      values
      (v_callback_id, new__event_type, new__object_type, new__callback, new__callback_type, v_sort_order);

-- TODO: Can we do this properly?
--       If not, could move select before insert
--      exception when dup_val_on_index then
--        select callback_id into v_callback_id
--          from subsite_callbacks
--         where event_type = new__event_type
--           and object_type = new__object_type
--           and callback_type = new__callback_type
--           and callback = new__callback;
--    end;
    return v_callback_id;

end;$_$;


--
-- Name: table_exists(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION table_exists(character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
        table_exists__table_name             alias for $1;  
begin

        return count(*) > 0
          from pg_class 
         where relname = lower(table_exists__table_name);
 
end;$_$;


--
-- Name: time_interval__copy(integer, interval); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__copy(integer, interval) RETURNS integer
    LANGUAGE plpgsql
    AS $_$    -- time_intervals.interval_id%TYPE
declare    
       copy__interval_id     alias for $1;
       copy__offset          alias for $2; -- default 0
       interval_row	      time_intervals%ROWTYPE;
begin
       select * into interval_row
       from   time_intervals
       where  interval_id = copy__interval_id;

       return time_interval__new(
	          interval_row.start_date + copy__offset,
		  interval_row.end_date + copy__offset
		  );

end;$_$;


--
-- Name: time_interval__copy(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__copy(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- return time_intervals.interval_id%TYPE
declare    
       copy__interval_id     alias for $1;
       v_query		     varchar;
       v_result		     time_intervals.interval_id%TYPE;
       rec_datecalc	     record;
begin
	return time_interval__copy(
	           copy__interval_id,
		   interval '0 days'
		   );

end;$_$;


--
-- Name: time_interval__copy(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__copy(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- time_intervals.interval_id%TYPE
declare    
       copy__interval_id     alias for $1;
       copy__offset          alias for $2; -- default 0
begin

       return time_interval__copy(
	          copy__interval_id,
		  to_interval(copy__offset,'days')
		  );

end;$_$;


--
-- Name: time_interval__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       delete__interval_id	alias for $1;
begin
	
       delete from time_intervals
       where  interval_id = delete__interval_id;

       return 0;

end;$_$;


--
-- Name: time_interval__edit(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__edit(integer, timestamp with time zone, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        edit__interval_id     alias for $1;
        edit__start_date      alias for $2; -- default null,
        edit__end_date        alias for $3; -- default null
begin

	-- JS: I hate deeply nested if-else-ifs!!! 

        -- Null for start_date or end_date means dont change.
        if edit__start_date is not null and edit__end_date is not null then
            update time_intervals
            set    start_date  = edit__start_date,
                   end_date    = edit__end_date
            where  interval_id = edit__interval_id;
	end if;

	-- Update only the end date if not null even if start date is null
        if edit__start_date is not null and edit__end_date is null 
        then
            update time_intervals
            set    start_date  = edit__start_date
            where  interval_id = edit__interval_id;
	end if;
	    
	-- Update only the start date if not null even if end date is null
        if edit__end_date is not null and edit__start_date is null 
	then
                 update time_intervals
		 set end_date       = edit__end_date
		 where interval_id  = edit__interval_id;
	end if;

	return 0;

end;$_$;


--
-- Name: time_interval__eq(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__eq(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$	--  return boolean
declare
       eq__interval_1_id   alias for $1;
       eq__interval_2_id   alias for $2;
       interval_1_row time_intervals%ROWTYPE;
       interval_2_row time_intervals%ROWTYPE;
begin
       select * into interval_1_row
       from   time_intervals
       where  interval_id = eq__interval_1_id;

       select * into interval_2_row
       from   time_intervals
       where  interval_id = eq__interval_2_id;

       if interval_1_row.start_date = interval_2_row.start_date and 
          interval_1_row.end_date = interval_2_row.end_date 
       then
            return true;
       else
            return false;
       end if;

end;$_$;


--
-- Name: time_interval__new(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__new(timestamp with time zone, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- time_intervals.interval_id%TYPE
declare
       new__start_date  alias for $1; -- default null,
       new__end_date    alias for $2; -- default null
       v_interval_id	 time_intervals.interval_id%TYPE;
begin
       select timespan_seq.nextval into v_interval_id from dual;

       insert into time_intervals 
            (interval_id, start_date, end_date)
       values
            (v_interval_id, new__start_date, new__end_date);
                
       return v_interval_id;

end;$_$;


--
-- Name: time_interval__overlaps_p(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__overlaps_p(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       overlaps_p__interval_id_1   alias for $1;
       overlaps_p__interval_id_2   alias for $2;
       v_start_1		   timestamptz;
       v_start_2		   timestamptz;
       v_end_1			   timestamptz;
       v_end_2			   timestamptz;
begin
       -- Pull out the start and end dates and call the main overlaps_p.
       select start_date, end_date
       into   v_start_1, v_end_1
       from   time_intervals
       where  interval_id = overlaps_p__interval_id_1;

       select start_date, end_date
       into   v_start_2, v_end_2
       from   time_intervals
       where  interval_id = overlaps_p__interval_id_2;

       return time_interval__overlaps_p(
	          v_start_1, 
		  v_end_1, 
		  v_start_2, 
		  v_end_2
		  );

end;$_$;


--
-- Name: time_interval__overlaps_p(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__overlaps_p(integer, timestamp with time zone, timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       overlaps_p__interval_id     alias for $1; 
       overlaps_p__start_date      alias for $2; -- default null,
       overlaps_p__end_date        alias for $3; -- default null
       v_interval_start		   time_intervals.start_date%TYPE;
       v_interval_end		   time_intervals.end_date%TYPE;
begin
       -- Pull out the start and end date and call the main overlaps_p.
       select start_date, end_date
       into   v_interval_start, v_interval_end
       from   time_intervals
       where  interval_id = overlaps_p__interval_id;

       return time_interval__overlaps_p(
	          v_interval_start, 
		  v_interval_end, 
		  overlaps_p__start_date, 
		  overlaps_p__end_date
		  );

end;$_$;


--
-- Name: time_interval__overlaps_p(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__overlaps_p(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       overlaps_p__start_1	alias for $1;
       overlaps_p__end_1	alias for $2;
       overlaps_p__start_2	alias for $3;
       overlaps_p__end_2	alias for $4;
begin

       -- JS: Modified yet another deeply nested if-else-if
       -- JS: Note that null date is the representation for infinite 
       -- (positive or negative) time. 
       if overlaps_p__start_1 is null 
       then
            -- No overlap if 2nd interval starts after 1st ends
            if overlaps_p__end_1 < overlaps_p__start_2 
	    then
                return false;
            else
                return true;
            end if;
       end if;

       if overlaps_p__start_2 is null 
       then
            -- No overlap if 2nd interval ends before 1st starts
            if overlaps_p__end_2 < overlaps_p__start_1 
	    then
                return false;
            else
                return true;
	    end if;
       end if;

       -- Okay, both start dates are not null
       if overlaps_p__start_1 <= overlaps_p__start_2 
       then
            -- 1st starts before 2nd
            if overlaps_p__end_1 < overlaps_p__start_2 
	    then
                  -- No overlap if 1st ends before 2nd starts
                  return false;
            else
                 -- No overlap or at least one null
                 return true;
            end if;

       else

            -- 1st starts after 2nd
            if overlaps_p__end_2 < overlaps_p__start_1 
	    then
                 -- No overlap if 2nd ends before 1st starts
                 return false;
            else
                 -- No overlap or at least one null
                 return true;
            end if;

       end if;

end;$_$;


--
-- Name: time_interval__shift(integer, interval, interval); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__shift(integer, interval, interval) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare 
       shift__interval_id      alias for $1;
       shift__start_offset     alias for $2; -- default 0,
       shift__end_offset       alias for $3; -- default 0
begin
       update time_intervals
       set    start_date = start_date + shift__start_offset,
              end_date   = end_date + shift__end_offset
       where  interval_id = shift__interval_id;

       return 0;

end;$_$;


--
-- Name: time_interval__shift(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION time_interval__shift(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare 
      shift__interval_id      alias for $1;
      shift__start_offset     alias for $2; -- default 0,
      shift__end_offset       alias for $3; -- default 0
begin

      return time_interval__shift(
	         shift__interval_id,
		 to_interval(shift__start_offset,'days'),
		 to_interval(shift__end_offset,'days')
		 );

end;$_$;


--
-- Name: timespan__copy(integer, interval); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__copy(integer, interval) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- timespans.timespan_id%TYPE
declare
       copy__timespan_id	alias for $1;
       copy__offset		alias for $2; --  default 0
       rec_timespan		record;
       v_interval_id		timespans.interval_id%TYPE;
       v_timespan_id		timespans.timespan_id%TYPE;
begin
       v_timespan_id := null;

       -- Loop over each interval in timespan, creating a new copy
       for rec_timespan in 
            select * 
            from timespans
            where timespan_id = copy__timespan_id
       loop
            v_interval_id := time_interval__copy(
				rec_timespan.interval_id, 
				copy__offset
				);

            if v_timespan_id is null 
	    then
	         -- JS: NOTE DEFAULT BEHAVIOR OF timespan__new
                v_timespan_id := timespan__new(v_interval_id);
            else
	        -- no copy, use whatever is generated by time_interval__copy
                PERFORM timespan__join_interval(
				v_timespan_id, 
				v_interval_id,
				false);
            end if;

       end loop;

       return v_timespan_id;

end;$_$;


--
-- Name: timespan__copy(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__copy(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- timespans.timespan_id%TYPE
declare
       copy__timespan_id	alias for $1;
begin

       return timespan__copy(
		    copy__timespan_id,
		    interval '0 days'
		    );

end;$_$;


--
-- Name: timespan__copy(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__copy(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- timespans.timespan_id%TYPE
declare
       copy__timespan_id	alias for $1;
       copy__offset		alias for $2;
begin

       return timespan__copy(
		    copy__timespan_id,
		    to_interval(copy__offset,'days')
		    );

end;$_$;


--
-- Name: timespan__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       delete__timespan_id alias for $1; 
begin
       -- Delete intervals, corresponding timespan entries deleted by
       -- cascading constraints

       delete from time_intervals
       where  interval_id in (select interval_id
                              from   timespans
                              where  timespan_id = delete__timespan_id);
       return 0;

end;$_$;


--
-- Name: timespan__exists_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__exists_p(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       exists_p__timespan_id   alias for $1;
       v_result		integer;
begin
       -- Only need to check if any rows exist. 
       select count(*)
       into   v_result
       from dual
       where exists (select timespan_id
                     from   timespans
                     where  timespan_id = exists_p__timespan_id);

       if v_result = 0 then
           return false;
       else
           return true;
       end if;

end;$_$;


--
-- Name: timespan__interval_delete(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__interval_delete(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
       interval_delete__timespan_id   alias for $1;
       interval_delete__interval_id   alias for $2;
begin

       delete from timespans
       where timespan_id = interval_delete__timespan_id
       and   interval_id = interval_delete__interval_id;

       return 0;

end;$_$;


--
-- Name: timespan__join(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__join(integer, timestamp with time zone, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- time_intervals.interval_id%TYPE
declare
       join__timespan_id   alias for $1;
       join__start_date    alias for $2; -- default null,
       join__end_date      alias for $3; -- default null
begin

       -- JS: This will create a new interval with start_date and end_date
       -- JS: so we might as well return the interval id 
       return timespan__join_interval(
		join__timespan_id, 
		time_interval__new(join__start_date, join__end_date),
		false
		);

end;$_$;


--
-- Name: timespan__join(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__join(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- time_intervals.interval_id%TYPE
declare
       join__timespan_1_id   alias for $1;
       join__timespan_2_id   alias for $2;
       v_interval_id	      time_intervals.interval_id%TYPE;
       rec_timespan	      record;
begin
       -- Loop over intervals in 2nd timespan, join with 1st.
       for rec_timespan in 
            select * 
            from   timespans
            where  timespan_id = join__timespan_2_id
       loop
            v_interval_id := timespan__join_interval(
			          join__timespan_1_id, 
				  rec_timespan.interval_id,
				  false
				  );
       end loop;

       -- JS: Return the last interval id joined.  Not very useful, since there may be
       -- JS: more than one interval joined
       return v_interval_id;

end;$_$;


--
-- Name: timespan__join_interval(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__join_interval(integer, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$    -- time_intervals.interval_id%TYPE
declare
       join_interval__timespan_id     alias for $1;
       join_interval__interval_id     alias for $2;
       join_interval__copy_p          alias for $3; -- default true
       v_interval_id		      time_intervals.interval_id%TYPE;
begin
       if join_interval__copy_p then
           v_interval_id := time_interval__copy(join_interval__interval_id);
       else
           v_interval_id := join_interval__interval_id;
       end if;
        
       insert into timespans
            (timespan_id, interval_id)
       values
            (join_interval__timespan_id, v_interval_id);

       -- JS: We might as well return the interval id being joined, instead of returning a dummy integer
       return v_interval_id;

end;$_$;


--
-- Name: timespan__multi_interval_p(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__multi_interval_p(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       multi_interval_p__timespan_id   alias for $1;
       v_result			boolean;
begin
       -- 'f' if 0 or 1 intervals, 't' otherwise
       -- use the simple case syntax
       select (case count(timespan_id) 
	            when 0 then false
	            when 1 then false 
	            else true
	       end)
       into v_result
       from timespans
       where timespan_id = multi_interval_p__timespan_id;
        
       return v_result;

end;$_$;


--
-- Name: timespan__new(integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__new(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- timespans.timespan_id%TYPE
declare
        new__interval_id	alias for $1;
	new__copy_p		alias for $2;
        v_timespan_id		timespans.timespan_id%TYPE;
        v_interval_id		time_intervals.interval_id%TYPE;
begin
	-- get a new id;
        select timespan_seq.nextval into v_timespan_id from dual;

	if new__copy_p
	then      
	     -- JS: Note use of overloaded function (zero offset)
	     v_interval_id := time_interval__copy(new__interval_id);
	else
	     v_interval_id := new__interval_id;
	end if;
        
        insert into timespans
            (timespan_id, interval_id)
        values
            (v_timespan_id, v_interval_id);
        
        return v_timespan_id;

end;$_$;


--
-- Name: timespan__new(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__new(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	-- timespans.timespan_id%TYPE
declare
        new__interval_id	alias for $1;
begin
        return timespan__new(
		   new__interval_id,
		   true
		   );
        
end;$_$;


--
-- Name: timespan__new(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__new(timestamp with time zone, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	--  timespans.timespan_id%TYPE
declare
       new__start_date  alias for $1; -- default null,
       new__end_date    alias for $2; -- default null
begin

       -- JS: If we simply call timespan__new with default copy_p = true,
       -- JS: there will be two new time intervals that will be created
       -- JS: everytime this function is called. The first one will never be used!!! 
       -- JS: To fix, we use the timespan__new with copy_p parameter and
       -- JS: setting copy_p to false.
       return timespan__new(time_interval__new(new__start_date, new__end_date),false);

end;$_$;


--
-- Name: timespan__overlaps_interval_p(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__overlaps_interval_p(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       overlaps_interval_p__timespan_id   alias for $1;
       overlaps_interval_p__interval_id   alias for $2; -- default null
       v_start_date		  timestamptz;
       v_end_date		  timestamptz;
begin
       select start_date, end_date
       into   v_start_date, v_end_date
       from   time_intervals
       where  interval_id = overlaps_interval_p__interval_id;
        
       return timespan__overlaps_p(
			overlaps_interval_p__timespan_id, 
			v_start_date, 
			v_end_date
			);

end;$_$;


--
-- Name: timespan__overlaps_p(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__overlaps_p(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       overlaps_p__timespan_1_id   alias for $1;
       overlaps_p__timespan_2_id   alias for $2;
       v_result		    boolean;
       rec_timespan		    record;
begin
       -- Loop over 2nd timespan, checking each interval against 1st
       for rec_timespan in 
            select * 
            from timespans
            where timespan_id = overlaps_p__timespan_2_id
       loop
            v_result := timespan__overlaps_interval_p(
				overlaps_p__timespan_1_id,
				rec_timespan.interval_id
				);
            if v_result then
                return true;
            end if;
       end loop;

       return false;

end;$_$;


--
-- Name: timespan__overlaps_p(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timespan__overlaps_p(integer, timestamp with time zone, timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
       overlaps_p__timespan_id     alias for $1;
       overlaps_p__start_date      alias for $2; -- default null,
       overlaps_p__end_date        alias for $3; -- default null
       v_result			   boolean;
       rec_timespan		   record;
begin
       -- Loop over each interval in timespan, checking against dates.
       for rec_timespan in
            select * 
            from timespans
            where timespan_id = overlaps_p__timespan_id
       loop
            v_result := time_interval__overlaps_p(
				rec_timespan.interval_id, 
				overlaps_p__start_date,
				overlaps_p__end_date
				);

            if v_result then
                return true;
            end if;
       end loop;

       return false;

end;$_$;


--
-- Name: timezone__add_rule(character varying, character varying, integer, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__add_rule(character varying, character varying, integer, character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_tz alias for $1;
  p_abbrev alias for $2;
  p_isdst_p alias for $3;
  p_gmt_offset alias for $4;
  p_utc_start alias for $5;
  p_utc_end alias for $6;
  p_local_start alias for $7;
  p_local_end alias for $8;
begin
  insert into timezone_rules
    (tz_id, abbrev, utc_start, utc_end, local_start, local_end, gmt_offset, isdst_p)
  select timezone__get_id(p_tz), p_abbrev, rdbms_date(p_utc_start),
    rdbms_date(p_utc_end), rdbms_date(p_local_start),
    to_date(p_local_end),
    p_gmt_offset,
    case p_isdst_p when 0 then 'f' else 't'end;
end;$_$;


--
-- Name: timezone__convert_to_local(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__convert_to_local(integer, character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  p_tz_id alias for $1;
  p_utc_varchar alias for $2;
  v_base_time timestamptz;
begin

  select "timestamptz" (p_utc_varchar || substr(gmt_offset,1,5)) into v_base_time
  from timezones
  where tz_id = p_tz_id;

  if not found then
    return "timestamptz" (p_utc_varchar || '+00');
  end if;

  return "timestamptz" (p_utc_varchar) + "interval" (gmt_offset || 'seconds')
  from   timezone_rules
  where  tz_id = p_tz_id and v_base_time between utc_start and utc_end;

end;$_$;


--
-- Name: timezone__convert_to_utc(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__convert_to_utc(integer, character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
declare
  p_tz_id alias for $1;
  p_local_varchar alias for $2;
  v_base_time timestamptz;
begin

  select "timestamptz" (p_local_varchar || substr(gmt_offset,1,5)) into v_base_time
  from timezones
  where tz_id = p_tz_id;

  if not found then
    return "timestamptz" (p_local_varchar || '+00');
  end if;

  return "timestamptz" (p_local_varchar) - "interval" (gmt_offset || 'seconds')
  from   timezone_rules
  where  tz_id = p_tz_id and v_base_time between utc_start and utc_end;

end;$_$;


--
-- Name: timezone__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_tz_id alias for $1;
begin
  delete from timezone_rules where tz_id = p_tz_id;
  delete from timezones      where tz_id = p_tz_id;
  return 0;
end;$_$;


--
-- Name: timezone__get_abbrev(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__get_abbrev(integer, timestamp with time zone) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  p_tz_id alias for $1;
  p_time alias for $2;
  v_abbrev timezone_rules.abbrev%TYPE;
begin
  v_abbrev := 'GMT';

  select abbrev into v_abbrev
  from   timezone_rules
  where  tz_id = p_tz_id and p_time between local_start and local_end;
	 
  return v_abbrev;
end;$_$;


--
-- Name: timezone__get_date(integer, timestamp with time zone, character varying, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__get_date(integer, timestamp with time zone, character varying, boolean) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  p_tz_id alias for $1;
  p_timestamp alias for $2;
  p_format alias for $3;
  p_append_timezone_p alias for $4;
  v_timestamp timestamptz;
  v_abbrev text;
  v_date text;
begin

  v_abbrev := '';
  if p_append_timezone_p then
    select abbrev into v_abbrev
    from   timezone_rules
    where  tz_id = p_tz_id and p_timestamp between utc_start and utc_end;
  end if;

  select to_char(p_timestamp + "interval" (
     (extract(timezone_hour from p_timestamp) * 3600 + extract(timezone_minute from p_timestamp) * 60) || 'seconds') +
         "interval" (gmt_offset || 'seconds'), p_format) || ' ' || v_abbrev
    into v_date 
  from   timezone_rules
  where  tz_id = p_tz_id and p_timestamp between utc_start and utc_end;

  if not found then
    select to_char(p_timestamp + "interval" ((extract(timezone_hour from p_timestamp) * 3600 + extract(timezone_minute from p_timestamp) * 60) || 'seconds'), p_format)
      into v_date;
  end if;

  return v_date;

end;$_$;


--
-- Name: timezone__get_id(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__get_id(character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  p_tz alias for $1;
  v_tz_id integer;
begin

  return tz_id
  from   timezones
  where  tz = p_tz;

end;$_$;


--
-- Name: timezone__get_offset(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__get_offset(integer, timestamp with time zone) RETURNS interval
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  p_tz_id alias for $1;
  p_time alias for $2;
  v_offset integer;
begin
  v_offset := '0';

  select gmt_offset into v_offset
  from timezone_rules
  where  tz_id = p_tz_id and p_time between utc_start and utc_end;

  return "interval" (v_offset || 'seconds');
end;$_$;


--
-- Name: timezone__get_rawoffset(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__get_rawoffset(integer, timestamp with time zone) RETURNS interval
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  p_tz_id alias for $1;
  p_time alias for $2;
  v_offset varchar;
begin
  v_offset := '0';

  select
    case isdst_p
    when 't' then "interval" (gmt_offset || 'seconds') - '3600 seconds'
    else "interval" (gmt_offset || 'seconds')
    end
  into v_offset
  from   timezone_rules
  where  tz_id  = p_tz_id and p_time between utc_start and utc_end;

  return v_offset;
end;$_$;


--
-- Name: timezone__isdst_p(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__isdst_p(integer, timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  p_tz_id alias for $1;
  p_time alias for $2;
  v_isdst_p boolean;
begin
  v_isdst_p := 'f';

  select isdst_p into v_isdst_p
  from   timezone_rules
  where  tz_id = p_tz_id and p_time between local_start and local_end;

  return v_isdst_p;
end;$_$;


--
-- Name: timezone__new(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION timezone__new(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_tz alias for $1;
  p_gmt_offset alias for $2;
begin
  insert into timezones
    (tz_id, tz, gmt_offset)
  values
    (nextval('timezone_seq'), p_tz, gmt_offset);
  return 0;
end;$_$;


--
-- Name: to_interval(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION to_interval(integer, character varying) RETURNS interval
    LANGUAGE plpgsql
    AS $_$	
declare    
       interval__number	     alias for $1;
       interval__units	     alias for $2;
begin

	-- We should probably do unit checking at some point
	return ('''' || interval__number || ' ' || interval__units || '''')::interval;

end;$_$;


--
-- Name: tree_ancestor_key(bit varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_ancestor_key(bit varying, integer) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$

-- Returns a key for the ancestor at the given level.  The root is level
-- one.

declare
  p_tree_key      alias for $1;
  p_level         alias for $2;
  v_level         integer default 0;
  v_pos           integer default 1;
begin

  if tree_level(p_tree_key) < p_level then
    raise exception 'tree_ancestor_key: key is at a level less than %', p_level;
  end if;

  while v_level < p_level loop
    v_level := v_level + 1;
    if substring(p_tree_key, v_pos, 1) = '1' then
      v_pos := v_pos + 32;
    else
      v_pos := v_pos + 8;
    end if;
  end loop;

  return substring(p_tree_key, 1, v_pos - 1);

end;$_$;


--
-- Name: tree_ancestor_keys(bit varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_ancestor_keys(bit varying, integer) RETURNS SETOF bit varying
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  select tree_ancestor_key($1, $2)
  union
  select tree_ancestor_keys($1, $2 + 1)
  where $2 < tree_level($1)
$_$;


--
-- Name: tree_ancestor_keys(bit varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_ancestor_keys(bit varying) RETURNS SETOF bit varying
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$

  select tree_ancestor_keys($1, 1)

$_$;


--
-- Name: tree_ancestor_p(bit varying, bit varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_ancestor_p(bit varying, bit varying) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
  p_potential_ancestor      alias for $1;
  p_potential_child         alias for $2;
begin
  return position(p_potential_ancestor in p_potential_child) = 1;
end;$_$;


--
-- Name: tree_increment_key(bit varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_increment_key(bit varying) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
    p_child_sort_key                alias for $1;
    v_child_sort_key                integer;
begin
    if p_child_sort_key is null then
        v_child_sort_key := 0;
    else
        v_child_sort_key := tree_leaf_key_to_int(p_child_sort_key) + 1;
    end if;

    return int_to_tree_key(v_child_sort_key);
end;$_$;


--
-- Name: tree_key_to_int(bit varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_key_to_int(bit varying, integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$

-- Convert the compressed key for the node at the given level to an 
-- integer.

declare
  p_tree_key      alias for $1;
  p_level         alias for $2;
  v_level         integer default 0;
  v_parent_pos    integer default 1;
  v_pos           integer default 1;
begin

  -- Find the right key first
  while v_pos < length(p_tree_key) and v_level < p_level loop
    v_parent_pos := v_pos;
    v_level := v_level + 1;
    if substring(p_tree_key, v_pos, 1) = '1' then
      v_pos := v_pos + 32;
    else
      v_pos := v_pos + 8;
    end if;
  end loop;

  if v_level < p_level then
    raise exception 'tree_key_to_int: key is at a level less than %', p_level;
  end if;

  if substring(p_tree_key, v_parent_pos, 1) = '1' then
    return bittoint4(substring(p_tree_key, v_parent_pos + 1, 31));
  else
    return bittoint4(substring(p_tree_key, v_parent_pos, 8));
  end if;

end;$_$;


--
-- Name: tree_leaf_key_to_int(bit varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_leaf_key_to_int(bit varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$

-- Convert the bitstring for the last, or leaf, node represented by this key
-- to an integer.

declare
  p_tree_key      alias for $1;
  v_leaf_pos      integer default 1;
  v_pos           integer default 1;
begin

  -- Find the leaf key first
  while v_pos < length(p_tree_key) loop
    v_leaf_pos := v_pos;
    if substring(p_tree_key, v_pos, 1) = '1' then
      v_pos := v_pos + 32;
    else
      v_pos := v_pos + 8;
    end if;
  end loop;

  if substring(p_tree_key, v_leaf_pos, 1) = '1' then
    return bittoint4(substring(p_tree_key, v_leaf_pos + 1, 31));
  else
    return bittoint4(substring(p_tree_key, v_leaf_pos, 8));
  end if;

end;$_$;


--
-- Name: tree_left(bit varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_left(bit varying) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE
    AS $_$

-- Create a key less than or equal to that of any child of the
-- current key.

declare
  key      alias for $1;
begin
  if key is null then
    return 'X00'::varbit;
  else
    return key || 'X00'::varbit;
  end if;
end;$_$;


--
-- Name: tree_level(bit varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_level(bit varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$

-- Return the tree level of the given key.  The root level is defined
-- to be at level one.

declare
  p_tree_key           alias for $1;
  v_pos                integer;        
  v_level              integer;
  
begin

  if p_tree_key is null then
    return 0;
  end if;

  v_pos := 1;
  v_level := 0;

  while v_pos <= length(p_tree_key) loop
    v_level := v_level + 1;
    if substring(p_tree_key, v_pos, 1) = '1' then
      v_pos := v_pos + 32;
    else
      v_pos := v_pos + 8;
    end if;
  end loop;

  return v_level;
end;$_$;


--
-- Name: tree_next_key(bit varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_next_key(bit varying, integer) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
  p_parent_key      alias for $1;
  p_child_value     alias for $2;
  v_child_value     integer;
begin
-- Create a new child of the given key with a leaf key number one greater than
-- the child value parameter.  If the child value parameter is null, make the
-- child the first child of the parent.

  if p_child_value is null then
    v_child_value := 0;
  else
    v_child_value := p_child_value + 1;
  end if;

  if p_parent_key is null then
    return int_to_tree_key(v_child_value);
  else
    return p_parent_key || int_to_tree_key(v_child_value);
  end if;

end;$_$;


--
-- Name: tree_right(bit varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_right(bit varying) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE
    AS $_$

-- Create a key greater or equal to that of any child of the current key.
-- Used in BETWEEN expressions to select the subtree rooted at the given
-- key. 

declare
  key      alias for $1;
begin
  if key is null then
    return 'XFFFFFFFF'::varbit;
  else
    return key || 'XFFFFFFFF'::varbit;
  end if;
end;$_$;


--
-- Name: tree_root_key(bit varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tree_root_key(bit varying) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$

-- Return the tree_sortkey for the root node of the node with the 
-- given tree_sortkey.  

declare
  p_tree_key      alias for $1;
begin

  if substring(p_tree_key, 1, 1) = '1' then
      return substring(p_tree_key, 1, 32);
  else
      return substring(p_tree_key, 1, 8);
  end if;

end;$_$;


--
-- Name: trigger_exists(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION trigger_exists(character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare 
        trigger_name    alias for $1;
        on_table        alias for $2;
begin
        return count(*) > 0
          from pg_class c, pg_trigger t
         where c.relname = lower(on_table)
           and c.oid = t.tgrelid
           and t.tgname = lower(trigger_name);

end;$_$;


--
-- Name: trigger_func_exists(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION trigger_func_exists(character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare 
        trigger_name    alias for $1;
begin
        return count(*) = 1
          from pg_proc
         where proname = lower(trigger_name)
           and pronargs = 0;

end;$_$;


--
-- Name: trigger_type(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION trigger_type(integer) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
  tgtype            alias for $1;
  description       varchar;
  sep               varchar;
begin

 if tgtype & 2 then
    description := 'BEFORE ';
 else 
    description := 'AFTER ';
 end if;

 sep := '';

 if tgtype & 4 then
    description := description || 'INSERT ';
    sep := 'OR ';
 end if;

 if tgtype & 8 then
    description := description || sep || 'DELETE ';
    sep := 'OR ';
 end if;

 if tgtype & 16 then
    description := description || sep || 'UPDATE ';
    sep := 'OR ';
 end if;

 if tgtype & 1 then
    description := description || 'FOR EACH ROW';
 else
    description := description || 'STATEMENT';
 end if;

 return description;

end;$_$;


--
-- Name: ttl__create_file(integer, integer, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ttl__create_file(integer, integer, character varying, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_package_id alias for $1;
  p_user_id alias for $2;
  p_name alias for $3;
  p_parent_id alias for $4;
  p_mime_type alias for $5;
  p_file_extension alias for $6;
  v_item_id integer;
  v_revision_id integer;
  v_mime_type varchar;
begin

-- detect mime type if mime is not yet in cr_mime_type and add it
  select mime_type into v_mime_type from cr_mime_types
    	where  mime_type = p_mime_type;
 
  if not found then
    insert into cr_mime_types (mime_type, file_extension) values (p_mime_type, p_file_extension);
  end if;

-- if the file already exists then nuke it. this become essentially write
  select item_id into v_item_id from cr_items where name = p_name;
  if found then 
    perform content_item__delete(v_item_id);
  end if;

-- create a new cr_item
  v_item_id := acs_object__new(null, 'content_item', now(), p_user_id, null, p_package_id);
  insert into cr_items (
    item_id, parent_id, name, content_type, storage_type
  ) values (
    v_item_id, p_parent_id, p_name, 'content_revision', 'file'
  );

-- create a new cr_revision
  v_revision_id := acs_object__new(null, 'content_revision', now(), p_user_id, null, null);
  insert into cr_revisions (revision_id, item_id, mime_type) 
  values (v_revision_id, v_item_id, p_mime_type);

  return v_revision_id;
end;
$_$;


--
-- Name: ttl_relative_date(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ttl_relative_date(timestamp with time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  relative_date     alias for $1;
begin
  if date_trunc('day', relative_date) = date_trunc('day', current_timestamp) then
      return to_char(relative_date, 'fmhh:mi am');
  else 
      return to_char(relative_date, 'Month fmdd, yyyy');
  end if;
end;$_$;


--
-- Name: ttl_top_privilege_for_object(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ttl_top_privilege_for_object(integer, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  p_object_id          alias for $1;
  p_user_id            alias for $2;
  v_privilege        acs_privileges.privilege%TYPE default '';
  v_admin_p          integer;
begin
    select count(*) into v_admin_p
    where acs_permission__permission_p(p_object_id, p_user_id, 'admin') = 't';

    if v_admin_p = 1 then
        v_privilege := 'admin';
    else 
        select privilege into v_privilege
        from acs_permissions
        where object_id = p_object_id
        and grantee_id = p_user_id
        and privilege = 'write';
    end if;

    return v_privilege;
end;$_$;


--
-- Name: util__computehash(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION util__computehash(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare 
        v_value alias for $1;
	v_hashed      char(40);
begin
	select RAWTOHEX(util__computehash_raw(v_value)) into v_hashed;

	return v_hashed;
end;$_$;


--
-- Name: util__computehash_raw(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION util__computehash_raw(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
        arg     alias for $1;
begin
        raise exception 'not implemented yet: depends on java code in acs classic';
        return '';
end;$_$;


--
-- Name: util__logical_negation(boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION util__logical_negation(boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
        true_or_false alias for $1;
begin
      IF true_or_false is null THEN
        return null;
      ELSE IF true_or_false = 'f' THEN
        return 't';   
      ELSE 
        return 'f';   
      END IF; END IF;
END;$_$;


--
-- Name: util__multiple_nextval(character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION util__multiple_nextval(character varying, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  v_sequence_name        alias for $1;  
  v_count                alias for $2;  
  a_sequence_values      text default ''; 
  v_rec                  record;
begin
    for counter in 1..v_count loop
        for v_rec in EXECUTE 'select ' || quote_ident(v_sequence_name) '.nextval as a_seq_val'
        LOOP
           a_sequence_values := a_sequence_values || '','' || v_rec.a_seq_val;
          exit;
        end loop;
    end loop;

    return substr(a_sequence_values, 2);
 
end;$_$;


--
-- Name: weblogger_blogroll_entry__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION weblogger_blogroll_entry__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_link_id alias for $1;
begin
    delete from weblogger_blogroll_entries
        where link_id = p_link_id;

    PERFORM acs_object__delete(p_link_id);
    return 0;
end;
$_$;


--
-- Name: weblogger_blogroll_entry__name(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION weblogger_blogroll_entry__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_link_id           alias for $1;
    v_name              varchar;
begin
    select name into v_name
        from weblogger_blogroll_entries
        where link_id = p_link_id;
    return v_name;
end;
$_$;


--
-- Name: weblogger_blogroll_entry__new(integer, integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION weblogger_blogroll_entry__new(integer, integer, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_link_id               alias for $1;
    p_package_id           alias for $2;
    p_name                 alias for $3;
    p_url           alias for $4;
    p_creation_user        alias for $5;
    p_creation_ip          alias for $6;
    v_link_id          integer;
begin
    v_link_id := acs_object__new (
        p_link_id,
        'weblogger_blogroll_entry',
        current_timestamp,
        p_creation_user,
        p_creation_ip,
        p_package_id
    );

    insert into weblogger_blogroll_entries (
      link_id, 
      package_id,
      name,
      url
    ) values (
      v_link_id, 
      p_package_id,
      p_name,
      p_url
    );

    return v_link_id;   
end;
$_$;


--
-- Name: weblogger_channel__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION weblogger_channel__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_channel_id alias for $1;
    subscr_rec         record;
begin
    -- delete rss_gen_subscrs which relate to this channel
    for subscr_rec in select subscr_id 
                         from rss_gen_subscrs
                         where summary_context_id = p_channel_id loop
        perform rss_gen_subscr__delete(subscr_rec.subscr_id);
    end loop;

    delete from weblogger_channels
        where channel_id = p_channel_id;
    PERFORM acs_object__delete(p_channel_id);
    return 0;
end;
$_$;


--
-- Name: weblogger_channel__new(integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION weblogger_channel__new(integer, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_channel_id           alias for $1;
    p_package_id           alias for $2;
    p_user_id		   alias for $3;
    p_creation_user        alias for $4;
    p_creation_ip          alias for $5;
    v_channel_id           integer;
begin
    v_channel_id := acs_object__new (
        p_channel_id,
        'weblogger_channel',
        current_timestamp,
        p_creation_user,
        p_creation_ip,
        p_package_id
    );

    insert into weblogger_channels (
      channel_id, 
      package_id,
      user_id      
    ) values (
      v_channel_id, 
      p_package_id,
      p_user_id
    );

    return v_channel_id;   
end;
$_$;


--
-- Name: wf_article_callback__notificati(integer, character varying, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION wf_article_callback__notificati(integer, character varying, integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  notification__task_id               alias for $1; 	
  notification__custom_arg            alias for $2;
  notification__party_to              alias for $3;
  notification__party_from            alias for $4;
  notification__subject               alias for $5;
  notification__body                  alias for $6;
  v_deadline_pretty                   varchar(400);
  v_object_name                       text;
  v_transition_name                   wf_transitions.transition_name%TYPE;
  v_name                              varchar(1000);
  v_subject                           text default '';
  v_body                              text default '';
  v_request_id                        integer;
begin
        select to_char(ta.deadline,'Mon fmDDfm, YYYY HH24:MI:SS'),
               acs_object__name(c.object_id),
               tr.transition_name
        into   v_deadline_pretty,
               v_object_name, 
	       v_transition_name
	from   wf_tasks ta, wf_transitions tr, wf_cases c
	where  ta.task_id = notification__task_id
        and    c.case_id = ta.case_id
        and    tr.workflow_key = c.workflow_key
        and    tr.transition_key = ta.transition_key;

	v_subject := 'Assignment: ' || v_transition_name || ' ' || 
                     v_object_name;

	v_body := 'Dear ' || acs_object__name(notification__party_to) || '
' || '
Today, you have been assigned to a task.
' || '
Task    : ' || v_transition_name || '
Object  : ' || v_object_name || '
';

        if v_deadline_pretty != '' then
           v_body := v_body || 'Deadline: ' || v_deadline_pretty || '
';
        end if;

        -- NOTICE, NOTICE, NOTICE
        --
        -- Since postgresql does not support out parameters, this 
        -- function call has been moved from workflow_case.notify_assignee
        -- into the callback function.

        -- If you implement a new notification callback, make sure 
        -- that this function call is included at the end of the 
        -- callback routine just as we have done for this example code.
        --
        -- DanW (dcwickstrom@earthlink.net)

        v_request_id := acs_mail_nt__post_request (       
            notification__party_from,     -- party_from
            notification__party_to,       -- party_to
            'f',                        -- expand_group
            v_subject,                    -- subject
            v_body,                       -- message
            0                             -- max_retries
        );

        return null;
end;$_$;


--
-- Name: wf_callback__guard_attribute_tr(integer, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION wf_callback__guard_attribute_tr(integer, character varying, character varying, character varying, character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  guard_attribute_true__case_id         alias for $1;  
  guard_attribute_true__workflow_key    alias for $2;  
  guard_attribute_true__transition_key  alias for $3;  
  guard_attribute_true__place_key       alias for $4;  
  guard_attribute_true__direction       alias for $5;  
  guard_attribute_true__custom_arg      alias for $6;  
begin
        return workflow_case__get_attribute_value(
	    guard_attribute_true__case_id, 
	    guard_attribute_true__custom_arg
	);
     
end;$_$;


--
-- Name: wf_callback__time_sysdate_plus_(integer, character varying, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION wf_callback__time_sysdate_plus_(integer, character varying, text) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
declare
  time_sysdate_plus_x__case_id          alias for $1;  
  time_sysdate_plus_x__transition_key   alias for $2;  
  time_sysdate_plus_x__custom_arg       alias for $3;  
begin
        return now() + (time_sysdate_plus_x__custom_arg || ' days')::interval;
     
end;$_$;


--
-- Name: workflow__add_arc(character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__add_arc(character varying, character varying, character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_arc__workflow_key            alias for $1;  
  add_arc__transition_key          alias for $2;  
  add_arc__place_key               alias for $3;  
  add_arc__direction               alias for $4;  
  add_arc__guard_callback          alias for $5;  -- default null  
  add_arc__guard_custom_arg        alias for $6;  -- default null
  add_arc__guard_description       alias for $7;  -- default null
begin
        insert into wf_arcs (workflow_key, transition_key, place_key, direction,
        guard_callback, guard_custom_arg, guard_description)
        values (add_arc__workflow_key, add_arc__transition_key, add_arc__place_key, add_arc__direction,
        add_arc__guard_callback, add_arc__guard_custom_arg, add_arc__guard_description);

        return 0; 
end;$_$;


--
-- Name: workflow__add_arc(character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__add_arc(character varying, character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_arc__workflow_key		alias for $1;
  add_arc__from_transition_key	alias for $2;
  add_arc__to_place_key		alias for $3;
  add_arc__guard_callback	alias for $4;
  add_arc__guard_custom_arg	alias for $5;
  add_arc__guard_description	alias for $6;
begin
  perform workflow__add_arc (
	    add_arc__workflow_key,
	    add_arc__from_transition_key,
	    add_arc__to_place_key,
	    'out',
	    add_arc__guard_callback,
	    add_arc__guard_custom_arg,
	    add_arc__guard_description
	  );

  return 0;
end;$_$;


--
-- Name: workflow__add_arc(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__add_arc(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_arc__workflow_key		alias for $1;
  add_arc__from_place_key	alias for $2;
  add_arc__to_transition_key	alias for $3;
begin
  perform workflow__add_arc(
	    add_arc__workflow_key,
	    add_arc__to_transition_key,
	    add_arc__from_place_key,
	    'in',
	    null,
	    null,
	    null
	  );	 

  return 0;
end;$_$;


--
-- Name: workflow__add_place(character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__add_place(character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_place__workflow_key          alias for $1;  
  add_place__place_key             alias for $2;  
  add_place__place_name            alias for $3;  
  add_place__sort_order            alias for $4; 
  v_sort_order			   integer; 
begin
        if add_place__sort_order is null then
            select coalesce(max(sort_order)+1, 1)
              into v_sort_order
              from wf_places
             where workflow_key = add_place__workflow_key;
        else
            v_sort_order := add_place__sort_order;
        end if;
        insert into wf_places (workflow_key, place_key, place_name, sort_order)
        values (add_place__workflow_key, add_place__place_key,add_place__place_name, add_place__sort_order);

        return 0; 
end;$_$;


--
-- Name: workflow__add_role(character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__add_role(character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_role__workflow_key	   alias for $1;
  add_role__role_key		   alias for $2;
  add_role__role_name		   alias for $3;
  add_role__sort_order		   alias for $4;
  v_sort_order			   integer;
begin
        if add_role__sort_order is null then
            select coalesce(max(sort_order)+1, 1)
              into v_sort_order
              from wf_roles
	     where workflow_key = add_role__workflow_key;
        else
            v_sort_order := add_role__sort_order;
        end if;
        insert into wf_roles (
            workflow_key, role_key, role_name, sort_order
        ) values (
            add_role__workflow_key, add_role__role_key, add_role__role_name, v_sort_order
        );
        return 0; 
end;$_$;


--
-- Name: workflow__add_trans_attribute_m(character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__add_trans_attribute_m(character varying, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_workflow_key		alias for $1;
  p_transition_key		alias for $2; 
  p_attribute_id		alias for $3;
  p_sort_order			alias for $4;
  v_num_rows			integer;
  v_sort_order			integer;
begin
        select count(*)
          into v_num_rows
          from wf_transition_attribute_map
         where workflow_key = p_workflow_key
	   and transition_key = p_transition_key
	   and attribute_id = p_attribute_id;

        if v_num_rows > 0 then
            return;
        end if;
        if p_sort_order is null then
            select coalesce(max(sort_order)+1, 1)
              into v_sort_order
              from wf_transition_attribute_map
             where workflow_key = p_workflow_key
               and transition_key = p_transition_key;
        else
            v_sort_order := p_sort_order;
        end if;
        insert into wf_transition_attribute_map (
            workflow_key,
            transition_key,
            attribute_id,
            sort_order
        ) values (
            p_workflow_key,
	    p_transition_key,
            p_attribute_id,
            v_sort_order
       );

  return 0;

end;$_$;


--
-- Name: workflow__add_trans_attribute_m(character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__add_trans_attribute_m(character varying, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_workflow_key		alias for $1;
  p_transition_key		alias for $2;
  p_attribute_name		alias for $3;
  p_sort_order			alias for $4;
  v_attribute_id		integer;
begin
        select attribute_id
          into v_attribute_id
          from acs_attributes
         where object_type = p_workflow_key
           and attribute_name = p_attribute_name;

        perform workflow__add_trans_attribute_map (
		  p_workflow_key,
		  p_transition_key,
		  v_attribute_id,
		  p_sort_order
        );

	return 0;

end;$_$;


--
-- Name: workflow__add_trans_role_assign(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__add_trans_role_assign(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_workflow_key		alias for $1;
  p_transition_key		alias for $2;
  p_assign_role_key		alias for $3;
  v_num_rows			integer;
begin
        select count(*)
          into v_num_rows
          from wf_transition_role_assign_map
	 where workflow_key = p_workflow_key
           and transition_key = p_transition_key
           and assign_role_key = p_assign_role_key;

        if v_num_rows = 0 then
	    insert into wf_transition_role_assign_map (
		workflow_key,
		transition_key,
		assign_role_key
	    ) values (
		p_workflow_key,
		p_transition_key,
		p_assign_role_key
	    );
        end if;

	return 0;
end;$_$;


--
-- Name: workflow__add_transition(character varying, character varying, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__add_transition(character varying, character varying, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_transition__workflow_key     alias for $1;  
  add_transition__transition_key   alias for $2;  
  add_transition__transition_name  alias for $3;  
  add_transition__role_key	   alias for $4;
  add_transition__sort_order       alias for $5;  
  add_transition__trigger_type     alias for $6;  -- default 'user'
  v_sort_order			   integer;
begin
        if add_transition__sort_order is null then
            select coalesce(max(sort_order)+1, 1)
              into v_sort_order
              from wf_transitions
             where workflow_key = add_transition__workflow_key;
        else
            v_sort_order := add_transition__sort_order;
        end if;
	insert into wf_transitions (
            workflow_key, 
            transition_key, 
            transition_name, 
            role_key,
            sort_order, 
            trigger_type
        ) values (
            add_transition__workflow_key, 
            add_transition__transition_key, 
            add_transition__transition_name,
            add_transition__role_key,
	    v_sort_order, 
            add_transition__trigger_type
        );

        return 0; 
end;$_$;


--
-- Name: workflow__create_attribute(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__create_attribute(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  create_attribute__workflow_key   alias for $1;  
  create_attribute__attribute_name alias for $2;  
  create_attribute__datatype       alias for $3;  
  create_attribute__pretty_name    alias for $4;  
  create_attribute__pretty_plural  alias for $5;  -- default null  
  create_attribute__table_name     alias for $6;  -- default null
  create_attribute__column_name    alias for $7;  -- default null
  create_attribute__default_value  alias for $8;  -- default null
  create_attribute__min_n_values   alias for $9;  -- default 1
  create_attribute__max_n_values   alias for $10; -- default 1
  create_attribute__sort_order     alias for $11; -- default null
  create_attribute__storage        alias for $12; -- default 'generic'
  v_attribute_id                   integer;        
begin
        v_attribute_id := acs_attribute__create_attribute(
            create_attribute__workflow_key,
            create_attribute__attribute_name,
            create_attribute__datatype,
            create_attribute__pretty_name,
            create_attribute__pretty_plural,
            create_attribute__table_name,
            create_attribute__column_name,
            create_attribute__default_value,
            create_attribute__min_n_values,
            create_attribute__max_n_values,
            create_attribute__sort_order,
            create_attribute__storage,
            'f'
        );

        return v_attribute_id;
     
end;$_$;


--
-- Name: workflow__create_workflow(character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__create_workflow(character varying, character varying, character varying, character varying, character varying, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  create_workflow__workflow_key    alias for $1;  
  create_workflow__pretty_name     alias for $2;  
  create_workflow__pretty_plural   alias for $3;  -- default null  
  create_workflow__description     alias for $4;  -- default null
  create_workflow__table_name      alias for $5;  
  create_workflow__id_column       alias for $6;  -- default 'case_id'
  v_num_rows                       integer;
  v_workflow_key                   varchar;
begin
        select count(*) into v_num_rows 
        from pg_class
        where relname = lower(create_workflow__table_name);

        if v_num_rows = 0 then
            raise EXCEPTION '-20000: The table "%"must be created before calling workflow.create_workflow.', create_workflow__table_name;
        end if;

        if substr(create_workflow__workflow_key, 
                  length(create_workflow__workflow_key) - 2, 3) != '_wf' then
            v_workflow_key := create_workflow__workflow_key || '_wf';
        else
            v_workflow_key := create_workflow__workflow_key;
        end if;

        PERFORM acs_object_type__create_type (
            v_workflow_key, 
            create_workflow__pretty_name, 
            create_workflow__pretty_plural,
            'workflow',
            create_workflow__table_name,
            create_workflow__id_column,
            null,
            'f',
            null,
            null
        );

        insert into wf_workflows 
            (workflow_key, description) 
        values 
            (v_workflow_key, create_workflow__description);

        return v_workflow_key;
     
end;$_$;


--
-- Name: workflow__delete_arc(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__delete_arc(character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete_arc__workflow_key         alias for $1;  
  delete_arc__transition_key       alias for $2;  
  delete_arc__place_key            alias for $3;  
  delete_arc__direction            alias for $4;  
begin
        delete from wf_arcs
        where  workflow_key = delete_arc__workflow_key
        and    transition_key = delete_arc__transition_key
        and    place_key = delete_arc__place_key
        and    direction = delete_arc__direction;

        return 0; 
end;$_$;


--
-- Name: workflow__delete_cases(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__delete_cases(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete_cases__workflow_key       alias for $1; 
  case_rec                         record; 
begin
        for case_rec in 
            select case_id 
            from wf_cases 
            where workflow_key = delete_cases__workflow_key
        LOOP
            PERFORM workflow_case__delete(case_rec.case_id);
        end loop;

        return 0; 
end;$_$;


--
-- Name: workflow__delete_place(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__delete_place(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete_place__workflow_key       alias for $1;  
  delete_place__place_key          alias for $2;  
begin
        delete from wf_places
        where  workflow_key = delete_place__workflow_key 
        and    place_key = delete_place__place_key;

        return 0; 
end;$_$;


--
-- Name: workflow__delete_role(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__delete_role(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete_role__workflow_key		alias for $1;
  delete_role__role_key			alias for $2;
begin
        /* First, remove all references to this role from transitions */
        update wf_transitions
	   set role_key = null
         where workflow_key = delete_role__workflow_key
	   and role_key = delete_role__role_key;

        delete from wf_roles
        where  workflow_key = delete_role__workflow_key
        and    role_key = delete_role__role_key;

	return 0;
end;$_$;


--
-- Name: workflow__delete_trans_attribut(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__delete_trans_attribut(character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_workflow_key		alias for $1;
  p_transition_key		alias for $2;
  p_attribute_id            alias for $3;
begin
        delete
          from wf_transition_attribute_map
         where workflow_key = p_workflow_key
           and transition_key = p_transition_key
           and attribute_id = p_attribute_id;

  return 0;
end;$_$;


--
-- Name: workflow__delete_trans_attribut(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__delete_trans_attribut(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_workflow_key		alias for $1;
  p_transition_key		alias for $2;
  p_attribute_name		alias for $3;
  v_attribute_id		integer;
begin
        select attribute_id
          into v_attribute_id
          from acs_attributes
         where object_type = p_workflow_key
           and attribute_name = p_attribute_name;

        delete
          from wf_transition_attribute_map
         where workflow_key = p_workflow_key
           and transition_key = p_transition_key
           and attribute_id = v_attribute_id;

  return 0;
end;$_$;


--
-- Name: workflow__delete_trans_role_ass(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__delete_trans_role_ass(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_workflow_key		alias for $1;
  p_transition_key		alias for $2;
  p_assign_role_key		alias for $3;
begin
        delete
          from wf_transition_role_assign_map
         where workflow_key = p_workflow_key
           and transition_key = p_transition_key
           and assign_role_key = p_assign_role_key;

	   return 0;
end;$_$;


--
-- Name: workflow__delete_transition(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__delete_transition(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete_transition__workflow_key       alias for $1;  
  delete_transition__transition_key     alias for $2;  
begin
        delete from wf_transitions
        where  workflow_key = delete_transition__workflow_key
        and    transition_key = delete_transition__transition_key;

        return 0; 
end;$_$;


--
-- Name: workflow__drop_attribute(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__drop_attribute(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_attribute__workflow_key     alias for $1;  
  drop_attribute__attribute_name   alias for $2;  
  v_attribute_id                   integer;        
begin
        select attribute_id into v_attribute_id
        from   acs_attributes
        where  object_type = drop_attribute__workflow_key
        and    attribute_name = drop_attribute__attribute_name;

        PERFORM acs_attribute__drop_attribute (
            drop_attribute__workflow_key,
            drop_attribute__attribute_name
        );

        return 0; 
end;$_$;


--
-- Name: workflow__drop_workflow(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__drop_workflow(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  drop_workflow__workflow_key      alias for $1;  
  v_table_name                     varchar;  
  v_num_rows                       integer;        
  attribute_rec                    record;
begin
        select table_name into v_table_name 
        from   acs_object_types
        where  object_type = drop_workflow__workflow_key;

        select case when count(*) = 0 then 0 else 1 end into v_num_rows 
        from   pg_class
        where  relname = lower(v_table_name);

        if v_num_rows > 0 then
            raise EXCEPTION '-20000: The table "%" must be dropped before calling workflow__drop_workflow.', v_table_name;
        end if;

        select case when count(*) = 0 then 0 else 1 end into v_num_rows 
        from   wf_cases
        where  workflow_key = drop_workflow__workflow_key;

        if v_num_rows > 0 then
            raise EXCEPTION '-20000: You must delete all cases of workflow "%" before dropping the workflow definition.', drop_workflow__workflow_key;
        end if;

        /* Delete all the auxillary stuff */
        delete from wf_context_task_panels where workflow_key = drop_workflow__workflow_key;
        delete from wf_context_assignments where workflow_key = drop_workflow__workflow_key;
        delete from wf_context_role_info where workflow_key = drop_workflow__workflow_key; 
        delete from wf_context_transition_info where workflow_key = drop_workflow__workflow_key; 
        delete from wf_context_workflow_info where workflow_key = drop_workflow__workflow_key;
        delete from wf_arcs where workflow_key = drop_workflow__workflow_key;
        delete from wf_places where workflow_key = drop_workflow__workflow_key;
	delete from wf_transition_role_assign_map where workflow_key = drop_workflow__workflow_key;
	delete from wf_transitions where workflow_key = drop_workflow__workflow_key;
        delete from wf_roles where workflow_key = drop_workflow__workflow_key;

        /* Drop all attributes */
        for attribute_rec in 
        select attribute_id, attribute_name 
        from acs_attributes 
        where object_type = drop_workflow__workflow_key
        LOOP
            /* there is no on delete cascade, so we have to manually 
             * delete all the values 
             */

            delete from acs_attribute_values where attribute_id = attribute_rec.attribute_id;

            PERFORM workflow__drop_attribute (
                drop_workflow__workflow_key,
                attribute_rec.attribute_name
            );
        end loop;

        /* Delete the workflow */
        delete from wf_workflows where workflow_key = drop_workflow__workflow_key;
        
        PERFORM acs_object_type__drop_type (
            drop_workflow__workflow_key,
            'f'
        );

        return 0; 
end;$_$;


--
-- Name: workflow__move_role_down(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__move_role_down(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  move_role_down__workflow_key		alias for $1;
  move_role_down__role_key		alias for $2;
  v_this_sort_order			integer;
  v_next_sort_order			integer;
begin
        select sort_order
          into v_this_sort_order
          from wf_roles
         where workflow_key = move_role_down__workflow_key
           and role_key = move_role_down__role_key;

        select min(sort_order)
	  into v_next_sort_order
	  from wf_roles
	 where workflow_key = move_role_down__workflow_key
	  and sort_order > v_this_sort_order;

	if not found then
            /* already at bottom of sort order */
	  return;
	end if;

        /* switch the sort orders around */
        update wf_roles
	   set sort_order = (case when role_key=move_role_down__role_key then v_next_sort_order else v_this_sort_order end)
         where workflow_key = move_role_down__workflow_key
           and sort_order in (v_this_sort_order, v_next_sort_order);

  return 0;
end;$_$;


--
-- Name: workflow__move_role_up(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__move_role_up(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  move_role_up__workflow_key		alias for $1;
  move_role_up__role_key		alias for $2;
  v_this_sort_order			integer;
  v_prior_sort_order			integer;
begin
        select sort_order
          into v_this_sort_order
          from wf_roles
         where workflow_key = move_role_up__workflow_key
           and role_key = move_role_up__role_key;

        select max(sort_order) 
	  into v_prior_sort_order
	  from wf_roles
	where workflow_key = move_role_up__workflow_key
        and sort_order < v_this_sort_order;

	if not found then
            /* already at top of sort order */
	  return;
	end if;

	/* switch the sort orders around */
        update wf_roles
	   set sort_order = (case when role_key=move_role_up__role_key then v_prior_sort_order else v_this_sort_order end)
         where workflow_key = move_role_up__workflow_key
           and sort_order in (v_this_sort_order, v_prior_sort_order);

	return 0;
end;$_$;


--
-- Name: workflow__simple_p(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow__simple_p(character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  simple_p__workflow_key           alias for $1;  
  v_session_id                     integer;
  retval                           boolean;
begin
      v_session_id := nextval('workflow_session_id');
      retval := __workflow__simple_p(simple_p__workflow_key, v_session_id);

      delete from previous_place_list where session_id = v_session_id;
      delete from target_place_list where session_id = v_session_id;
      delete from guard_list where session_id = v_session_id;

      return retval;

end;$_$;


--
-- Name: workflow_case__add_manual_assig(integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__add_manual_assig(integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_manual_assignment__case_id                alias for $1;  
  add_manual_assignment__role_key		alias for $2;  
  add_manual_assignment__party_id               alias for $3;  
  v_workflow_key                                varchar;  
  v_num_rows					integer;
begin
        select count(*)
          into v_num_rows
          from wf_case_assignments
         where case_id = add_manual_assignment__case_id
           and role_key = add_manual_assignment__role_key
           and party_id = add_manual_assignment__party_id;

        if v_num_rows = 0 then
	    select workflow_key 
	      into v_workflow_key 
	      from wf_cases 
	     where case_id = add_manual_assignment__case_id;
        
            insert into wf_case_assignments (
                case_id, 
                workflow_key, 
                role_key, 
                party_id
            ) values (
                add_manual_assignment__case_id, 
                v_workflow_key, 
                add_manual_assignment__role_key, 
                add_manual_assignment__party_id
            );
        end if;

        return 0; 
end;$_$;


--
-- Name: workflow_case__add_task_assignm(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__add_task_assignm(integer, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_task_assignment__task_id                alias for $1;  
  add_task_assignment__party_id               alias for $2;  
  add_task_assignment__permanent_p	      alias for $3;
  v_count                                    integer;       
  v_workflow_key                             wf_workflows.workflow_key%TYPE;
  v_context_key                              wf_contexts.context_key%TYPE;
  v_case_id                                  wf_cases.case_id%TYPE;
  v_role_key				     wf_roles.role_key%TYPE;
  v_transition_key                           wf_transitions.transition_key%TYPE;
  v_notification_callback     wf_context_transition_info.notification_callback%TYPE;
  v_notification_custom_arg   wf_context_transition_info.notification_custom_arg%TYPE;
  callback_rec                record;
  v_assigned_user             record;
begin
        -- get some needed information

        select ta.case_id, ta.workflow_key, ta.transition_key, tr.role_key, c.context_key
        into   v_case_id, v_workflow_key, v_transition_key, v_role_key, v_context_key
        from   wf_tasks ta, wf_transitions tr, wf_cases c
        where  ta.task_id = add_task_assignment__task_id
          and  tr.workflow_key = ta.workflow_key
          and  tr.transition_key = ta.transition_key
          and  c.case_id = ta.case_id;

        -- make the same assignment as a manual assignment

        if add_task_assignment__permanent_p = 't' then
	    /* We do this up-front, because 
	     * even though the user already had a task assignment, 
	     * he might not have a case assignment.
	     */
            perform workflow_case__add_manual_assignment (
                v_case_id,
                v_role_key,
                add_task_assignment__party_id
            );
        end if;

        -- check that we do not hit the unique constraint

        select count(*) into v_count
        from   wf_task_assignments
        where  task_id = add_task_assignment__task_id
        and    party_id = add_task_assignment__party_id;

        if v_count > 0 then
            return null;
        end if;

        -- get callback information

        select notification_callback,
		   notification_custom_arg into callback_rec
	    from   wf_context_transition_info
	    where  context_key = v_context_key
	    and    workflow_key = v_workflow_key
	    and    transition_key = v_transition_key;

            
        if FOUND then
            v_notification_callback := callback_rec.notification_callback;
            v_notification_custom_arg := callback_rec.notification_custom_arg;
        else
            v_notification_callback := null;
            v_notification_custom_arg := null;
        end if;

        -- notify any new assignees

        for v_assigned_user in  
            select distinct u.user_id
            from   users u
            where  u.user_id not in (
	            select distinct u2.user_id
	            from   wf_task_assignments tasgn2,
	                   party_approved_member_map m2,
	                   users u2
	            where  tasgn2.task_id = add_task_assignment__task_id
	            and    m2.party_id = tasgn2.party_id
	            and    u2.user_id = m2.member_id)
            and exists (
                select 1 
                from   party_approved_member_map m
                where  m.member_id = u.user_id
                and    m.party_id = add_task_assignment__party_id
            )
        LOOP
            PERFORM workflow_case__notify_assignee (
                add_task_assignment__task_id,
                v_assigned_user.user_id,
                v_notification_callback,
                v_notification_custom_arg
            );
        end loop;

        -- do the insert

        insert into wf_task_assignments (
            task_id, 
            party_id
        ) values (
            add_task_assignment__task_id, 
            add_task_assignment__party_id
        );

        return 0; 
end;$_$;


--
-- Name: workflow_case__add_token(integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__add_token(integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  add_token__case_id                alias for $1;  
  add_token__place_key              alias for $2;  
  add_token__journal_id             alias for $3;  
  v_token_id                        integer;
  v_workflow_key                    varchar;
begin
        select wf_token_id_seq.nextval into v_token_id from dual;
        
        select workflow_key into v_workflow_key 
        from   wf_cases c 
        where  c.case_id = add_token__case_id;
    
        insert into wf_tokens 
            (token_id, case_id, workflow_key, place_key, state, produced_journal_id)
        values 
            (v_token_id, add_token__case_id, v_workflow_key, add_token__place_key, 
            'free', add_token__journal_id);

        return 0; 
end;$_$;


--
-- Name: workflow_case__begin_task_actio(integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__begin_task_actio(integer, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  begin_task_action__task_id                alias for $1;  
  begin_task_action__action                 alias for $2;  
  begin_task_action__action_ip              alias for $3;  
  begin_task_action__user_id                alias for $4;  
  begin_task_action__msg                    alias for $5;  -- default null  
  v_state                                   varchar;
  v_journal_id                              integer;
  v_case_id                                 integer;
  v_transition_name                         varchar;
  v_num_rows                                integer;
begin
        select state into v_state
        from   wf_tasks
        where  task_id = begin_task_action__task_id;

        if begin_task_action__action = 'start' then
            if v_state != 'enabled' then
                raise EXCEPTION '-20000: Task is in state "%", but it must be in state "enabled" to be started.', v_state;
            end if;
        
            select case when count(*) = 0 then 0 else 1 end into v_num_rows
            from   wf_user_tasks
            where  task_id = begin_task_action__task_id
            and    user_id = begin_task_action__user_id;
            
            if v_num_rows = 0 then
                raise EXCEPTION '-20000: You are not assigned to this task.';
            end if;
        else if begin_task_action__action = 'finish' or begin_task_action__action = 'cancel' then

            if v_state = 'started' then
                /* Is this user the holding user? */
                select case when count(*) = 0 then 0 else 1 end into v_num_rows
                from   wf_tasks
                where  task_id = begin_task_action__task_id
                and    holding_user = begin_task_action__user_id;
                if v_num_rows = 0 then  
                    raise EXCEPTION '-20000: You are not the user currently working on this task.';
                end if;
            else if v_state = 'enabled' then
                if begin_task_action__action = 'cancel' then
                    raise EXCEPTION '-20000: You can only cancel a task in state "started", but this task is in state "%"', v_state;
                end if;

                /* Is this user assigned to this task? */
                select case when count(*) = 0 then 0 else 1 end into v_num_rows
                from   wf_user_tasks
                where  task_id = begin_task_action__task_id
                and    user_id = begin_task_action__user_id;
                if v_num_rows = 0 then  
                    raise EXCEPTION '-20000: You are not assigned to this task.';
                end if;

                /* This task is finished without an explicit start.
                 * Store the user as the holding_user */
                update wf_tasks 
                set    holding_user = begin_task_action__user_id 
                where  task_id = begin_task_action__task_id;
            else
                raise EXCEPTION '-20000: Task is in state "%", but it must be in state "enabled" or "started" to be finished', v_state;
            end if; end if;

        else if begin_task_action__action = 'comment' then
            -- We currently allow anyone to comment on a task
            -- (need this line because PL/SQL does not like empty if blocks)
            v_num_rows := 0;
        end if; end if; end if;

        select  t.case_id, tr.transition_name into v_case_id, v_transition_name
        from    wf_tasks t, 
                wf_transitions tr
        where   t.task_id = begin_task_action__task_id
        and     tr.workflow_key = t.workflow_key
        and     tr.transition_key = t.transition_key;

        /* Insert a journal entry */

        v_journal_id := journal_entry__new (
            null,
            v_case_id,
            'task ' || begin_task_action__task_id || ' ' || begin_task_action__action,
            v_transition_name || ' ' || begin_task_action__action,
            now(),
            begin_task_action__user_id,
            begin_task_action__action_ip,
            begin_task_action__msg
        );

        return v_journal_id;
     
end;$_$;


--
-- Name: workflow_case__cancel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__cancel(integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  cancel__case_id                alias for $1;  
  cancel__user_id                alias for $2;  -- default null  
  cancel__ip_address             alias for $3;  -- default null
  cancel__msg                    alias for $4;  -- default null
  v_state                        varchar;   
  v_journal_id                   integer;        
begin
        select state into v_state
        from   wf_cases
        where  case_id = cancel__case_id;

        if v_state != 'active' and v_state != 'suspended' then
            raise EXCEPTION '-20000: Only active or suspended cases can be canceled';
        end if;

        /* Add an entry to the journal */
        v_journal_id := journal_entry__new(
            null,
            cancel__case_id,
            'case cancel',
            'Case canceled',
            now(),
            cancel__user_id,
            cancel__ip_address,
            cancel__msg
        );

        update wf_cases
        set    state = 'canceled'
        where  case_id = cancel__case_id;

        return 0; 
end;$_$;


--
-- Name: workflow_case__cancel_task(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__cancel_task(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  cancel_task__task_id                alias for $1;  
  cancel_task__journal_id             alias for $2;  
  v_case_id                           integer;
begin
        PERFORM workflow_case__ensure_task_in_state (cancel_task__task_id, 
                                                    'started');
        select case_id into v_case_id 
        from wf_tasks 
        where task_id = cancel_task__task_id;
    
        /* Mark the task canceled */

        update wf_tasks 
        set    state = 'canceled',
               canceled_date =  now()
        where  task_id = cancel_task__task_id;

    
        /* Release our reserved tokens */

        PERFORM workflow_case__release_token (
            cancel_task__task_id,
            cancel_task__journal_id
        );

        /* The workflow state has now changed, so we must run this */
        
        PERFORM workflow_case__sweep_automatic_transitions (
            v_case_id,
            cancel_task__journal_id
        );

        return 0; 
end;$_$;


--
-- Name: workflow_case__clear_manual_ass(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__clear_manual_ass(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  clear_manual_assignments__case_id                alias for $1;  
  clear_manual_assignments__role_key		   alias for $2;  
  v_workflow_key				   varchar;
begin
        select workflow_key 
          into v_workflow_key
          from wf_cases 
         where case_id = clear_manual_assignments__case_id;
        
        delete 
          from wf_case_assignments 
         where workflow_key = v_workflow_key 
           and case_id = clear_manual_assignments__case_id
           and role_key = clear_manual_assignments__role_key;
   return 0; 
end;$_$;


--
-- Name: workflow_case__clear_task_assig(integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__clear_task_assig(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  clear_task_assignments__task_id                alias for $1;  
  clear_task_assignments__permanent_p		 alias for $2;
  v_case_id                                      integer;        
  v_transition_key                               varchar;  
  v_role_key					 wf_roles.role_key%TYPE;
  v_workflow_key                                 varchar;  
  v_context_key                                  varchar;  
  v_callback                                     varchar;  
  v_custom_arg                                   varchar; 
begin
        -- get some information

        select ta.case_id, ta.transition_key, tr.role_key, ta.workflow_key, c.context_key
          into v_case_id, v_transition_key, v_role_key, v_workflow_key, v_context_key
          from wf_tasks ta, wf_transitions tr, wf_cases c
         where ta.task_id = clear_task_assignments__task_id
           and tr.workflow_key = ta.workflow_key
           and tr.transition_key = ta.transition_key
           and c.case_id = ta.case_id;

        -- make the unassignment stick as a manual assignment

        if clear_task_assignments__permanent_p = 't' then
            perform workflow_case__clear_manual_assignments (
                v_case_id,
                v_role_key
            );
        end if;

        -- delete the rows


        delete 
        from   wf_task_assignments
        where  task_id = clear_task_assignments__task_id;

        -- fire the unassigned callback

        select unassigned_callback, unassigned_custom_arg
        into   v_callback, v_custom_arg
        from   wf_context_transition_info
        where  workflow_key = v_workflow_key
        and    context_key  = v_context_key
        and    transition_key = v_transition_key;

        PERFORM workflow_case__execute_unassigned_callback (
            v_callback,
            clear_task_assignments__task_id,
            v_custom_arg
        );

        return 0; 
end;$_$;


--
-- Name: workflow_case__consume_token(integer, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__consume_token(integer, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  consume_token__case_id                alias for $1;  
  consume_token__place_key              alias for $2;  
  consume_token__journal_id             alias for $3;  
  consume_token__task_id                alias for $4;  -- default null  
begin
        if consume_token__task_id is null then
            update wf_tokens
            set    state = 'consumed',
                   consumed_date = now(),
                   consumed_journal_id = consume_token__journal_id
            where  token_id = (select token_id 
                                 from wf_tokens 
                                where case_id = consume_token__case_id
                                  and place_key = consume_token__place_key
                                  and state = 'free'
                                limit 1);
        else
            update wf_tokens
            set    state = 'consumed',
                   consumed_date = now(),
                   consumed_journal_id = consume_token__journal_id
            where  case_id = consume_token__case_id
            and    place_key = consume_token__place_key
            and    state = 'locked'
            and    locked_task_id = consume_token__task_id;
        end if;

        return 0; 
end;$_$;


--
-- Name: workflow_case__delete(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  delete__case_id                alias for $1;  
  v_workflow_case_table          varchar;   
begin
        /* delete attribute_value_audit, tokens, tasks  */
        delete from wf_attribute_value_audit 
         where case_id = delete__case_id;

        delete from wf_case_assignments 
         where case_id = delete__case_id;

        delete from wf_case_deadlines 
         where case_id = delete__case_id;

        delete from wf_tokens 
         where case_id = delete__case_id;

        delete from wf_task_assignments 
         where task_id in (select task_id 
                             from wf_tasks 
                            where case_id = delete__case_id);

        delete from wf_tasks 
         where case_id = delete__case_id;

        /* delete the journal */
        PERFORM journal_entry__delete_for_object(delete__case_id);
        
        /* delete from the workflow-specific cases table */
        select table_name into v_workflow_case_table
        from   acs_object_types ot, wf_cases c
        where  c.case_id = delete__case_id
        and    object_type = c.workflow_key;
        
        execute 'delete from ' || v_workflow_case_table || ' where case_id = ' || delete__case_id;

        /* delete from the generic cases table */
        delete from wf_cases where case_id = delete__case_id;

        /* delete from acs-objects */
        PERFORM acs_object__delete(delete__case_id);

        return 0; 
end;$_$;


--
-- Name: workflow_case__enable_transitio(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__enable_transitio(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  enable_transitions__case_id                alias for $1;  
  v_task_id                                  integer;        
  v_workflow_key                             varchar;  
  v_trigger_time                             timestamptz;     
  v_deadline_date                            timestamptz;     
  v_party_from                               integer;       
  v_subject                                  varchar;  
  v_body                                     text; 
  v_num_assigned                             integer; 
  trans_rec                                  record;
begin
        select workflow_key into v_workflow_key 
        from   wf_cases 
        where  case_id = enable_transitions__case_id;
    
        /* we mark tasks overridden if they were once enabled, but are no longer so */

        update wf_tasks 
        set    state = 'overridden',
               overridden_date = now()
        where  case_id = enable_transitions__case_id 
        and    state = 'enabled'
        and    transition_key not in 
            (select transition_key 
             from wf_enabled_transitions 
             where case_id = enable_transitions__case_id);
    

        /* insert a task for the transitions that are enabled but have no task row */

        for trans_rec in select et.transition_key,
                   et.transition_name, 
                   et.trigger_type, 
                   et.enable_callback,
                   et.enable_custom_arg, 
                   et.time_callback, 
                   et.time_custom_arg,
                   et.deadline_callback,
                   et.deadline_custom_arg,
                   et.deadline_attribute_name,
                   et.notification_callback,
                   et.notification_custom_arg,
                   et.unassigned_callback,
                   et.unassigned_custom_arg,
                   et.estimated_minutes,
                   cr.assignment_callback,
                   cr.assignment_custom_arg
              from wf_enabled_transitions et left outer join wf_context_role_info cr
		    on (et.workflow_key = cr.workflow_key and et.role_key = cr.role_key)
             where et.case_id = enable_transitions__case_id
               and not exists (select 1 from wf_tasks 
                               where case_id = enable_transitions__case_id
                               and   transition_key = et.transition_key
                               and   state in ('enabled', 'started')) 
        LOOP

            v_trigger_time := null;
            v_deadline_date := null;

            if trans_rec.trigger_type = 'user' then
                v_deadline_date := workflow_case__get_task_deadline (
                    trans_rec.deadline_callback, 
                    trans_rec.deadline_custom_arg,
                    trans_rec.deadline_attribute_name,
                    enable_transitions__case_id, 
                    trans_rec.transition_key
                );
            else if trans_rec.trigger_type = 'time' then
		    v_trigger_time := workflow_case__execute_time_callback (
                                        trans_rec.time_callback, 
                                        trans_rec.time_custom_arg,
                                        enable_transitions__case_id, 
                                        trans_rec.transition_key);
		 end if;
            end if;

            /* we are ready to insert the row */
            select wf_task_id_seq.nextval into v_task_id from dual;

            insert into wf_tasks (
                task_id, case_id, workflow_key, transition_key, 
                deadline, trigger_time, estimated_minutes
            ) values (
                v_task_id, enable_transitions__case_id, v_workflow_key, 
                trans_rec.transition_key,
                v_deadline_date, v_trigger_time, trans_rec.estimated_minutes
            );
            
            PERFORM workflow_case__set_task_assignments (
                v_task_id,
                trans_rec.assignment_callback,
                trans_rec.assignment_custom_arg
            );

            /* Execute the transition enabled callback */
            PERFORM workflow_case__execute_transition_callback (
                trans_rec.enable_callback, 
                trans_rec.enable_custom_arg,
                enable_transitions__case_id, 
                trans_rec.transition_key
            );

            select count(*) into v_num_assigned
            from   wf_task_assignments
            where  task_id = v_task_id;

            if v_num_assigned = 0 then
                PERFORM workflow_case__execute_unassigned_callback (
                    trans_rec.unassigned_callback,
                    v_task_id,
                    trans_rec.unassigned_custom_arg
                );
            end if;

        end loop;

        return 0; 
end;$_$;


--
-- Name: workflow_case__end_task_action(integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__end_task_action(integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  end_task_action__journal_id             alias for $1;  
  end_task_action__action                 alias for $2;  
  end_task_action__task_id                alias for $3;  
  v_user_id                               integer;
begin
        select creation_user into v_user_id
        from   acs_objects
        where  object_id = end_task_action__journal_id;

        /* Update the workflow state */

        if end_task_action__action = 'start' then
            PERFORM workflow_case__start_task(end_task_action__task_id, 
                                              v_user_id, 
                                              end_task_action__journal_id
                    );
        else if end_task_action__action = 'finish' then
            PERFORM workflow_case__finish_task(end_task_action__task_id, 
                                               end_task_action__journal_id
                    );
        else if end_task_action__action = 'cancel' then
            PERFORM workflow_case__cancel_task(end_task_action__task_id, 
                                               end_task_action__journal_id
                    );
        else if end_task_action__action != 'comment' then
            raise EXCEPTION '-20000: Unknown action "%"', end_task_action__action;
        end if; end if; end if; end if;

        return 0; 
end;$_$;


--
-- Name: workflow_case__ensure_task_in_s(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__ensure_task_in_s(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  ensure_task_in_state__task_id         alias for $1;  
  ensure_task_in_state__state           alias for $2;  
  v_count                               integer;        
begin
        select case when count(*) = 0 then 0 else 1 end into v_count
        from   wf_tasks 
        where  task_id = ensure_task_in_state__task_id
        and    state = ensure_task_in_state__state;
    
        if v_count != 1 then
            raise EXCEPTION '-20000: The task %  is not in state "%"', ensure_task_in_state__task_id, ensure_task_in_state__state;
        end if;
        
        return 0; 
end;$_$;


--
-- Name: workflow_case__evaluate_guard(character varying, character varying, integer, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__evaluate_guard(character varying, character varying, integer, character varying, character varying, character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  evaluate_guard__callback               alias for $1;  
  evaluate_guard__custom_arg             alias for $2;  
  evaluate_guard__case_id                alias for $3;  
  evaluate_guard__workflow_key           alias for $4;  
  evaluate_guard__transition_key         alias for $5;  
  evaluate_guard__place_key              alias for $6;  
  evaluate_guard__direction              alias for $7;  
  v_guard_happy_p                        boolean;
  v_rec                                  record;
  v_str                                  text default '';
begin
        if evaluate_guard__callback = '' or 
           evaluate_guard__callback is null then
            -- null guard evaluates to true
            return 't';
        else
            if evaluate_guard__callback = '#' then
                return 'f';
            else
                v_str := 'select ' || evaluate_guard__callback
                || '(' || 
                evaluate_guard__case_id || ',' || 
                quote_literal(evaluate_guard__workflow_key) || ',' || 
                quote_literal(evaluate_guard__transition_key) || ',' || 
                quote_literal(evaluate_guard__place_key) || ',' || 
                quote_literal(evaluate_guard__direction) || ',' || 
                coalesce(quote_literal(evaluate_guard__custom_arg),'null') || ') as guard_happy_p';
                raise notice 'str = %', v_str;
                for v_rec in 
                    execute v_str
                LOOP
                    return v_rec.guard_happy_p;                        
                end LOOP;
            end if;
        end if;

        return null;
     
end;$_$;


--
-- Name: workflow_case__execute_hold_tim(character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__execute_hold_tim(character varying, character varying, integer, character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
declare
  execute_hold_timeout_callback__callback               alias for $1;  
  execute_hold_timeout_callback__custom_arg             alias for $2;  
  execute_hold_timeout_callback__case_id                alias for $3;  
  execute_hold_timeout_callback__transition_key         alias for $4;  
  v_hold_timeout                                        timestamptz;
  v_rec                                                 record;
  v_str                                                 text;
begin
        if execute_hold_timeout_callback__callback = '' or execute_hold_timeout_callback__callback is null then
            return null;
        end if;
 
        v_str := 'select ' || execute_hold_timeout_callback__callback 
              || '(' ||
              execute_hold_timeout_callback__case_id || ',' ||
              quote_literal(execute_hold_timeout_callback__transition_key) || 
              ',' ||
              coalesce(quote_literal(execute_hold_timeout_callback__custom_arg),'null') || ') as hold_timeout';

        for v_rec in execute v_str
        LOOP
           return v_rec.hold_timeout;
        end LOOP;

        return null;
     
end;$_$;


--
-- Name: workflow_case__execute_time_cal(character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__execute_time_cal(character varying, character varying, integer, character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
declare
  execute_time_callback__callback               alias for $1;  
  execute_time_callback__custom_arg             alias for $2;  
  execute_time_callback__case_id                alias for $3;  
  execute_time_callback__transition_key         alias for $4;  
  v_rec                                         record;
  v_str                                         text;
begin
        if execute_time_callback__callback = '' or execute_time_callback__callback is null then
            raise EXCEPTION '-20000: There''s no time_callback function for the timed transition "%"', execute_time_callback__transition_key;
        end if;
 
        v_str := 'select ' || execute_time_callback__callback || '(' || 
                 execute_time_callback__case_id || ',' || 
                 quote_literal(execute_time_callback__transition_key) || ',' || 
                 coalesce(quote_literal(execute_time_callback__custom_arg),'null') || ') as trigger_time';

        for v_rec in execute v_str
        LOOP
            return v_rec.trigger_time;
        end LOOP;

        return null;
     
end;$_$;


--
-- Name: workflow_case__execute_transiti(character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__execute_transiti(character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  execute_transition_callback__callback               alias for $1;  
  execute_transition_callback__custom_arg             alias for $2;  
  execute_transition_callback__case_id                alias for $3;  
  execute_transition_callback__transition_key         alias for $4;  
  v_str                                               text;
begin
        if execute_transition_callback__callback != '' and execute_transition_callback__callback is not null then 
            v_str := 'select ' || execute_transition_callback__callback
            || '(' || execute_transition_callback__case_id || ',' || 
            quote_literal(execute_transition_callback__transition_key) || ',' || 
            coalesce(quote_literal(execute_transition_callback__custom_arg),'null') || ')';
            execute v_str;
        end if;

        return 0; 
end;$_$;


--
-- Name: workflow_case__execute_unassign(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__execute_unassign(character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  callback               alias for $1;  
  task_id                alias for $2;  
  custom_arg             alias for $3; 
  v_str                  text; 
begin
        if callback != '' and callback is not null then
            v_str := 'select ' || callback
                     || '(' || task_id || ',' || 
                     coalesce(quote_literal(custom_arg),'null') 
                     || ')';

            execute v_str;
        end if;

        return 0; 
end;$_$;


--
-- Name: workflow_case__finish_task(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__finish_task(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  finish_task__task_id                alias for $1;  
  finish_task__journal_id             alias for $2;  
  v_case_id                           integer;
begin
        select case_id into v_case_id
        from   wf_tasks
        where  task_id = finish_task__task_id;

        PERFORM workflow_case__fire_transition_internal (
            finish_task__task_id,
            finish_task__journal_id
        );

        PERFORM workflow_case__sweep_automatic_transitions (
            v_case_id,
            finish_task__journal_id
        );

        return 0; 
end;$_$;


--
-- Name: workflow_case__finished_p(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__finished_p(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  finished_p__case_id                alias for $1;  
  finished_p__journal_id             alias for $2;  
  v_case_state                       varchar;
  v_token_id                         integer;
  v_num_rows                         integer;
  v_journal_id                       integer;
begin
        select state into v_case_state 
        from   wf_cases 
        where  case_id = finished_p__case_id;

        if v_case_state = 'finished' then
            return 't';
        else
            /* Let us see if the case is actually finished, but just not marked so */
            select case when count(*) = 0 then 0 else 1 end into v_num_rows
            from   wf_tokens
            where  case_id = finished_p__case_id
            and    place_key = 'end';
    
            if v_num_rows = 0 then 
                return 'f';
            else
                /* There is a token in the end place.
                 * Count the total integer of tokens to make sure the wf is well-constructed.
                 */
    
                select case when count(*) = 0 then 0
                            when count(*) = 1 then 1 
                                              else 2 
                        end into v_num_rows
                from   wf_tokens
                where  case_id = finished_p__case_id
                and    state in ('free', 'locked');
    
                if v_num_rows > 1 then 
                    raise EXCEPTION '-20000: The workflow net is misconstructed: Some parallel executions have not finished.';
                end if;
    
                /* Consume that token */
                select token_id into v_token_id
                from   wf_tokens
                where  case_id = finished_p__case_id
                and    state in ('free', 'locked');

                PERFORM workflow_case__consume_token (
                    finished_p__case_id,
                    'end',
                    finished_p__journal_id,
                    null
                );

                update wf_cases 
                set    state = 'finished' 
                where  case_id = finished_p__case_id;

                /* Add an extra entry to the journal */
                v_journal_id := journal_entry__new (
                    null,
                    finished_p__case_id,
                    'case finish',
                    'Case finished',
                    now(),
                    null,
                    null,
                    null
                );

                return 't';
            end if;
        end if;
     
end;$_$;


--
-- Name: workflow_case__fire_message_tra(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__fire_message_tra(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  fire_message_transition__task_id               alias for $1;  
  v_case_id                                      integer;        
  v_transition_name                              varchar;  
  v_trigger_type                                 varchar;   
  v_journal_id                                   integer;        
begin
        select t.case_id, tr.transition_name, tr.trigger_type 
        into   v_case_id, v_transition_name, v_trigger_type
        from   wf_tasks t, wf_transitions tr
        where  t.task_id = fire_message_transition__task_id
        and    tr.workflow_key = t.workflow_key
        and    tr.transition_key = t.transition_key;

        if v_trigger_type != 'message' then
	    raise EXCEPTION '-20000: Transition "%" is not message triggered',  v_transition_name;
        end if;

        /* Add an entry to the journal */
        v_journal_id := journal_entry__new (
            null,
            v_case_id,
            'task ' || fire_message_transition__task_id || ' fire',
            v_transition_name || ' fired',
            now(),
            null,
            null,
            null
        );
        
        PERFORM workflow_case__fire_transition_internal(
            fire_message_transition__task_id,
            v_journal_id
        );

        PERFORM workflow_case__sweep_automatic_transitions (
            v_case_id,
            v_journal_id
        );

        return 0; 
end;$_$;


--
-- Name: workflow_case__fire_transition_(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__fire_transition_(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  fire_transition_internal__task_id                alias for $1;  
  fire_transition_internal__journal_id             alias for $2;  
  v_case_id                                        integer;        
  v_state                                          varchar;   
  v_transition_key                                 varchar;  
  v_workflow_key                                   varchar;  
  v_place_key                                      varchar;  
  v_direction                                      varchar;    
  v_guard_happy_p                                  boolean;       
  v_fire_callback                                  varchar;  
  v_fire_custom_arg                                text; 
  v_found_happy_guard                              boolean;       
  v_locked_task_id                                 integer;   
  place_rec                                        record;     
begin
        select t.case_id, t.state, t.workflow_key, t.transition_key, ti.fire_callback, ti.fire_custom_arg
        into   v_case_id, v_state, v_workflow_key, v_transition_key, v_fire_callback, v_fire_custom_arg
        from   wf_tasks t, wf_cases c, wf_transition_info ti
        where  t.task_id = fire_transition_internal__task_id
        and    c.case_id = t.case_id
        and    ti.context_key = c.context_key
        and    ti.workflow_key = c.workflow_key
        and    ti.transition_key = t.transition_key;

        /* Check that the state is either started or enabled */

        if v_state = 'enabled' then 
            v_locked_task_id := null;
        else if v_state = 'started' then
            v_locked_task_id := fire_transition_internal__task_id;
        else 
            raise EXCEPTION '-20000: Can''t fire the transition if it''s not in state enabled or started';
        end if; end if;

        /* Mark the task finished */

        update wf_tasks
        set    state = 'finished',
               finished_date = now()
        where  task_id = fire_transition_internal__task_id;


        /* Consume the tokens */

        for place_rec in select *
        from   wf_transition_places tp
        where  tp.workflow_key = v_workflow_key
        and    tp.transition_key = v_transition_key
        LOOP 
            PERFORM workflow_case__consume_token (
                v_case_id,
                place_rec.place_key,
                fire_transition_internal__journal_id,
                v_locked_task_id
             );
        end loop;

    
        /* Spit out new tokens in the output places */

        v_found_happy_guard := 'f';
        for place_rec in 
        select *
        from   wf_transition_places tp
        where  tp.workflow_key = v_workflow_key
        and    tp.transition_key = v_transition_key
        and    direction = 'out'
        LOOP
            v_place_key := place_rec.place_key;
            v_direction := place_rec.direction;

            v_guard_happy_p := workflow_case__evaluate_guard(
                place_rec.guard_callback, 
                place_rec.guard_custom_arg,
                v_case_id, 
                v_workflow_key, 
                v_transition_key, 
                v_place_key, 
                v_direction
            );
    
            if v_guard_happy_p = 't' then
                v_found_happy_guard := 't';
                PERFORM workflow_case__add_token (
                    v_case_id, 
                    place_rec.place_key,
                    fire_transition_internal__journal_id
                );
            end if;
        end loop;


        /* If we did not find any happy guards, look for arcs with the special hash (#) guard */

        if v_found_happy_guard = 'f' then
            for place_rec in 
                select place_key
                from   wf_transition_places tp
                where  tp.workflow_key = v_workflow_key
                and    tp.transition_key = v_transition_key
                and    tp.direction = 'out'
                and    tp.guard_callback = '#'
            loop

                PERFORM workflow_case__add_token (
                    v_case_id, 
                    place_rec.place_key,
                    fire_transition_internal__journal_id
                );
            end loop;
        end if;


        /* Execute the transition fire callback */

        PERFORM workflow_case__execute_transition_callback (
            v_fire_callback, 
            v_fire_custom_arg, 
            v_case_id, 
            v_transition_key
        );

        return 0; 
end;$_$;


--
-- Name: workflow_case__get_attribute_va(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__get_attribute_va(integer, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  get_attribute_value__case_id                alias for $1;  
  get_attribute_value__attribute_name         alias for $2;  
begin
        return acs_object__get_attribute (
            get_attribute_value__case_id,
            get_attribute_value__attribute_name
        );
     
end;$_$;


--
-- Name: workflow_case__get_task_deadlin(character varying, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__get_task_deadlin(character varying, character varying, character varying, integer, character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
declare
  get_task_deadline__callback               alias for $1;  
  get_task_deadline__custom_arg             alias for $2;  
  get_task_deadline__attribute_name         alias for $3;  
  get_task_deadline__case_id                alias for $4;  
  get_task_deadline__transition_key         alias for $5;  
  v_deadline                                timestamptz;
  v_rec                                     record;
  v_str                                     varchar;
begin
        /*
         * 1. or if there is a row in wf_case_deadlines, we use that
         * 2. if there is a callback, we execute that
         * 3. otherwise, if there is an attribute, we use that
         */

        /* wf_case_deadlines */
        select deadline into v_deadline
            from wf_case_deadlines
            where case_id = get_task_deadline__case_id
            and   transition_key = get_task_deadline__transition_key;

        if NOT FOUND then
            if get_task_deadline__callback != '' and get_task_deadline__callback is not null then
                /* callback */
                v_str := 'select ' || get_task_deadline__callback || '(' || 
                         get_task_deadline__case_id || ',' || 
                         quote_literal(get_task_deadline__transition_key) || ',' || 
                         coalesce(quote_literal(get_task_deadline__custom_arg),'null') || ') as deadline';

                for v_rec in execute v_str
                LOOP
                    v_deadline := v_rec.deadline;
                    exit;
                end LOOP;
            else if get_task_deadline__attribute_name != '' and get_task_deadline__attribute_name is not null then
                /* attribute */
                v_deadline := acs_object__get_attribute (
                    get_task_deadline__case_id,
                    get_task_deadline__attribute_name
                );
            else 
                v_deadline := null;
            end if; end if;
        end if;
        
        return v_deadline;
     
end;$_$;


--
-- Name: workflow_case__get_task_id(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__get_task_id(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  get_task_id__case_id         alias for $1;
  get_task_id__transition_key  alias for $2;
  v_task_id                    integer;
begin

  select task_id into v_task_id
  from wf_tasks
  where case_id = get_task_id__case_id and
    transition_key = get_task_id__transition_key;

  if not found then
    raise error 'Case % has no transition with key %', get_task_id__case_id, get_task_id__transition_key;

  return v_task_id;

end;$_$;


--
-- Name: workflow_case__lock_token(integer, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__lock_token(integer, character varying, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  lock_token__case_id                alias for $1;  
  lock_token__place_key              alias for $2;  
  lock_token__journal_id             alias for $3;  
  lock_token__task_id                alias for $4;  
begin
        -- FIXME: rownum 
--        update wf_tokens
--        set    state = 'locked',
--               locked_task_id = lock_token__task_id,
--               locked_date = now(),
--               locked_journal_id = lock_token__journal_id
--        where  case_id = lock_token__case_id
--        and    place_key = lock_token__place_key
--        and    state = 'free'
--        and    rownum = 1;

        update wf_tokens
        set    state = 'locked',
               locked_task_id = lock_token__task_id,
               locked_date = now(),
               locked_journal_id = lock_token__journal_id
        where  token_id = (select token_id 
                             from wf_tokens 
                            where case_id = lock_token__case_id
                              and place_key = lock_token__place_key
                              and state = 'free'
                            limit 1);

        return 0; 
end;$_$;


--
-- Name: workflow_case__new(integer, character varying, character varying, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__new(integer, character varying, character varying, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__case_id                alias for $1;  -- default null  
  new__workflow_key           alias for $2;  
  new__context_key            alias for $3;  -- default null
  new__object_id              alias for $4;  
  new__creation_date          alias for $5;  -- default now()
  new__creation_user          alias for $6;  -- default null
  new__creation_ip            alias for $7;  -- default null
  v_case_id                   integer;
  v_workflow_case_table       varchar;
  v_context_key_for_query     varchar;
begin
        if new__context_key = '' or new__context_key is null then
            v_context_key_for_query := 'default';
        else
            v_context_key_for_query := new__context_key;
        end if;

        /* insert a row into acs_objects */
        v_case_id := acs_object__new(
            new__case_id,
            new__workflow_key,
            new__creation_date,
            new__creation_user,
            new__creation_ip,
            null
        );

        /* insert the case in to the general wf_cases table */
        insert into wf_cases 
            (case_id, workflow_key, context_key, object_id, state)
        values 
            (v_case_id, new__workflow_key, v_context_key_for_query, new__object_id, 'created');
            
        /* insert the case into the workflow-specific cases table */
        select table_name into v_workflow_case_table
        from   acs_object_types
        where  object_type = new__workflow_key;

        execute 'insert into ' || v_workflow_case_table || ' (case_id) values (' || v_case_id || ')';

        return v_case_id;
     
end;$_$;


--
-- Name: workflow_case__notify_assignee(integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__notify_assignee(integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  notify_assignee__task_id                alias for $1;  
  notify_assignee__user_id                alias for $2;  
  notify_assignee__callback               alias for $3;  
  notify_assignee__custom_arg             alias for $4;  
  v_deadline_pretty                       varchar;  
  v_object_name                           text; 
  v_transition_key                        wf_transitions.transition_key%TYPE;
  v_transition_name                       wf_transitions.transition_name%TYPE;
  v_party_from                            parties.party_id%TYPE;
  v_party_to                              parties.party_id%TYPE;
  v_subject                               text; 
  v_body                                  text; 
  v_request_id                            integer; 
  v_workflow_url			  text;      
  v_str                                   text;
begin
        select to_char(ta.deadline,'Mon fmDDfm, YYYY HH24:MI:SS'),
               acs_object__name(c.object_id),
               tr.transition_key,
               tr.transition_name
        into   v_deadline_pretty,
               v_object_name, 
               v_transition_key,
               v_transition_name
          from wf_tasks ta, wf_transitions tr, wf_cases c
         where ta.task_id = notify_assignee__task_id
           and c.case_id = ta.case_id
           and tr.workflow_key = c.workflow_key
           and tr.transition_key = ta.transition_key;

        select apm__get_value(p.package_id,'SystemURL') || site_node__url(s.node_id)
          into v_workflow_url
          from site_nodes s, 
               apm_packages a,
               (select package_id
                from apm_packages 
                where package_key = 'acs-kernel') p
         where s.object_id = a.package_id 
           and a.package_key = 'acs-workflow';

        /* Mail sent from */
          select wfi.principal_party
	    into v_party_from
            from wf_context_workflow_info wfi, wf_tasks ta, wf_cases c
           where ta.task_id = notify_assignee__task_id
             and c.case_id = ta.case_id
             and wfi.workflow_key = c.workflow_key
             and wfi.context_key = c.context_key;
        if NOT FOUND then
            v_party_from := -1;
        end if;

        /* Subject */
        v_subject := 'Assignment: ' || v_transition_name || ' ' || v_object_name;

        /* Body */
        v_body := 'You have been assigned to a task.
' || '
Case        : ' || v_object_name || '
Task        : ' || v_transition_name || '
';

        if v_deadline_pretty != '' and v_deadline_pretty is not null then
            v_body := v_body || 'Deadline    : ' || v_deadline_pretty || '
';
        end if;

	v_body := v_body ||'Task website: '||v_workflow_url||'task?task_id='||notify_assignee__task_id||'
';

        /* 
         * We would like to add a URL to go visit, but how do we get that URL?
         *
         * The notifications should really be sent from the application 
         * server layer, not from the database 
         */
    
        -- FIXME: last three args are also out varibles.

        if notify_assignee__callback != '' and notify_assignee__callback is not null then
            v_str :=  'select ' || notify_assignee__callback || ' (' || 
                      notify_assignee__task_id || ',' ||
                      coalesce(quote_literal(notify_assignee__custom_arg),'null') || 
                      ',' ||
                      notify_assignee__user_id || ',' ||
                      v_party_from || ',' ||
                      quote_literal(v_subject) || ',' ||
                      quote_literal(v_body) || ')';

            execute v_str;
        else
            v_request_id := acs_mail_nt__post_request (       
                v_party_from,                 -- party_from
                notify_assignee__user_id,     -- party_to
                'f',                        -- expand_group
                v_subject,                    -- subject
                v_body,                       -- message
                0                             -- max_retries
            );
        end if;

    return 0; 
end;$_$;


--
-- Name: workflow_case__release_token(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__release_token(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  release_token__task_id                alias for $1;  
  release_token__journal_id             alias for $2;  
  token_rec                             record;
begin
        /* Add a new token for each released one */
        for token_rec in 
            select token_id, 
                   case_id, 
                   place_key
            from   wf_tokens
            where  state = 'locked'
            and    locked_task_id = release_token__task_id
        LOOP
            PERFORM workflow_case__add_token (
                token_rec.case_id,
                token_rec.place_key,
                release_token__journal_id
            );
        end loop;

        /* Mark the released ones canceled */
        update wf_tokens
        set    state = 'canceled',
               canceled_date = now(),
               canceled_journal_id = release_token__journal_id
        where  state = 'locked'
        and    locked_task_id = release_token__task_id;

        return 0; 
end;$_$;


--
-- Name: workflow_case__remove_case_dead(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__remove_case_dead(integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  remove_case_deadline__case_id		alias for $1;
  remove_case_deadline__transition_key	alias for $2;
begin
      perform workflow_case__set_case_deadline (
            remove_case_deadline__case_id,
            remove_case_deadline__transition_key,
            null
        );

  return 0;
end;$_$;


--
-- Name: workflow_case__remove_manual_as(integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__remove_manual_as(integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  remove_manual_assignment__case_id                alias for $1;  
  remove_manual_assignment__role_key		   alias for $2;  
  remove_manual_assignment__party_id               alias for $3;  
  v_workflow_key				   varchar;
begin
        select workflow_key 
          into v_workflow_key 
          from wf_cases
         where case_id = remove_manual_assignment__case_id;
        
        delete 
          from wf_case_assignments
         where workflow_key = v_workflow_key
           and case_id = remove_manual_assignment__case_id
           and role_key = remove_manual_assignment__role_key
           and party_id = remove_manual_assignment__party_id;

  return 0; 
end;$_$;


--
-- Name: workflow_case__remove_task_assi(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__remove_task_assi(integer, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  remove_task_assignment__task_id                alias for $1;  
  remove_task_assignment__party_id               alias for $2;  
  remove_task_assignment__permanent_p		 alias for $3;
  v_num_assigned                                 integer;        
  v_case_id                                      integer; 
  v_role_key					 wf_roles.role_key%TYPE;       
  v_workflow_key                                 varchar;  
  v_transition_key                               varchar;  
  v_context_key                                  varchar;  
  callback_rec                                   record;
begin
        -- get some information

        select ta.case_id, ta.transition_key, tr.role_key, ta.workflow_key, c.context_key
          into v_case_id, v_transition_key, v_role_key, v_workflow_key, v_context_key
          from wf_tasks ta, wf_transitions tr, wf_cases c
         where ta.task_id = remove_task_assignment__task_id
           and tr.workflow_key = ta.workflow_key
           and tr.transition_key = ta.transition_key
           and c.case_id = ta.case_id;

        -- make the same assignment as a manual assignment

        if remove_task_assignment__permanent_p = 't' then
            perform workflow_case__remove_manual_assignment (
                v_case_id,
                v_role_key,
                remove_task_assignment__party_id
            );
        end if;

        -- now delete the row
 
        delete 
          from wf_task_assignments
         where task_id = remove_task_assignment__task_id
           and party_id = remove_task_assignment__party_id;

        -- check if the task now became unassigned

        select count(*) 
          into v_num_assigned
          from wf_task_assignments
         where task_id = remove_task_assignment__task_id;

        if v_num_assigned > 0 then
            return 0;
        end if;

        -- yup, the task is now unassigned; fire the callback

        select unassigned_callback, unassigned_custom_arg
          into callback_rec
            from   wf_context_transition_info
            where  workflow_key = v_workflow_key
            and    context_key = v_context_key
            and    transition_key = v_transition_key;
        if FOUND then
            PERFORM workflow_case__execute_unassigned_callback (
                callback_rec.unassigned_callback,
                remove_task_assignment__task_id,
                callback_rec.unassigned_custom_arg
            );
        end if;

        return 0; 
end;$_$;


--
-- Name: workflow_case__resume(integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__resume(integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  resume__case_id                alias for $1;  
  resume__user_id                alias for $2;  -- default null  
  resume__ip_address             alias for $3;  -- default null
  resume__msg                    alias for $4;  -- default null
  v_state                        varchar;   
  v_journal_id                   integer;        
begin
        select state into v_state
        from   wf_cases
        where  case_id = resume__case_id;

        if v_state != 'suspended' and v_state != 'canceled' then
            raise EXCEPTION '-20000: Only suspended or canceled cases can be resumed';
        end if;

        /* Add an entry to the journal */
        v_journal_id := journal_entry__new(
            null,
            resume__case_id,
            'case resume',
            'case resumed',
            now(),
            resume__user_id,
            resume__ip_address,
            resume__msg
        );

        update wf_cases
        set    state = 'active'
        where  case_id = resume__case_id;

        return 0; 
end;$_$;


--
-- Name: workflow_case__set_attribute_va(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__set_attribute_va(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_attribute_value__journal_id             alias for $1;  
  set_attribute_value__attribute_name         alias for $2;  
  set_attribute_value__value                  alias for $3;  
  v_workflow_key                              varchar;
  v_case_id                                   integer;
  v_attribute_id                              integer;
begin
        select o.object_type, o.object_id into v_workflow_key, v_case_id
        from   journal_entries je, acs_objects o
        where  je.journal_id = set_attribute_value__journal_id
        and    o.object_id = je.object_id;
        
        select attribute_id into v_attribute_id
        from acs_attributes
        where object_type = v_workflow_key
        and   attribute_name = set_attribute_value__attribute_name;
        
        PERFORM acs_object__set_attribute (
            v_case_id,  
            set_attribute_value__attribute_name,
            set_attribute_value__value
        );

        insert into wf_attribute_value_audit
            (case_id, attribute_id, journal_id, attr_value)
        values
            (v_case_id, v_attribute_id, set_attribute_value__journal_id, 
             set_attribute_value__value);

        return 0; 
end;$_$;


--
-- Name: workflow_case__set_case_deadlin(integer, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__set_case_deadlin(integer, character varying, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_case_deadline__case_id		alias for $1;
  set_case_deadline__transition_key	alias for $2;
  set_case_deadline__deadline		alias for $3;
  v_workflow_key			wf_workflows.workflow_key%TYPE;
begin
        -- delete the current deadline row
        delete
          from wf_case_deadlines
         where case_id = set_case_deadline__case_id
           and transition_key = set_case_deadline__transition_key;

        if set_case_deadline__deadline is not null then
            -- get some info
            select workflow_key
              into v_workflow_key
              from wf_cases
             where case_id = set_case_deadline__case_id;

            -- insert new deadline row
            insert into wf_case_deadlines (
                case_id,
                workflow_key,
                transition_key,
                deadline
            ) values (
                set_case_deadline__case_id,
                v_workflow_key,
                set_case_deadline__transition_key,
                set_case_deadline__deadline
            );
        end if;
  return 0;
end;$_$;


--
-- Name: workflow_case__set_task_assignm(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__set_task_assignm(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  set_task_assignments__task_id                alias for $1;  
  set_task_assignments__callback               alias for $2;  
  set_task_assignments__custom_arg             alias for $3;  
  v_done_p                                     boolean;
  case_assignment_rec                          record;
  context_assignment_rec                       record;
  v_str                                        text;
begin

        /* Find out who to assign the given task to.
         *
         * 1. See if there are rows in wf_case_assignments.
         * 2. If not, and a callback is defined, execute that.
         * 3. Otherwise, grab the assignment from the workflow context.
         *
         * (We used to use the callback first, but that makes
         *  reassignment of tasks difficult.)
         */

        v_done_p := 'f';
        for case_assignment_rec in  select party_id
              from wf_case_assignments ca, wf_tasks t, wf_transitions tr
             where t.task_id = set_task_assignments__task_id
               and ca.case_id = t.case_id
               and ca.role_key = tr.role_key
               and tr.workflow_key = t.workflow_key
               and tr.transition_key = t.transition_key
        LOOP
            v_done_p := 't';
            PERFORM workflow_case__add_task_assignment (
                set_task_assignments__task_id,
                case_assignment_rec.party_id,
		'f'
            );
        end loop;
        if v_done_p != 't' then

            if set_task_assignments__callback != '' and set_task_assignments__callback is not null then
                v_str := 'select '|| set_task_assignments__callback || '(' || 
                set_task_assignments__task_id || ',' || 
                coalesce(quote_literal(set_task_assignments__custom_arg),'null') || ')';
                execute v_str;
            else
                for context_assignment_rec in  
                    select party_id
		    from wf_context_assignments ca, wf_cases c, wf_tasks t, wf_transitions tr
		    where t.task_id = set_task_assignments__task_id
		    and c.case_id = t.case_id
		    and ca.context_key = c.context_key
		    and ca.workflow_key = t.workflow_key
		    and ca.role_key = tr.role_key
		    and tr.workflow_key = t.workflow_key
		    and tr.transition_key = t.transition_key
                LOOP
                    PERFORM workflow_case__add_task_assignment (
                        set_task_assignments__task_id,
                        context_assignment_rec.party_id,
			'f'
                    );
                end LOOP;
            end if;
        end if;

        return 0; 
end;$_$;


--
-- Name: workflow_case__start_case(integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__start_case(integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  start_case__case_id                alias for $1;  
  start_case__creation_user          alias for $2;  -- default null  
  start_case__creation_ip            alias for $3;  -- default null
  start_case__msg                    alias for $4;  -- default null
  v_journal_id                       integer;        
begin
        /* Add an entry to the journal */
        v_journal_id := journal_entry__new(
            null, 
            start_case__case_id,
            'case start',
            'Case started',
            now(),
            start_case__creation_user,
            start_case__creation_ip,
            start_case__msg
        );

        update wf_cases 
           set state = 'active' 
         where case_id = start_case__case_id;

        PERFORM workflow_case__add_token (
            start_case__case_id, 
            'start',
            v_journal_id
        );

        -- Turn the wheels
        PERFORM workflow_case__sweep_automatic_transitions (
            start_case__case_id,
            v_journal_id
        );

        return 0; 
end;$_$;


--
-- Name: workflow_case__start_task(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__start_task(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  start_task__task_id                alias for $1;  
  start_task__user_id                alias for $2;  
  start_task__journal_id             alias for $3;  
  v_case_id                          integer;        
  v_workflow_key                     wf_workflows.workflow_key%TYPE;
  v_transition_key                   varchar(100);  
  v_hold_timeout_callback            varchar(100);  
  v_hold_timeout_custom_arg          varchar(4000); 
  v_hold_timeout                     timestamptz;     
  place_rec                          record;
begin
        PERFORM workflow_case__ensure_task_in_state(start_task__task_id, 
                                                    'enabled');
    
        select t.case_id, t.workflow_key, t.transition_key, ti.hold_timeout_callback, ti.hold_timeout_custom_arg 
        into   v_case_id, v_workflow_key, v_transition_key, v_hold_timeout_callback, v_hold_timeout_custom_arg
        from   wf_tasks t, wf_cases c, wf_transition_info ti
        where  t.task_id = start_task__task_id
        and    c.case_id = t.case_id
        and    ti.context_key = c.context_key
        and    ti.workflow_key = t.workflow_key
        and    ti.transition_key = t.transition_key;

        v_hold_timeout := workflow_case__execute_hold_timeout_callback (
                       v_hold_timeout_callback, 
                       v_hold_timeout_custom_arg, 
                       v_case_id, v_transition_key);

        /* Mark it started */

        update wf_tasks 
        set    state = 'started', 
               started_date = now(),
               holding_user = start_task__user_id, 
               hold_timeout = v_hold_timeout
        where task_id = start_task__task_id;
    
        
        /* Reserve one token from each input place */

        for place_rec in select *
        from   wf_transition_places tp
        where  tp.workflow_key = v_workflow_key
        and    tp.transition_key = v_transition_key
        and    direction = 'in'
        LOOP
            PERFORM workflow_case__lock_token (  
                v_case_id,
                place_rec.place_key,
                start_task__journal_id,
                start_task__task_id
            );
        end loop;

        return 0; 
end;$_$;


--
-- Name: workflow_case__suspend(integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__suspend(integer, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  suspend__case_id                alias for $1;  
  suspend__user_id                alias for $2;  -- default null  
  suspend__ip_address             alias for $3;  -- default null
  suspend__msg                    alias for $4;  -- default null
  v_state                         varchar;   
  v_journal_id                    integer;        
begin
        select state into v_state
        from   wf_cases
        where  case_id = suspend__case_id;

        if v_state != 'active' then
            raise EXCEPTION '-20000: Only active cases can be suspended';
        end if;
        
        /* Add an entry to the journal */
        v_journal_id := journal_entry__new(
            null,
            suspend__case_id,
            'case suspend',
            'case suspended',
            now(),
            suspend__user_id,
            suspend__ip_address,
            suspend__msg
        );

        update wf_cases
        set    state = 'suspended'
        where  case_id = suspend__case_id;

        return 0; 
end;$_$;


--
-- Name: workflow_case__sweep_automatic_(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__sweep_automatic_(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  sweep_automatic_transitions__case_id                alias for $1;  
  sweep_automatic_transitions__journal_id             alias for $2;  
  v_done_p                                            boolean:='f';       
  v_finished_p                                        boolean;       
  task_rec                                            record;
begin

        PERFORM workflow_case__enable_transitions(sweep_automatic_transitions__case_id);
        while v_done_p != 't' loop
            v_done_p := 't';
            v_finished_p := workflow_case__finished_p (
                sweep_automatic_transitions__case_id,
                sweep_automatic_transitions__journal_id);

            if v_finished_p = 'f' then
                for task_rec in 
                    select task_id
                    from   wf_tasks ta, wf_transitions tr
                    where  tr.workflow_key = ta.workflow_key
                    and    tr.transition_key = ta.transition_key
                    and    tr.trigger_type = 'automatic'
                    and    ta.state = 'enabled'
                    and    ta.case_id = sweep_automatic_transitions__case_id
                LOOP
                    PERFORM workflow_case__fire_transition_internal (
                        task_rec.task_id,
                        sweep_automatic_transitions__journal_id
                    );

                    v_done_p := 'f';
                end loop;
                PERFORM workflow_case__enable_transitions(sweep_automatic_transitions__case_id);
            end if;

        end loop;

        return 0; 
end;$_$;


--
-- Name: workflow_case__sweep_hold_timeo(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__sweep_hold_timeo() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
        v_journal_id    integer;
        task_rec        record;
begin
        for task_rec in select t.task_id, t.case_id, tr.transition_name
            from   wf_tasks t, wf_transitions tr
            where  hold_timeout <= now()
            and    state = 'started'
            and    tr.workflow_key = t.workflow_key
            and    tr.transition_key = t.transition_key
        LOOP
 
            /* Insert an entry to the journal so people will know it was canceled */

            v_journal_id := journal_entry__new (
                null,
                task_rec.case_id, 
                'task ' || task_rec.task_id || ' cancel timeout',
                task_rec.transition_name || ' timed out', 
                now(),
                null,
                null,
                'The user''s hold on the task timed out and the task was automatically canceled'
            );


            /* Cancel the task */

            PERFORM workflow_case__cancel_task (
                task_rec.task_id,
                v_journal_id
            );

        end loop;

        return 0;
end;$$;


--
-- Name: workflow_case__sweep_timed_tran(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__sweep_timed_tran() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
        v_journal_id    integer;
        trans_rec       record;
begin
        for trans_rec in select t.task_id, t.case_id, tr.transition_name
            from   wf_tasks t, wf_transitions tr
            where  trigger_time <= now()
            and    state = 'enabled'
            and    tr.workflow_key = t.workflow_key
            and    tr.transition_key = t.transition_key 
        LOOP
 
            /* Insert an entry to the journal so people will know it fired */

            v_journal_id := journal_entry__new (
                null,
                trans_rec.case_id, 
                'task ' || trans_rec.task_id || ' fire time',
                trans_rec.transition_name || ' automatically finished',
                now(),
                null,
                null,
                'Timed transition fired.'
            );
        
            /* Fire the transition */

            PERFORM workflow_case__fire_transition_internal (
                trans_rec.task_id,
                v_journal_id
            );

            /* Update the workflow internal state */

            PERFORM workflow_case__sweep_automatic_transitions(
                trans_rec.case_id,
                v_journal_id
            );

        end loop;

        return 0;
end;$$;


--
-- Name: workflow_case__task_action(integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION workflow_case__task_action(integer, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  task_action__task_id                alias for $1;  
  task_action__action                 alias for $2;  
  task_action__action_ip              alias for $3;  
  task_action__user_id                alias for $4;  
  task_action__msg                    alias for $5;  -- default null  
  v_journal_id                        integer;       
begin
        v_journal_id := workflow_case__begin_task_action (
            task_action__task_id,
            task_action__action,
            task_action__action_ip,
            task_action__user_id,
            task_action__msg
        );
        
        PERFORM workflow_case__end_task_action (
            v_journal_id,
            task_action__action,
            task_action__task_id
        );

        return v_journal_id;        
     
end;$_$;


SET default_tablespace = '';

SET default_with_oids = true;

--
-- Name: aa_test_final_results; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE aa_test_final_results (
    testcase_id character varying(512),
    package_key character varying(100),
    "timestamp" timestamp with time zone,
    passes integer,
    fails integer
);


--
-- Name: aa_test_results; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE aa_test_results (
    testcase_id character varying(512),
    package_key character varying(100),
    test_id integer,
    "timestamp" timestamp with time zone,
    result character varying(4),
    notes character varying(2000)
);


--
-- Name: acs_activities; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_activities (
    activity_id integer NOT NULL,
    name character varying(255) NOT NULL,
    description text,
    html_p boolean DEFAULT false,
    status_summary character varying(255)
);


--
-- Name: TABLE acs_activities; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_activities IS '
    Represents what happens during an event
';


--
-- Name: acs_activity_object_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_activity_object_map (
    activity_id integer NOT NULL,
    object_id integer NOT NULL
);


--
-- Name: TABLE acs_activity_object_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_activity_object_map IS '
    Maps between an activity and multiple ACS objects.
';


--
-- Name: acs_attribute_descriptions; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_attribute_descriptions (
    object_type character varying(100) NOT NULL,
    attribute_name character varying(100) NOT NULL,
    description_key character varying(100) NOT NULL,
    description text NOT NULL
);


--
-- Name: acs_attribute_id_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_attribute_id_seq AS
    SELECT nextval(('t_acs_attribute_id_seq'::text)::regclass) AS nextval;


--
-- Name: acs_attribute_value_id_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_attribute_value_id_seq AS
    SELECT nextval(('t_acs_attribute_value_id_seq'::text)::regclass) AS nextval;


--
-- Name: acs_attribute_values; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_attribute_values (
    object_id integer NOT NULL,
    attribute_id integer NOT NULL,
    attr_value text
);


--
-- Name: TABLE acs_attribute_values; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_attribute_values IS '
  Instead of coercing everything into a big string, we could use
  a "union", i.e, a string column, a number column, a date column,
  and a discriminator.
';


--
-- Name: acs_attributes; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_attributes (
    attribute_id integer NOT NULL,
    object_type character varying(100) NOT NULL,
    table_name character varying(30),
    attribute_name character varying(100) NOT NULL,
    pretty_name character varying(100) NOT NULL,
    pretty_plural character varying(100),
    sort_order integer NOT NULL,
    datatype character varying(50) NOT NULL,
    default_value text,
    min_n_values integer DEFAULT 1 NOT NULL,
    max_n_values integer DEFAULT 1 NOT NULL,
    storage character varying(13) DEFAULT 'type_specific'::character varying,
    static_p boolean DEFAULT false,
    column_name character varying(30),
    CONSTRAINT acs_attributes_max_n_ck CHECK ((max_n_values >= 0)),
    CONSTRAINT acs_attributes_min_n_ck CHECK ((min_n_values >= 0)),
    CONSTRAINT acs_attributes_n_values_ck CHECK ((min_n_values <= max_n_values)),
    CONSTRAINT acs_attributes_storage_ck CHECK ((((storage)::text = ('type_specific'::character varying)::text) OR ((storage)::text = ('generic'::character varying)::text)))
);


--
-- Name: TABLE acs_attributes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_attributes IS '
 Each row in the <code>acs_attributes</code> table defines an
 attribute of the specified object type. Each object of this type
 must have a minimum of min_n_values values and a maximum of
 max_n_values for this attribute.
';


--
-- Name: COLUMN acs_attributes.table_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_attributes.table_name IS '
 If the data storage for the object type is arranged in a vertically
 partitioned manner, then this column should indicate in which table
 the attribute is stored.
';


--
-- Name: COLUMN acs_attributes.storage; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_attributes.storage IS '
 Indicates how values of this attribute are stored: either
 "type_specific" (i.e., in the table identified by
 object_type.table_name) or "generic" (i.e., in the
 acs_attribute_values table). (Or we could just have a column_name and,
 if it''s null, then assume that we''re using acs_attribute_values.)
';


--
-- Name: COLUMN acs_attributes.static_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_attributes.static_p IS '
 Determines whether this attribute is static. If so, only one copy of
 the attribute''s value exists for all objects of the same type. This
 value is stored in acs_static_attr_values table if storage_type is
 "generic". Otherwise, each object of this type can have its own
 distinct value for the attribute.
';


--
-- Name: COLUMN acs_attributes.column_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_attributes.column_name IS '
 If storage is "type_specific", column_name identifies the column in
 the table identified by object_type.table_name that holds the values
 of this attribute. If column_name is null, then we assume that
 attribute_name identifies a column in the table identified by
 object_type.table_name.
';


--
-- Name: acs_contents; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_contents (
    content_id integer NOT NULL,
    content integer,
    searchable_p boolean DEFAULT true,
    nls_language character varying(50),
    mime_type character varying(200) DEFAULT 'text/plain'::character varying,
    CONSTRAINT acs_cont_searchable_p_ck CHECK (((searchable_p = true) OR (searchable_p = false)))
);


--
-- Name: TABLE acs_contents; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_contents IS 'Table for storing object content';


--
-- Name: COLUMN acs_contents.searchable_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_contents.searchable_p IS 'Include content for search?';


--
-- Name: acs_data_links; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_data_links (
    rel_id integer NOT NULL,
    object_id_one integer NOT NULL,
    object_id_two integer NOT NULL
);


--
-- Name: acs_data_links_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE acs_data_links_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: acs_datatypes; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_datatypes (
    datatype character varying(50) NOT NULL,
    max_n_values integer DEFAULT 1,
    CONSTRAINT acs_datatypes_max_n_ck CHECK ((max_n_values > 0))
);


--
-- Name: TABLE acs_datatypes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_datatypes IS '
 Defines the set of available datatypes for acs_attributes. These
 datatypes are abstract, not implementation-specific, i.e., they
 are not Oracle datatypes. The set of pre-defined datatypes is
 inspired by XForms (http://www.w3.org/TR/xforms-datamodel/).
';


--
-- Name: COLUMN acs_datatypes.max_n_values; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_datatypes.max_n_values IS '
 The maximum number of values that any attribute with this datatype
 can have. Of the predefined attribute types, only "boolean" specifies
 a non-null max_n_values, because it doesn''t make sense to have a
 boolean attribute with more than one value. There is no
 corresponding min_n_values column, because each attribute may be
 optional, i.e., min_n_values would always be zero.
';


--
-- Name: acs_enum_values; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_enum_values (
    attribute_id integer NOT NULL,
    enum_value character varying(1000) NOT NULL,
    pretty_name character varying(100) NOT NULL,
    sort_order integer NOT NULL
);


--
-- Name: acs_event_party_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_event_party_map (
    event_id integer NOT NULL,
    party_id integer NOT NULL
);


--
-- Name: TABLE acs_event_party_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_event_party_map IS '
        Maps a many-to-many relationship between events and parties.
';


--
-- Name: acs_events; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_events (
    event_id integer NOT NULL,
    name character varying(255),
    description text,
    html_p boolean,
    status_summary character varying(255),
    activity_id integer,
    timespan_id integer,
    recurrence_id integer,
    related_link_url text,
    related_link_text text,
    redirect_to_rel_link_p boolean
);


--
-- Name: TABLE acs_events; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_events IS '
    A relationship between a time span and an activity.
';


--
-- Name: COLUMN acs_events.name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_events.name IS '
        The name of the event.
';


--
-- Name: COLUMN acs_events.description; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_events.description IS '
        The description of the event.
';


--
-- Name: COLUMN acs_events.html_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_events.html_p IS '
        Whether or not the description is in HTML.
';


--
-- Name: COLUMN acs_events.status_summary; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_events.status_summary IS '
        Additional information to display along with the name.
';


--
-- Name: COLUMN acs_events.activity_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_events.activity_id IS '
    The activity associated with this event.
';


--
-- Name: COLUMN acs_events.timespan_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_events.timespan_id IS '
    The time span associated with this event.
';


--
-- Name: COLUMN acs_events.recurrence_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_events.recurrence_id IS '
    A description of how this event recurs.  If null, then this event does
    not recur.
';


--
-- Name: acs_events_activities; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_events_activities AS
    SELECT e.event_id, CASE WHEN (e.name IS NOT NULL) THEN e.name WHEN (a.name IS NOT NULL) THEN a.name ELSE NULL::character varying END AS name, CASE WHEN (e.description IS NOT NULL) THEN e.description WHEN (a.description IS NOT NULL) THEN a.description ELSE NULL::text END AS description, CASE WHEN (e.html_p IS NOT NULL) THEN e.html_p WHEN (a.html_p IS NOT NULL) THEN a.html_p ELSE NULL::boolean END AS html_p, CASE WHEN (e.status_summary IS NOT NULL) THEN e.status_summary WHEN (a.status_summary IS NOT NULL) THEN a.status_summary ELSE NULL::character varying END AS status_summary, e.activity_id, e.timespan_id, e.recurrence_id FROM acs_events e, acs_activities a WHERE (e.activity_id = a.activity_id);


--
-- Name: VIEW acs_events_activities; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW acs_events_activities IS '
    This view pulls the event name and description from the underlying
    activity if necessary.
';


--
-- Name: time_intervals; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE time_intervals (
    interval_id integer NOT NULL,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    CONSTRAINT time_interval_date_order_ck CHECK ((start_date <= end_date))
);


--
-- Name: TABLE time_intervals; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE time_intervals IS '
    A time interval is represented by two points in time.
';


--
-- Name: timespans; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE timespans (
    timespan_id integer NOT NULL,
    interval_id integer
);


--
-- Name: TABLE timespans; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE timespans IS '
    Establishes a relationship between timespan_id and multiple time
    intervals.  Represents a range of moments at which an event can occur.
';


--
-- Name: acs_events_dates; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_events_dates AS
    SELECT e.event_id, e.name, e.description, e.html_p, e.status_summary, e.activity_id, e.timespan_id, e.recurrence_id, e.related_link_url, e.related_link_text, e.redirect_to_rel_link_p, t.start_date, t.end_date FROM acs_events e, timespans s, time_intervals t WHERE ((e.timespan_id = s.timespan_id) AND (s.interval_id = t.interval_id));


--
-- Name: VIEW acs_events_dates; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW acs_events_dates IS '
    This view produces a separate row for each time interval in the timespan
    associated with an event.
';


--
-- Name: dual; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW dual AS
    SELECT now() AS sysdate;


--
-- Name: acs_events_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_events_seq AS
    SELECT nextval(('acs_events_sequence'::text)::regclass) AS nextval FROM dual;


--
-- Name: acs_events_sequence; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE acs_events_sequence
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: acs_func_defs; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_func_defs AS
    SELECT get_func_definition((pg_proc.proname)::character varying, pg_proc.proargtypes) AS definition, pg_proc.proname AS fname FROM pg_proc;


--
-- Name: acs_func_headers; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_func_headers AS
    SELECT get_func_header((pg_proc.proname)::character varying, pg_proc.proargtypes) AS definition, pg_proc.proname AS fname FROM pg_proc;


--
-- Name: acs_function_args; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_function_args (
    function character varying(100) NOT NULL,
    arg_seq integer NOT NULL,
    arg_name character varying(100),
    arg_default character varying(100)
);


--
-- Name: acs_object_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_object_types (
    object_type character varying(100) NOT NULL,
    supertype character varying(100),
    abstract_p boolean DEFAULT false NOT NULL,
    pretty_name character varying(100) NOT NULL,
    pretty_plural character varying(100) NOT NULL,
    table_name character varying(30) NOT NULL,
    id_column character varying(30) NOT NULL,
    package_name character varying(30) NOT NULL,
    name_method character varying(100),
    type_extension_table character varying(30),
    dynamic_p boolean DEFAULT false,
    tree_sortkey bit varying
);


--
-- Name: TABLE acs_object_types; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_object_types IS '
 Each row in the acs_object_types table represents a distinct class
 of objects. For each instance of any acs_object_type, there is a
 corresponding row in the acs_objects table. Essentially,
 acs_objects.object_id supersedes the on_which_table/on_what_id pair
 that ACS 3.x used as the system-wide identifier for heterogeneous
 objects. The value of having a system-wide identifier for
 heterogeneous objects is that it helps us provide general solutions
 for common problems like access control, workflow, categorppization,
 and search. (Note that this framework is not overly restrictive,
 because it doesn''t force every type of object to be represented in
 the acs_object_types table.) Each acs_object_type has:
 * Attributes (stored in the acs_attributes table)
   Examples:
   * the "user" object_type has "email" and "password" attributes
   * the "content_item" object_type has "title" and "body" attributes
 * Relationship types (stored in the acs_rel_types table)
   Examples:
   * "a team has one team leader who is a user" (in other words,
     instances of the "team" object_type must have one "team leader"
     relationship to an instance of the "user" object_type)
   * "a content item may have zero or authors who are people or
     organizations, i.e., parties" (in other words, instances of
     the "content_item" object_type may have zero or more "author"
     relationships to instances of the "party" object_type)
 Possible extensions include automatic versioning, logical deletion,
 and auditing.
';


--
-- Name: COLUMN acs_object_types.supertype; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_object_types.supertype IS '
 The object_type of which this object_type is a specialization (if
 any). For example, the supertype of the "user" object_type is
 "person". An object_type inherits the attributes and relationship
 rules of its supertype, though it can add constraints to the
 attributes and/or it can override the relationship rules. For
 instance, the "person" object_type has an optional "email" attribute,
 while its "user" subtype makes "email" mandatory.
';


--
-- Name: COLUMN acs_object_types.abstract_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_object_types.abstract_p IS '
 ...
 If the object_type is not abstract, then all of its attributes must
 have a non-null storage specified.
';


--
-- Name: COLUMN acs_object_types.table_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_object_types.table_name IS '
 The name of the type-specific table in which the values of attributes
 specific to this object_type are stored, if any.
';


--
-- Name: COLUMN acs_object_types.id_column; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_object_types.id_column IS '
 The name of the primary key column in the table identified by
 table_name.
';


--
-- Name: COLUMN acs_object_types.name_method; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_object_types.name_method IS '
 The name of a stored function that takes an object_id as an argument
 and returns a varchar2: the corresponding object name. This column is
 required to implement the polymorphic behavior of the acs.object_name()
 function.
';


--
-- Name: COLUMN acs_object_types.type_extension_table; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_object_types.type_extension_table IS '
 Object types (and their subtypes) that require more type-specific
 data than the fields already existing in acs_object_types may name
 a table in which that data is stored.  The table should be keyed
 by the associated object_type.  For example, a row in the user_group_types
 table stores a default approval policy for every user group of that type.
 In this example, the user_group_types table has a primary key named
 group_type that references acs_object_types.  If a subtype of user_groups
 for example, lab_courses, has its own type-specific data, it could be
 maintained in a table called lab_course_types, with a primary key named
 lab_course_type that references user_group_types.  This provides the same
 functionality as static class fields in an object-oriented programming language.
';


--
-- Name: COLUMN acs_object_types.dynamic_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_object_types.dynamic_p IS '
  This flag is used to identify object types created dynamically
  (e.g. through a web interface). Dynamically created object types can
  be administered differently. For example, the group type admin pages
  only allow users to add attributes or otherwise modify dynamic
  object types. This column is still experimental and may not be supported in the
  future. That is the reason it is not yet part of the API.
';


--
-- Name: group_element_index; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE group_element_index (
    group_id integer NOT NULL,
    element_id integer NOT NULL,
    rel_id integer NOT NULL,
    container_id integer NOT NULL,
    rel_type character varying(100) NOT NULL,
    ancestor_rel_type character varying(100) NOT NULL,
    CONSTRAINT grp_el_idx_ancstr_rel_type_ck CHECK ((((ancestor_rel_type)::text = ('composition_rel'::character varying)::text) OR ((ancestor_rel_type)::text = ('membership_rel'::character varying)::text)))
);


--
-- Name: TABLE group_element_index; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE group_element_index IS '
 This table is for internal use by the parties system.  It as an auxiliary
 table, a denormalization of data, that is used to improve performance.
 Do not query on this table or insert into it.  Query on group_element_map
 instead.  And insert by using the API''s for membership_rel, composition_rel, 
 or some sub-type of those relationship types.
';


--
-- Name: group_element_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW group_element_map AS
    SELECT group_element_index.group_id, group_element_index.element_id, group_element_index.rel_id, group_element_index.container_id, group_element_index.rel_type, group_element_index.ancestor_rel_type FROM group_element_index;


--
-- Name: group_member_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW group_member_map AS
    SELECT group_element_map.group_id, group_element_map.element_id AS member_id, group_element_map.rel_id, group_element_map.container_id, group_element_map.rel_type FROM group_element_map WHERE ((group_element_map.ancestor_rel_type)::text = ('membership_rel'::character varying)::text);


--
-- Name: membership_rels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE membership_rels (
    rel_id integer NOT NULL,
    member_state character varying(20),
    CONSTRAINT membership_rel_mem_ck CHECK ((((((((member_state)::text = 'approved'::text) OR ((member_state)::text = 'needs approval'::text)) OR ((member_state)::text = 'banned'::text)) OR ((member_state)::text = 'rejected'::text)) OR ((member_state)::text = 'deleted'::text)) OR ((member_state)::text = 'merged'::text)))
);


--
-- Name: group_approved_member_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW group_approved_member_map AS
    SELECT gm.group_id, gm.member_id, gm.rel_id, gm.container_id, gm.rel_type FROM group_member_map gm, membership_rels mr WHERE ((gm.rel_id = mr.rel_id) AND ((mr.member_state)::text = ('approved'::character varying)::text));


--
-- Name: parties; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE parties (
    party_id integer NOT NULL,
    email character varying(100),
    url character varying(200)
);


--
-- Name: TABLE parties; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE parties IS '
 Party is the supertype of person and organization. It exists because
 many other types of object can have relationships to parties.
';


--
-- Name: COLUMN parties.url; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN parties.url IS '
 We store url here so that we can always make party names hyperlinks
 without joining to any other table.
';


--
-- Name: rel_segments; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE rel_segments (
    segment_id integer NOT NULL,
    segment_name character varying(230) NOT NULL,
    group_id integer NOT NULL,
    rel_type character varying(100) NOT NULL
);


--
-- Name: TABLE rel_segments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE rel_segments IS '
  Defines relational segments. Each relational segment is a pair of
  <code>group_id</code> / <code>rel_type</code>, or, in english, the
  parties that have a relation of type rel_type to group_id.
';


--
-- Name: COLUMN rel_segments.segment_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rel_segments.segment_name IS '
  The user-entered name of the relational segment.
';


--
-- Name: COLUMN rel_segments.group_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rel_segments.group_id IS '
  The group for which this segment was created.
';


--
-- Name: COLUMN rel_segments.rel_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rel_segments.rel_type IS '
  The relationship type used to define elements in this segment.
';


--
-- Name: rel_seg_approved_member_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_seg_approved_member_map AS
    SELECT rs.segment_id, gem.element_id AS member_id, gem.rel_id, gem.rel_type, gem.group_id, gem.container_id FROM membership_rels mr, group_element_map gem, rel_segments rs, acs_object_types o1, acs_object_types o2 WHERE ((((((rs.group_id = gem.group_id) AND ((rs.rel_type)::text = (o2.object_type)::text)) AND ((o1.object_type)::text = (gem.rel_type)::text)) AND ((o1.tree_sortkey >= o2.tree_sortkey) AND (o1.tree_sortkey <= tree_right(o2.tree_sortkey)))) AND (mr.rel_id = gem.rel_id)) AND ((mr.member_state)::text = ('approved'::character varying)::text));


--
-- Name: users; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE users (
    user_id integer NOT NULL,
    password character(40),
    salt character(40),
    screen_name character varying(100),
    priv_name integer DEFAULT 0 NOT NULL,
    priv_email integer DEFAULT 5 NOT NULL,
    email_verified_p boolean DEFAULT true,
    email_bouncing_p boolean DEFAULT false NOT NULL,
    no_alerts_until timestamp with time zone,
    last_visit timestamp with time zone,
    second_to_last_visit timestamp with time zone,
    n_sessions integer DEFAULT 1 NOT NULL,
    password_question character varying(1000),
    password_answer character varying(1000),
    password_changed_date timestamp with time zone DEFAULT now(),
    authority_id integer,
    username character varying(100) NOT NULL,
    auth_token character varying(100)
);


--
-- Name: TABLE users; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE users IS '
 The creation_date and creation_ip columns inherited from acs_objects
 indicate when and from where the user registered. How do we apply a
 constraint ("email must not be null") to the parent type?
';


--
-- Name: COLUMN users.no_alerts_until; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN users.no_alerts_until IS '
 For suppressing email alerts
';


--
-- Name: COLUMN users.last_visit; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN users.last_visit IS '
 Set when user reappears at site
';


--
-- Name: COLUMN users.second_to_last_visit; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN users.second_to_last_visit IS '
 This is what most pages query against (since last_visit will only be
 a few minutes old for most pages in a session)
';


--
-- Name: COLUMN users.n_sessions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN users.n_sessions IS '
 How many times this user has visited
';


--
-- Name: acs_grantee_party_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_grantee_party_map AS
    (((SELECT (-1) AS grantee_id, 0 AS party_id FROM dual UNION ALL SELECT (-1) AS grantee_id, users.user_id AS party_id FROM users) UNION ALL SELECT parties.party_id AS grantee_id, parties.party_id FROM parties) UNION ALL SELECT rel_seg_approved_member_map.segment_id AS grantee_id, rel_seg_approved_member_map.member_id AS party_id FROM rel_seg_approved_member_map) UNION ALL SELECT group_approved_member_map.group_id AS grantee_id, group_approved_member_map.member_id AS party_id FROM group_approved_member_map;


--
-- Name: acs_log_id_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_log_id_seq AS
    SELECT nextval(('t_acs_log_id_seq'::text)::regclass) AS nextval;


--
-- Name: acs_logs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_logs (
    log_id integer NOT NULL,
    log_date timestamp with time zone DEFAULT now() NOT NULL,
    log_level character varying(20) NOT NULL,
    log_key character varying(100) NOT NULL,
    message text NOT NULL,
    CONSTRAINT acs_logs_log_level_ck CHECK ((((((log_level)::text = ('notice'::character varying)::text) OR ((log_level)::text = ('warn'::character varying)::text)) OR ((log_level)::text = ('error'::character varying)::text)) OR ((log_level)::text = ('debug'::character varying)::text)))
);


--
-- Name: acs_magic_objects; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_magic_objects (
    name character varying(100) NOT NULL,
    object_id integer NOT NULL
);


--
-- Name: TABLE acs_magic_objects; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_magic_objects IS '
 This table allows us to provide semantic names for certain special
 objects like the site-wide organization, and the all users party.
';


--
-- Name: acs_mail_bodies; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_bodies (
    body_id integer NOT NULL,
    body_reply_to integer,
    body_from integer,
    body_date timestamp with time zone,
    header_message_id character varying(1000) NOT NULL,
    header_reply_to character varying(1000),
    header_subject text,
    header_from text,
    header_to text,
    content_item_id integer
);


--
-- Name: acs_mail_body_headers; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_body_headers (
    body_id integer,
    header_name character varying(1000),
    header_content text
);


--
-- Name: acs_mail_gc_objects; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_gc_objects (
    gc_object_id integer NOT NULL
);


--
-- Name: acs_mail_links; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_links (
    mail_link_id integer NOT NULL,
    body_id integer NOT NULL
);


--
-- Name: acs_mail_lite_bounce; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_lite_bounce (
    user_id integer NOT NULL,
    bounce_count integer DEFAULT 1
);


--
-- Name: acs_mail_lite_bounce_notif; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_lite_bounce_notif (
    user_id integer NOT NULL,
    notification_time timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone,
    notification_count integer DEFAULT 0
);


--
-- Name: acs_mail_lite_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE acs_mail_lite_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: acs_mail_lite_mail_log; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_lite_mail_log (
    user_id integer NOT NULL,
    last_mail_date timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone
);


--
-- Name: acs_mail_lite_queue; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_lite_queue (
    message_id integer NOT NULL,
    to_addr character varying(200),
    from_addr character varying(200),
    subject character varying(200),
    body text,
    extra_headers text,
    bcc text,
    package_id integer,
    valid_email_p boolean
);


--
-- Name: acs_mail_multipart_parts; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_multipart_parts (
    multipart_id integer NOT NULL,
    mime_filename character varying(1000),
    mime_disposition character varying(1000),
    sequence_number integer NOT NULL,
    content_item_id integer
);


--
-- Name: acs_mail_multiparts; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_multiparts (
    multipart_id integer NOT NULL,
    multipart_kind character varying(120) NOT NULL
);


--
-- Name: acs_mail_queue_incoming; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_queue_incoming (
    message_id integer NOT NULL,
    envelope_from text,
    envelope_to text
);


--
-- Name: acs_mail_queue_messages; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_queue_messages (
    message_id integer NOT NULL
);


--
-- Name: acs_mail_queue_outgoing; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_mail_queue_outgoing (
    message_id integer NOT NULL,
    envelope_from text,
    envelope_to text NOT NULL
);


--
-- Name: acs_messages; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_messages (
    message_id integer NOT NULL,
    reply_to integer,
    sent_date timestamp without time zone NOT NULL,
    sender integer,
    rfc822_id character varying(250) NOT NULL,
    tree_sortkey bit varying
);


--
-- Name: TABLE acs_messages; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_messages IS '
    A generic message which may be attached to any object in the system.
';


--
-- Name: COLUMN acs_messages.reply_to; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_messages.reply_to IS '
    Pointer to a message this message contains a reply to, for threading.
';


--
-- Name: COLUMN acs_messages.sent_date; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_messages.sent_date IS '
    The date the message was sent (may be distinct from when it was created
    or published in the system.)
';


--
-- Name: COLUMN acs_messages.sender; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_messages.sender IS '
    The person who sent the message (may be distinct from the person who
    entered the message in the system.)
';


--
-- Name: COLUMN acs_messages.rfc822_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_messages.rfc822_id IS '
    The RFC822 message-id of this message, for sending email.
';


--
-- Name: cr_items; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_items (
    item_id integer NOT NULL,
    parent_id integer NOT NULL,
    name character varying(400) NOT NULL,
    locale character varying(4),
    live_revision integer,
    latest_revision integer,
    publish_status character varying(40),
    content_type character varying(100),
    storage_type character varying(10) DEFAULT 'text'::character varying NOT NULL,
    storage_area_key character varying(100) DEFAULT 'CR_FILES'::character varying NOT NULL,
    tree_sortkey bit varying NOT NULL,
    max_child_sortkey bit varying,
    CONSTRAINT cr_items_pub_status_chk CHECK ((((((publish_status)::text = ('production'::character varying)::text) OR ((publish_status)::text = ('ready'::character varying)::text)) OR ((publish_status)::text = ('live'::character varying)::text)) OR ((publish_status)::text = ('expired'::character varying)::text))),
    CONSTRAINT cr_items_storage_type CHECK (((((storage_type)::text = ('lob'::character varying)::text) OR ((storage_type)::text = ('text'::character varying)::text)) OR ((storage_type)::text = ('file'::character varying)::text)))
);


--
-- Name: TABLE cr_items; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_items IS '
  Each content item has a row in this table, as well as a row in
  the acs_objects table.  The parent_id is used to place an
  item in a directory or place it within another container item.
';


--
-- Name: COLUMN cr_items.content_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cr_items.content_type IS '
  The content type constrains the type of revision that may be
  added to this item (an item should have revisions of only one type).
  If null, then no revisions should be allowed.
';


--
-- Name: cr_revisions; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_revisions (
    revision_id integer NOT NULL,
    item_id integer NOT NULL,
    title character varying(1000),
    description text,
    publish_date timestamp with time zone,
    mime_type character varying(200) DEFAULT 'text/plain'::character varying,
    nls_language character varying(50),
    lob integer,
    content text,
    content_length integer
);


--
-- Name: TABLE cr_revisions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_revisions IS '
  Each content item may be associated with any number of revisions.
  The item_id is used to associate revisions with an item.
';


--
-- Name: COLUMN cr_revisions.nls_language; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cr_revisions.nls_language IS '
  NLS_LANGUAGE is required in the same table as the content column
  for multi-lingual searching in Intermedia.
';


--
-- Name: acs_messages_all; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_messages_all AS
    SELECT m.message_id, m.reply_to, m.sent_date, m.sender, m.rfc822_id, m.tree_sortkey, r.revision_id, r.title, r.mime_type, r.content FROM cr_items i, cr_revisions r, acs_messages m WHERE ((i.item_id = m.message_id) AND (r.revision_id = i.live_revision));


--
-- Name: acs_messages_latest; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_messages_latest AS
    SELECT m.message_id, m.reply_to, m.sent_date, m.sender, m.rfc822_id, m.tree_sortkey, r.revision_id, r.title, r.mime_type, r.content FROM cr_items i, cr_revisions r, acs_messages m WHERE ((i.item_id = m.message_id) AND (r.revision_id = content_item__get_latest_revision(i.item_id)));


--
-- Name: acs_messages_outgoing; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_messages_outgoing (
    message_id integer NOT NULL,
    to_address character varying(1000) NOT NULL,
    grouping_id integer,
    wait_until timestamp without time zone NOT NULL
);


--
-- Name: TABLE acs_messages_outgoing; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_messages_outgoing IS '
    Set of messages to be sent to parties.  It is assumed that sending a
    message either queues it in a real MTA or fails, so no information about
    what''s been tried how many times is kept.
';


--
-- Name: COLUMN acs_messages_outgoing.to_address; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_messages_outgoing.to_address IS '
    The email address to send this message to.  Note that this will
    probably become a party_id again once upgrading a party to a user
    is possible.
';


--
-- Name: COLUMN acs_messages_outgoing.grouping_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_messages_outgoing.grouping_id IS '
    This identifier is used to group sets of messages to be sent as
    digests.  When a message is about to be sent, any other messages
    with the same grouping_id will be put together with it in a
    digest.  It is recommended but not required that an object id is
    used.  Bboard, for example, might use the forum id that the user''s
    subscribed to.  For instant (non-digest) updates, it would be
    appropriate to use null, which is never equal to anything else.
';


--
-- Name: COLUMN acs_messages_outgoing.wait_until; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_messages_outgoing.wait_until IS '
    Don''t schedule a send until after this date.  If another message with
    the same grouping ID is scheduled to be sent, then this message may be
    sent at the same time.  (So, for example, daily digests would be
    achieved by setting the grouping_id to the same value, and the wait_until
    value to the end of the current day.  As soon as one message in the group
    is to be sent, all will be sent.)
';


--
-- Name: acs_named_objects; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_named_objects (
    object_id integer NOT NULL,
    object_name character varying(200),
    package_id integer
);


--
-- Name: acs_object_context_index; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_object_context_index (
    object_id integer NOT NULL,
    ancestor_id integer NOT NULL,
    n_generations integer NOT NULL,
    CONSTRAINT acs_obj_context_idx_n_gen_ck CHECK ((n_generations >= 0))
);


--
-- Name: acs_object_contexts; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_object_contexts AS
    SELECT acs_object_context_index.object_id, acs_object_context_index.ancestor_id, acs_object_context_index.n_generations FROM acs_object_context_index WHERE (acs_object_context_index.object_id <> acs_object_context_index.ancestor_id);


--
-- Name: acs_object_paths; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_object_paths AS
    SELECT acs_object_context_index.object_id, acs_object_context_index.ancestor_id, acs_object_context_index.n_generations FROM acs_object_context_index;


--
-- Name: acs_permissions; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_permissions (
    object_id integer NOT NULL,
    grantee_id integer NOT NULL,
    privilege character varying(100) NOT NULL
);


--
-- Name: acs_permissions_all; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_permissions_all AS
    SELECT op.object_id, p.grantee_id, p.privilege FROM acs_object_paths op, acs_permissions p WHERE (op.ancestor_id = p.object_id);


--
-- Name: acs_privilege_descendant_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_privilege_descendant_map (
    privilege character varying(100) NOT NULL,
    descendant character varying(100) NOT NULL
);


--
-- Name: acs_object_grantee_priv_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_object_grantee_priv_map AS
    SELECT a.object_id, a.grantee_id, m.descendant AS privilege FROM acs_permissions_all a, acs_privilege_descendant_map m WHERE ((a.privilege)::text = (m.privilege)::text);


--
-- Name: acs_object_id_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_object_id_seq AS
    SELECT nextval(('t_acs_object_id_seq'::text)::regclass) AS nextval;


--
-- Name: party_approved_member_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE party_approved_member_map (
    party_id integer NOT NULL,
    member_id integer NOT NULL,
    tag integer NOT NULL
);


--
-- Name: acs_object_party_privilege_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_object_party_privilege_map AS
    SELECT c.object_id, pdm.descendant AS privilege, pamm.member_id AS party_id FROM acs_object_context_index c, acs_permissions p, acs_privilege_descendant_map pdm, party_approved_member_map pamm WHERE (((c.ancestor_id = p.object_id) AND ((pdm.privilege)::text = (p.privilege)::text)) AND (pamm.party_id = p.grantee_id));


--
-- Name: acs_object_type_supertype_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_object_type_supertype_map AS
    SELECT ot1.object_type, ot2.object_type AS ancestor_type FROM acs_object_types ot1, acs_object_types ot2 WHERE (((ot1.object_type)::text <> (ot2.object_type)::text) AND ((ot1.tree_sortkey >= ot2.tree_sortkey) AND (ot1.tree_sortkey <= tree_right(ot2.tree_sortkey))));


--
-- Name: acs_object_type_attributes; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_object_type_attributes AS
    SELECT all_types.object_type, all_types.ancestor_type, attr.attribute_id, attr.table_name, attr.attribute_name, attr.pretty_name, attr.pretty_plural, attr.sort_order, attr.datatype, attr.default_value, attr.min_n_values, attr.max_n_values, attr.storage, attr.static_p, attr.column_name FROM acs_attributes attr, (SELECT map.object_type, map.ancestor_type FROM acs_object_type_supertype_map map, acs_object_types t WHERE ((map.object_type)::text = (t.object_type)::text) UNION ALL SELECT t.object_type, t.object_type AS ancestor_type FROM acs_object_types t) all_types WHERE ((attr.object_type)::text = (all_types.ancestor_type)::text);


--
-- Name: acs_object_type_tables; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_object_type_tables (
    object_type character varying(100) NOT NULL,
    table_name character varying(30) NOT NULL,
    id_column character varying(30)
);


--
-- Name: TABLE acs_object_type_tables; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_object_type_tables IS '
 This table is used for objects that want to vertically partition
 their data storage, for example user_demographics stores a set of
 optional columns that belong to a user object.
';


--
-- Name: COLUMN acs_object_type_tables.id_column; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_object_type_tables.id_column IS '
 If this is null then the id column is assumed to have the same name
 as the primary table.
';


--
-- Name: acs_objects; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_objects (
    object_id integer NOT NULL,
    object_type character varying(100) NOT NULL,
    context_id integer,
    security_inherit_p boolean DEFAULT true NOT NULL,
    creation_user integer,
    creation_date timestamp with time zone DEFAULT now() NOT NULL,
    creation_ip character varying(50),
    last_modified timestamp with time zone DEFAULT now() NOT NULL,
    modifying_user integer,
    modifying_ip character varying(50),
    tree_sortkey bit varying NOT NULL,
    max_child_sortkey bit varying,
    title character varying(1000),
    package_id integer
);


--
-- Name: TABLE acs_objects; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_objects IS '
';


--
-- Name: COLUMN acs_objects.context_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_objects.context_id IS '
 The context_id column points to an object that provides a context for
 this object. Often this will reflect an observed hierarchy in a site,
 for example a bboard message would probably list a bboard topic as
 it''s context, and a bboard topic might list a sub-site as it''s
 context. Whenever we ask a question of the form "can user X perform
 action Y on object Z", the acs security model will defer to an
 object''s context if there is no information about user X''s
 permission to perform action Y on object Z.
';


--
-- Name: COLUMN acs_objects.creation_user; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_objects.creation_user IS '
 Who created the object; may be null since objects can be created by
 automated processes
';


--
-- Name: COLUMN acs_objects.modifying_user; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_objects.modifying_user IS '
 Who last modified the object
';


--
-- Name: COLUMN acs_objects.title; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_objects.title IS '
 Title of the object if applicable.
 Please note that in mid-term this column will replace all
 titles or object_names of package specific tables.
';


--
-- Name: COLUMN acs_objects.package_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN acs_objects.package_id IS '
 Which package instance this object belongs to.
 Please note that in mid-term this column will replace all
 package_ids of package specific tables.
';


--
-- Name: acs_permissions_lock; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_permissions_lock (
    lck integer
);


--
-- Name: acs_privilege_hierarchy_index; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_privilege_hierarchy_index (
    privilege character varying(100) NOT NULL,
    child_privilege character varying(100) NOT NULL,
    tree_sortkey bit varying
);


--
-- Name: acs_privileges; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_privileges (
    privilege character varying(100) NOT NULL,
    pretty_name character varying(100),
    pretty_plural character varying(100)
);


--
-- Name: TABLE acs_privileges; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_privileges IS '
 The rows in this table correspond to aggregations of specific
 methods. Privileges share a global namespace. This is to avoid a
 situation where granting the foo privilege on one type of object can
 have an entirely different meaning than granting the foo privilege on
 another type of object.
';


--
-- Name: acs_privilege_descendant_map_view; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_privilege_descendant_map_view AS
    (SELECT DISTINCT h1.privilege, h2.child_privilege AS descendant FROM acs_privilege_hierarchy_index h1, acs_privilege_hierarchy_index h2 WHERE ((h2.tree_sortkey >= h1.tree_sortkey) AND (h2.tree_sortkey <= tree_right(h1.tree_sortkey))) ORDER BY h1.privilege, h2.child_privilege) UNION SELECT acs_privileges.privilege, acs_privileges.privilege AS descendant FROM acs_privileges;


--
-- Name: acs_privilege_hierarchy; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_privilege_hierarchy (
    privilege character varying(100) NOT NULL,
    child_privilege character varying(100) NOT NULL
);


--
-- Name: TABLE acs_privilege_hierarchy; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_privilege_hierarchy IS '
 The acs_privilege_hierarchy gives us an easy way to say: The foo
 privilege is a superset of the bar privilege.
';


--
-- Name: acs_reference_repositories; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_reference_repositories (
    repository_id integer NOT NULL,
    table_name character varying(100) NOT NULL,
    internal_data_p boolean,
    package_name character varying(100),
    last_update timestamp with time zone,
    source character varying(1000),
    source_url character varying(255),
    effective_date timestamp with time zone,
    expiry_date timestamp with time zone,
    maintainer_id integer,
    lob integer
);


--
-- Name: acs_rel_id_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_rel_id_seq AS
    SELECT nextval(('t_acs_rel_id_seq'::text)::regclass) AS nextval;


--
-- Name: acs_rel_roles; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_rel_roles (
    role character varying(100) NOT NULL,
    pretty_name character varying(100) NOT NULL,
    pretty_plural character varying(100) NOT NULL
);


--
-- Name: acs_rel_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_rel_types (
    rel_type character varying(100) NOT NULL,
    object_type_one character varying(100) NOT NULL,
    role_one character varying(100),
    min_n_rels_one integer DEFAULT 0 NOT NULL,
    max_n_rels_one integer,
    object_type_two character varying(100) NOT NULL,
    role_two character varying(100),
    min_n_rels_two integer DEFAULT 0 NOT NULL,
    max_n_rels_two integer,
    CONSTRAINT acs_rel_types_max_n_1_ck CHECK ((max_n_rels_one >= 0)),
    CONSTRAINT acs_rel_types_max_n_2_ck CHECK ((max_n_rels_two >= 0)),
    CONSTRAINT acs_rel_types_min_n_1_ck CHECK ((min_n_rels_one >= 0)),
    CONSTRAINT acs_rel_types_min_n_2_ck CHECK ((min_n_rels_two >= 0)),
    CONSTRAINT acs_rel_types_n_rels_one_ck CHECK ((min_n_rels_one <= max_n_rels_one)),
    CONSTRAINT acs_rel_types_n_rels_two_ck CHECK ((min_n_rels_two <= max_n_rels_two))
);


--
-- Name: TABLE acs_rel_types; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_rel_types IS '
 Each row in <code>acs_rel_types</code> represents a type of
 relationship between objects. For example, the following DML
 statement:
 <blockquote><pre>
 insert into acs_rel_types
  (rel_type,
   object_type_one, role_one, min_n_rels_one, max_n_rels_one,
   object_type_two, role_two, min_n_rels_two, max_n_rels_two)
 values
  (''employment'',
   ''person'', ''employee'', 0, null,
   ''company'', ''employer'', 0, null)
 </pre></blockquote>
 defines an "employment" relationship type that can be expressed in
 in natural language as:
 <blockquote>
 A person may be the employee of zero or more companies, and a company
 may be the employer of zero or more people.
 </blockquote>
';


--
-- Name: acs_rels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_rels (
    rel_id integer NOT NULL,
    rel_type character varying(100) NOT NULL,
    object_id_one integer NOT NULL,
    object_id_two integer NOT NULL
);


--
-- Name: TABLE acs_rels; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_rels IS '
 The acs_rels table is essentially a generic mapping table for
 acs_objects. Once we come up with a way to associate attributes with
 relationship types, we could replace many of the ACS 3.x mapping
 tables like user_content_map, user_group_map, and
 user_group_type_modules_map with this one table. Much application
 logic consists of asking questions like "Does object X have a
 relationship of type Y to object Z?" where all that differs is
 X, Y, and Z. Thus, the value of consolidating many mapping tables
 into one is that we can provide a generic API for defining and
 querying relationships. In addition, we may need to design a way to
 enable "type_specific" storage for relationships (i.e., foreign key
 columns for one-to-many relationships and custom mapping tables for
 many-to-many relationships), instead of only supporting "generic"
 storage in the acs_rels table. This would parallel what we do with
 acs_attributes.
';


--
-- Name: acs_sc_bindings; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_sc_bindings (
    contract_id integer,
    impl_id integer
);


--
-- Name: acs_sc_contracts; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_sc_contracts (
    contract_id integer NOT NULL,
    contract_name character varying(1000) NOT NULL,
    contract_desc text NOT NULL
);


--
-- Name: acs_sc_impl_aliases; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_sc_impl_aliases (
    impl_id integer,
    impl_name character varying(100),
    impl_contract_name character varying(1000),
    impl_operation_name character varying(100),
    impl_alias character varying(100),
    impl_pl character varying(100)
);


--
-- Name: acs_sc_impls; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_sc_impls (
    impl_id integer NOT NULL,
    impl_name character varying(100),
    impl_owner_name character varying(1000),
    impl_contract_name character varying(1000),
    impl_pretty_name character varying(200)
);


--
-- Name: acs_sc_msg_type_elements; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_sc_msg_type_elements (
    msg_type_id integer,
    element_name character varying(100),
    element_msg_type_id integer,
    element_msg_type_isset_p boolean,
    element_pos integer
);


--
-- Name: acs_sc_msg_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_sc_msg_types (
    msg_type_id integer NOT NULL,
    msg_type_name character varying(100)
);


--
-- Name: acs_sc_operations; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_sc_operations (
    contract_id integer,
    operation_id integer NOT NULL,
    contract_name character varying(1000),
    operation_name character varying(100),
    operation_desc text NOT NULL,
    operation_iscachable_p boolean,
    operation_nargs integer,
    operation_inputtype_id integer,
    operation_outputtype_id integer
);


--
-- Name: acs_static_attr_values; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE acs_static_attr_values (
    object_type character varying(100) NOT NULL,
    attribute_id integer NOT NULL,
    attr_value text
);


--
-- Name: TABLE acs_static_attr_values; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE acs_static_attr_values IS '
  Stores static values for the object attributes. One row per object
  type.
';


--
-- Name: persons; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE persons (
    person_id integer NOT NULL,
    first_names character varying(100) NOT NULL,
    last_name character varying(100) NOT NULL
);


--
-- Name: TABLE persons; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE persons IS '
 Need to handle titles like Mr., Ms., Mrs., Dr., etc. and suffixes
 like M.D., Ph.D., Jr., Sr., III, IV, etc.
';


--
-- Name: acs_users_all; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW acs_users_all AS
    SELECT pa.party_id, pa.email, pa.url, pe.person_id, pe.first_names, pe.last_name, u.user_id, u.password, u.salt, u.screen_name, u.priv_name, u.priv_email, u.email_verified_p, u.email_bouncing_p, u.no_alerts_until, u.last_visit, u.second_to_last_visit, u.n_sessions, u.password_question, u.password_answer, u.password_changed_date, u.authority_id, u.username, u.auth_token FROM parties pa, persons pe, users u WHERE ((pa.party_id = pe.person_id) AND (pe.person_id = u.user_id));


--
-- Name: ad_locale_user_prefs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ad_locale_user_prefs (
    user_id integer,
    package_id integer,
    locale character varying(30) NOT NULL
);


--
-- Name: ad_locales; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ad_locales (
    locale character varying(30) NOT NULL,
    language character(2) NOT NULL,
    country character(2) NOT NULL,
    variant character varying(30),
    label character varying(200) NOT NULL,
    nls_language character varying(30) NOT NULL,
    nls_territory character varying(30),
    nls_charset character varying(30),
    mime_charset character varying(30),
    default_p boolean DEFAULT false,
    enabled_p boolean DEFAULT true
);


--
-- Name: TABLE ad_locales; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE ad_locales IS '
  An OpenACS locale is identified by a language and country.
  Locale definitions in Oracle consist of a language, and optionally
  territory and character set.  (Languages are associated with default
  territories and character sets when not defined).  The formats
  for numbers, currency, dates, etc. are determined by the territory.
  language is two letter abbrev is ISO 639 language code
  country is two letter abbrev is ISO 3166 country code
  mime_charset is IANA charset name
  nls_charset is  Oracle charset name
';


--
-- Name: ad_template_sample_users; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ad_template_sample_users (
    user_id integer NOT NULL,
    first_name character varying(20),
    last_name character varying(20),
    address1 character varying(40),
    address2 character varying(40),
    city character varying(40),
    state character varying(2)
);


--
-- Name: ad_template_sample_users_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE ad_template_sample_users_seq
    START WITH 5
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: ad_template_sample_users_sequence; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ad_template_sample_users_sequence AS
    SELECT nextval(('ad_template_sample_users_seq'::text)::regclass) AS nextval;


--
-- Name: admin_rels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE admin_rels (
    rel_id integer NOT NULL
);


--
-- Name: all_object_party_privilege_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW all_object_party_privilege_map AS
    SELECT acs_object_party_privilege_map.object_id, acs_object_party_privilege_map.privilege, acs_object_party_privilege_map.party_id FROM acs_object_party_privilege_map;


--
-- Name: am_meeting; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE am_meeting (
    meeting_id integer NOT NULL,
    type_id integer NOT NULL,
    meeting_date timestamp with time zone NOT NULL
);


--
-- Name: am_meeting_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE am_meeting_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: am_meeting_todo; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE am_meeting_todo (
    todo_id integer NOT NULL,
    meeting_id integer,
    description character varying(200) NOT NULL,
    assignee integer NOT NULL,
    completed_p character(1) DEFAULT 'f'::bpchar,
    completion_note text,
    CONSTRAINT am_meeting_completed_p_ck CHECK (((completed_p = 't'::bpchar) OR (completed_p = 'f'::bpchar)))
);


--
-- Name: am_meeting_todo_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE am_meeting_todo_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: am_meeting_type; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE am_meeting_type (
    type_id integer NOT NULL,
    title character varying(100) NOT NULL
);


--
-- Name: am_meeting_type_participants; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE am_meeting_type_participants (
    type_id integer NOT NULL,
    user_id integer NOT NULL
);


--
-- Name: am_meeting_type_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE am_meeting_type_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: anon_func_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW anon_func_seq AS
    SELECT nextval(('t_anon_func_seq'::text)::regclass) AS nextval;


--
-- Name: apm_applications; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_applications (
    application_id integer NOT NULL
);


--
-- Name: TABLE apm_applications; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_applications IS '
This table records data on all of the applications registered in OpenACS.
';


--
-- Name: apm_package_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_package_types (
    package_key character varying(100) NOT NULL,
    pretty_name character varying(100) NOT NULL,
    pretty_plural character varying(100),
    package_uri character varying(1500) NOT NULL,
    package_type character varying(300),
    spec_file_path character varying(1500),
    spec_file_mtime integer,
    initial_install_p boolean DEFAULT false NOT NULL,
    singleton_p boolean DEFAULT false NOT NULL,
    CONSTRAINT apm_packages_pack_type_ck CHECK ((((package_type)::text = ('apm_application'::character varying)::text) OR ((package_type)::text = ('apm_service'::character varying)::text)))
);


--
-- Name: TABLE apm_package_types; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_package_types IS '
 This table holds additional knowledge level attributes for the
 apm_package type and its subtypes.
';


--
-- Name: COLUMN apm_package_types.package_key; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_types.package_key IS '
 The package_key is what we call the package on this system.
';


--
-- Name: COLUMN apm_package_types.package_uri; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_types.package_uri IS '
 The package URI indicates where the package can be downloaded and 
 is a unique identifier for the package.
';


--
-- Name: COLUMN apm_package_types.spec_file_path; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_types.spec_file_path IS '
 The path to the package specification file.
';


--
-- Name: COLUMN apm_package_types.spec_file_mtime; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_types.spec_file_mtime IS '
 The last time a spec file was modified.  This information is maintained in the 
database so that if a user changes the specification file by editing the file
(as opposed to using the UI, the system can read the .info file and update
the information in the database appropriately.
';


--
-- Name: COLUMN apm_package_types.initial_install_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_types.initial_install_p IS '
 Indicates if the package should be installed during initial installation,
 in other words whether or not this package is part of the OpenACS core.
';


--
-- Name: COLUMN apm_package_types.singleton_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_types.singleton_p IS '
 Indicates if the package can be used for subsites.  If this is set to 
 ''t'', the package can be enabled for any subsite.  Otherwise, it is 
 restricted to the acs-admin/ subsite.
';


--
-- Name: apm_package_versions; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_package_versions (
    version_id integer NOT NULL,
    package_key character varying(100) NOT NULL,
    version_name character varying(100) NOT NULL,
    version_uri character varying(1500) NOT NULL,
    summary character varying(3000),
    description_format character varying(100),
    description text,
    release_date timestamp with time zone,
    vendor character varying(500),
    vendor_uri character varying(1500),
    enabled_p boolean DEFAULT false NOT NULL,
    installed_p boolean DEFAULT false NOT NULL,
    tagged_p boolean DEFAULT false NOT NULL,
    imported_p boolean DEFAULT false NOT NULL,
    data_model_loaded_p boolean DEFAULT false NOT NULL,
    cvs_import_results text,
    activation_date timestamp with time zone,
    deactivation_date timestamp with time zone,
    item_id integer,
    content_length integer,
    distribution_uri character varying(1500),
    distribution_date timestamp with time zone,
    auto_mount character varying(50),
    CONSTRAINT apm_package_vers_desc_for_ck CHECK ((((description_format)::text = ('text/html'::character varying)::text) OR ((description_format)::text = ('text/plain'::character varying)::text)))
);


--
-- Name: TABLE apm_package_versions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_package_versions IS '
 The table apm_package_versions contains one row for each version of each package
 we know about, e.g., acs-kernel-3.3, acs-kernel-3.3.1, bboard-1.0,
 bboard-1.0.1, etc.
';


--
-- Name: COLUMN apm_package_versions.version_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.version_name IS '
A version number consists of: 
   1.A major version number. 
   2.Optionally, up to three minor version numbers. 
   3.One of the following: 
         The letter d, indicating a development-only version.
         The letter a, indicating an alpha release.
         The letter b, indicating a beta release. 
         No letter at all, indicating a final release.
In addition, the letters d, a, and b may be followed by another integer, indicating a version within the release. 
For those who like regular expressions: 
     version_number := integer (''.'' integer){0,3} ((''d''|''a''|''b'') integer?)?
So the following is a valid progression for version numbers: 
     0.9d, 0.9d1, 0.9a1, 0.9b1, 0.9b2, 0.9, 1.0, 1.0.1, 1.1b1, 1.1
';


--
-- Name: COLUMN apm_package_versions.version_uri; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.version_uri IS '
  This column should uniquely identify a package version.  This URI should in practice be a URL at which this specific
version can be downloaded.  
';


--
-- Name: COLUMN apm_package_versions.summary; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.summary IS '
Type a brief, one-sentence-or-less summary of the functionality of 
your package.  The summary should begin with a capital letter 
and end with a period. 
XXX (bquinn): Move to Content Repository?
';


--
-- Name: COLUMN apm_package_versions.description_format; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.description_format IS '
 Must indicate whether the description is plain text or HTML.
';


--
-- Name: COLUMN apm_package_versions.description; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.description IS '
Type a one-paragraph description of your package. This is probably analogous 
to the first paragraph in your package''s documentation.  This is used to describe
the system to users considering installing it.
';


--
-- Name: COLUMN apm_package_versions.release_date; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.release_date IS '
This tracks when the package was released. Releasing a package means
freezing the code and files, creating an archive, and making the
package available for donwload. XXX (bquinn): I''m skeptical about the
usefulness of storing this information here.
';


--
-- Name: COLUMN apm_package_versions.vendor; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.vendor IS '
If the package is being released by a company or some kind of organization, 
its name should go here.
';


--
-- Name: COLUMN apm_package_versions.vendor_uri; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.vendor_uri IS '
This should be a URL pointing to the vendor.
';


--
-- Name: COLUMN apm_package_versions.enabled_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.enabled_p IS '
 Is the version scheduled to be loaded at startup?
';


--
-- Name: COLUMN apm_package_versions.installed_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.installed_p IS '
 Is the version actually present in the filesystem?
';


--
-- Name: COLUMN apm_package_versions.tagged_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.tagged_p IS '
 Have we ever assigned all the files in this version a CVS tag.
 XXX (bquinn): deprecated.  CVS management should not be through
 this table.
';


--
-- Name: COLUMN apm_package_versions.imported_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.imported_p IS '
 Did we perform a vendor import on this version?
 XXX (bquinn): deprecated.  CVS management should not be through
 this table.
';


--
-- Name: COLUMN apm_package_versions.data_model_loaded_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.data_model_loaded_p IS '
 Have we brought the data model up to date for this version.
 XXX (bquinn): deprecated.  Its not useful to track this information.
';


--
-- Name: COLUMN apm_package_versions.cvs_import_results; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.cvs_import_results IS '
 Store the results of an attempted CVS import.
 XXX (bquinn): deprecated.  CVS management should not be through
 this table.
';


--
-- Name: COLUMN apm_package_versions.activation_date; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.activation_date IS '
 When was the version last enabled?
 XXX (bquinn): do we really care about this enough to keep the information around?
';


--
-- Name: COLUMN apm_package_versions.deactivation_date; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.deactivation_date IS '
 When was the version last disabled?
 XXX (bquinn): do we really care about this enough to keep the information around?
';


--
-- Name: COLUMN apm_package_versions.item_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.item_id IS '
 item_id is a reference to the distribution_tarball which is stored in the content
 repository.
';


--
-- Name: COLUMN apm_package_versions.distribution_uri; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.distribution_uri IS '
 Where was the distribution tarball downloaded from.
';


--
-- Name: COLUMN apm_package_versions.distribution_date; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.distribution_date IS '
 When was the distribution tarball downloaded.
';


--
-- Name: COLUMN apm_package_versions.auto_mount; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_versions.auto_mount IS '
 A dir under the main site site node where an instance of the package will be mounted
 automatically upon installation. Useful for site-wide services that need mounting
 such as general-comments and notifications.
';


--
-- Name: apm_package_version_info; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW apm_package_version_info AS
    SELECT v.package_key, t.package_uri, t.pretty_name, t.singleton_p, t.initial_install_p, v.version_id, v.version_name, v.version_uri, v.summary, v.description_format, v.description, v.release_date, v.vendor, v.vendor_uri, v.auto_mount, v.enabled_p, v.installed_p, v.tagged_p, v.imported_p, v.data_model_loaded_p, v.activation_date, v.deactivation_date, CASE WHEN (v.content_length IS NOT NULL) THEN v.content_length WHEN (0 IS NOT NULL) THEN 0 ELSE NULL::integer END AS tarball_length, v.distribution_uri, v.distribution_date FROM apm_package_types t, apm_package_versions v WHERE ((v.package_key)::text = (t.package_key)::text);


--
-- Name: apm_enabled_package_versions; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW apm_enabled_package_versions AS
    SELECT apm_package_version_info.package_key, apm_package_version_info.package_uri, apm_package_version_info.pretty_name, apm_package_version_info.singleton_p, apm_package_version_info.initial_install_p, apm_package_version_info.version_id, apm_package_version_info.version_name, apm_package_version_info.version_uri, apm_package_version_info.summary, apm_package_version_info.description_format, apm_package_version_info.description, apm_package_version_info.release_date, apm_package_version_info.vendor, apm_package_version_info.vendor_uri, apm_package_version_info.auto_mount, apm_package_version_info.enabled_p, apm_package_version_info.installed_p, apm_package_version_info.tagged_p, apm_package_version_info.imported_p, apm_package_version_info.data_model_loaded_p, apm_package_version_info.activation_date, apm_package_version_info.deactivation_date, apm_package_version_info.tarball_length, apm_package_version_info.distribution_uri, apm_package_version_info.distribution_date FROM apm_package_version_info WHERE (apm_package_version_info.enabled_p = true);


--
-- Name: apm_package_callbacks; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_package_callbacks (
    version_id integer,
    type character varying(40),
    proc character varying(300)
);


--
-- Name: TABLE apm_package_callbacks; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_package_callbacks IS '
  This table holds names of Tcl procedures to invoke at the time (before or after) the package is
  installed, instantiated, or mounted.        
';


--
-- Name: COLUMN apm_package_callbacks.type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_callbacks.type IS '
  Indicates when the callback proc should be invoked, for example after-install. Valid
  values are given by the Tcl proc apm_supported_callback_types.
';


--
-- Name: COLUMN apm_package_callbacks.proc; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_callbacks.proc IS '
  Name of the Tcl proc.
';


--
-- Name: apm_package_db_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_package_db_types (
    db_type_key character varying(50) NOT NULL,
    pretty_db_name character varying(200) NOT NULL
);


--
-- Name: TABLE apm_package_db_types; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_package_db_types IS '
  A list of all the different kinds of database engines that an APM package can
  support.  This table is initialized in acs-tcl/tcl/apm-init.tcl rather than in
  PL/SQL in order to guarantee that the list of supported database engines is
  consistent between the bootstrap code and the package manager.
';


--
-- Name: apm_package_dependencies; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_package_dependencies (
    dependency_id integer NOT NULL,
    version_id integer NOT NULL,
    dependency_type character varying(20) NOT NULL,
    service_uri character varying(1500) NOT NULL,
    service_version character varying(100) NOT NULL,
    CONSTRAINT apm_package_deps_type_ck CHECK ((((dependency_type)::text = ('provides'::character varying)::text) OR ((dependency_type)::text = ('requires'::character varying)::text)))
);


--
-- Name: TABLE apm_package_dependencies; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_package_dependencies IS '
 This table indicates what services are provided or required by a particular version.
';


--
-- Name: COLUMN apm_package_dependencies.service_version; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_package_dependencies.service_version IS '
 The restrictions on service version should match those on apm_package_versions.version_name.
';


--
-- Name: apm_package_owners; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_package_owners (
    version_id integer,
    owner_uri character varying(1500),
    owner_name character varying(200) NOT NULL,
    sort_key integer
);


--
-- Name: TABLE apm_package_owners; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_package_owners IS '
 This table tracks all of the owners of a particular package, and their email information.  The sort_key column
 manages the order of the authors.
';


--
-- Name: apm_package_version_attr; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_package_version_attr (
    version_id integer NOT NULL,
    attribute_name character varying(100) NOT NULL,
    attribute_value character varying(4000)
);


--
-- Name: apm_packages; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_packages (
    package_id integer NOT NULL,
    package_key character varying(100),
    instance_name character varying(300) NOT NULL,
    default_locale character varying(30)
);


--
-- Name: TABLE apm_packages; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_packages IS '
   This table maintains the list of all package instances in the sytem. 
';


--
-- Name: COLUMN apm_packages.instance_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_packages.instance_name IS '
   This column enables a name to associated with each instance of package.  This enables the storage
of a human-readable distinction between different package instances.  This is useful
if a site admin wishes to name an instance of an application, e.g. bboard, for a subsite.  The admin
might create one instance, "Boston Public Bboard" for managing public forums for the Boston subsite,
and "Boston Private Bboard" for managing private forums for the Boston subsite.
';


--
-- Name: apm_parameter_values; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_parameter_values (
    value_id integer NOT NULL,
    package_id integer,
    parameter_id integer,
    attr_value text
);


--
-- Name: TABLE apm_parameter_values; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_parameter_values IS '
 This table holds the values of parameters for package instances.
';


--
-- Name: COLUMN apm_parameter_values.attr_value; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_parameter_values.attr_value IS '
 This column holds the value for the instance parameter.
';


--
-- Name: apm_parameters; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_parameters (
    parameter_id integer NOT NULL,
    package_key character varying(100) NOT NULL,
    parameter_name character varying(100) NOT NULL,
    description character varying(2000),
    section_name character varying(200),
    datatype character varying(100) NOT NULL,
    default_value text,
    min_n_values integer DEFAULT 1 NOT NULL,
    max_n_values integer DEFAULT 1 NOT NULL,
    CONSTRAINT apm_parameter_datatype_ck CHECK ((((datatype)::text = ('number'::character varying)::text) OR ((datatype)::text = ('string'::character varying)::text))),
    CONSTRAINT apm_paramters_max_n_ck CHECK ((max_n_values >= 0)),
    CONSTRAINT apm_paramters_min_n_ck CHECK ((min_n_values >= 0)),
    CONSTRAINT apm_paramters_n_values_ck CHECK ((min_n_values <= max_n_values))
);


--
-- Name: TABLE apm_parameters; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_parameters IS '
  This table stores information about parameters on packages.  Every package parameter
is specific to a particular package instance and is queryable with the Tcl call 
ad_parameter.
';


--
-- Name: COLUMN apm_parameters.parameter_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_parameters.parameter_name IS '
  This is the name of the parameter, for example "DebugP."
';


--
-- Name: COLUMN apm_parameters.description; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_parameters.description IS '
  A human readable description of what the parameter is used for.
';


--
-- Name: COLUMN apm_parameters.datatype; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_parameters.datatype IS '
 Acceptable datatypes for parameters.  Currently only numbers and strings.
 XXX (bquinn): Integrate with acs objects metadata system.  It is not 
 currently so integrated because of fluctuations with the general 
 storage mechanism during development.
';


--
-- Name: COLUMN apm_parameters.default_value; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_parameters.default_value IS '
  The default value that any package instance will inherit unless otherwise
  specified. 
';


--
-- Name: COLUMN apm_parameters.min_n_values; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_parameters.min_n_values IS '
  The minimum number of values that this parameter can take.  Zero values means
  that the default is always enforced (but is somewhat pointless).  One value means that
  it can only be set to one value.  Increasing this number beyond one enables associating 
  a list of values with a parameter.  
  XXX (bquinn): More than one value is not supported by ad_parameter call at this time.
';


--
-- Name: COLUMN apm_parameters.max_n_values; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN apm_parameters.max_n_values IS '
The maximum number of values that any attribute with this datatype
 can have. 
';


--
-- Name: apm_services; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE apm_services (
    service_id integer NOT NULL
);


--
-- Name: TABLE apm_services; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE apm_services IS '
This table records data on all of the services registered in OpenACS. 
';


--
-- Name: application_groups; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE application_groups (
    group_id integer NOT NULL,
    package_id integer
);


--
-- Name: application_group_element_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW application_group_element_map AS
    SELECT g.package_id, g.group_id, m.element_id, m.container_id, m.rel_id, m.rel_type, m.ancestor_rel_type FROM application_groups g, group_element_map m WHERE (g.group_id = m.group_id);


--
-- Name: app_group_distinct_element_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW app_group_distinct_element_map AS
    SELECT DISTINCT application_group_element_map.package_id, application_group_element_map.group_id, application_group_element_map.element_id FROM application_group_element_map ORDER BY application_group_element_map.package_id, application_group_element_map.group_id, application_group_element_map.element_id;


--
-- Name: app_group_distinct_rel_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW app_group_distinct_rel_map AS
    SELECT DISTINCT application_group_element_map.package_id, application_group_element_map.group_id, application_group_element_map.rel_id, application_group_element_map.rel_type, application_group_element_map.ancestor_rel_type FROM application_group_element_map ORDER BY application_group_element_map.package_id, application_group_element_map.group_id, application_group_element_map.rel_id, application_group_element_map.rel_type, application_group_element_map.ancestor_rel_type;


--
-- Name: application_group_segments; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW application_group_segments AS
    SELECT g.package_id, s.segment_id, s.group_id, s.rel_type, s.segment_name FROM application_groups g, group_element_map m, rel_segments s WHERE ((g.group_id = m.group_id) AND (m.element_id = s.group_id)) UNION ALL SELECT g.package_id, s.segment_id, s.group_id, s.rel_type, s.segment_name FROM application_groups g, rel_segments s WHERE (g.group_id = s.group_id);


--
-- Name: attachments; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE attachments (
    object_id integer NOT NULL,
    item_id integer NOT NULL,
    approved_p character(1) DEFAULT 't'::bpchar NOT NULL,
    CONSTRAINT attachments_approved_p_ck CHECK (((approved_p = 't'::bpchar) OR (approved_p = 'f'::bpchar)))
);


--
-- Name: attachments_fs_root_folder_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE attachments_fs_root_folder_map (
    package_id integer NOT NULL,
    folder_id integer NOT NULL
);


--
-- Name: auth_authorities; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE auth_authorities (
    authority_id integer NOT NULL,
    short_name character varying(255),
    pretty_name character varying(4000),
    help_contact_text character varying(4000),
    help_contact_text_format character varying(200),
    enabled_p boolean DEFAULT true NOT NULL,
    sort_order integer NOT NULL,
    auth_impl_id integer,
    pwd_impl_id integer,
    forgotten_pwd_url character varying(4000),
    change_pwd_url character varying(4000),
    register_impl_id integer,
    register_url character varying(4000),
    user_info_impl_id integer,
    get_doc_impl_id integer,
    process_doc_impl_id integer,
    batch_sync_enabled_p boolean DEFAULT false NOT NULL
);


--
-- Name: COLUMN auth_authorities.help_contact_text; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN auth_authorities.help_contact_text IS '
    Contact information (phone, email, etc.) to be displayed
    as a last resort when people are having problems with an authority.
';


--
-- Name: COLUMN auth_authorities.forgotten_pwd_url; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN auth_authorities.forgotten_pwd_url IS '
    Any username in this url must be on the syntax foo={username}
    and {username} will be replaced with the real username
';


--
-- Name: COLUMN auth_authorities.change_pwd_url; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN auth_authorities.change_pwd_url IS '
    Any username in this url must be on the syntax foo={username}
    and {username} will be replaced with the real username
';


--
-- Name: auth_batch_job_entries; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE auth_batch_job_entries (
    entry_id integer NOT NULL,
    job_id integer,
    entry_time timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone,
    operation character varying(100),
    username character varying(100),
    user_id integer,
    success_p boolean NOT NULL,
    message text,
    element_messages text,
    CONSTRAINT auth_batch_jobs_entries_op_ck CHECK (((((operation)::text = 'insert'::text) OR ((operation)::text = 'update'::text)) OR ((operation)::text = 'delete'::text)))
);


--
-- Name: auth_batch_job_entry_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE auth_batch_job_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: auth_batch_jobs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE auth_batch_jobs (
    job_id integer NOT NULL,
    job_start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone,
    job_end_time timestamp with time zone,
    interactive_p boolean NOT NULL,
    snapshot_p boolean,
    authority_id integer,
    message text,
    creation_user integer,
    doc_start_time timestamp with time zone,
    doc_end_time timestamp with time zone,
    doc_status text,
    doc_message text,
    document text
);


--
-- Name: auth_batch_jobs_job_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE auth_batch_jobs_job_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: auth_driver_params; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE auth_driver_params (
    authority_id integer NOT NULL,
    impl_id integer NOT NULL,
    key character varying(200) NOT NULL,
    value text
);


--
-- Name: cal_item_type_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE cal_item_type_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: cal_item_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cal_item_types (
    item_type_id integer NOT NULL,
    calendar_id integer NOT NULL,
    type character varying(100) NOT NULL
);


--
-- Name: cal_items; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cal_items (
    cal_item_id integer NOT NULL,
    on_which_calendar integer,
    item_type_id integer
);


--
-- Name: TABLE cal_items; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cal_items IS '
        Table cal_items maps the ownership relation between 
        an cal_item_id to calendars. Each cal_item is owned
        by a calendar
';


--
-- Name: COLUMN cal_items.cal_item_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cal_items.cal_item_id IS '
        Primary Key
';


--
-- Name: COLUMN cal_items.on_which_calendar; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cal_items.on_which_calendar IS '
        Mapping to calendar. Each cal_item is owned
        by a calendar
';


--
-- Name: cal_party_prefs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cal_party_prefs (
    calendar_id integer,
    party_id integer,
    default_view character varying(10) DEFAULT 'day'::character varying,
    default_duration integer DEFAULT 60,
    daily_start numeric(2,0) DEFAULT 7,
    daily_end numeric(2,0) DEFAULT 18,
    time_zone integer,
    first_day_of_week character varying(9) DEFAULT 'Sunday'::character varying,
    CONSTRAINT cal_party_prefs_time_zone CHECK ((time_zone > 0)),
    CONSTRAINT cal_pty_prefs_1st_day_ck CHECK (((((((((first_day_of_week)::text = 'Sunday'::text) OR ((first_day_of_week)::text = 'Monday'::text)) OR ((first_day_of_week)::text = 'Tuesday'::text)) OR ((first_day_of_week)::text = 'Wednesday'::text)) OR ((first_day_of_week)::text = 'Thursday'::text)) OR ((first_day_of_week)::text = 'Friday'::text)) OR ((first_day_of_week)::text = 'Saturday'::text))),
    CONSTRAINT cal_pty_prefs_daily_end CHECK (((daily_end < (24)::numeric) AND (daily_end > (0)::numeric))),
    CONSTRAINT cal_pty_prefs_daily_start CHECK (((daily_start < (24)::numeric) AND (daily_start > ((-1))::numeric))),
    CONSTRAINT cal_pty_prefs_default_duration CHECK ((default_duration > 0)),
    CONSTRAINT cal_pty_prefs_default_view_ck CHECK (((((((default_view)::text = 'list'::text) OR ((default_view)::text = 'day'::text)) OR ((default_view)::text = 'week'::text)) OR ((default_view)::text = 'month'::text)) OR ((default_view)::text = 'year'::text)))
);


--
-- Name: TABLE cal_party_prefs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cal_party_prefs IS '
        Table cal_user_prefs would stores custom information
        about each indivdual user. This would include time zone
        which is the first day of the week, monday or sunday, 
        and the likes. 
';


--
-- Name: COLUMN cal_party_prefs.party_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cal_party_prefs.party_id IS '
        Maps to a party
';


--
-- Name: COLUMN cal_party_prefs.default_view; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cal_party_prefs.default_view IS '
        default_view stores whether the user wants
        list, month, day, week, or year as his/her default view. 
';


--
-- Name: COLUMN cal_party_prefs.default_duration; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cal_party_prefs.default_duration IS '
        the default number of minutes for each appointment
';


--
-- Name: COLUMN cal_party_prefs.daily_start; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cal_party_prefs.daily_start IS '
        the default start time in daily view in military time 00 - 23
        default to 07 or 7 am
';


--
-- Name: COLUMN cal_party_prefs.daily_end; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cal_party_prefs.daily_end IS '
        the default end time in daily view in military time 00 - 23
        default to 18 or 6 pm
';


--
-- Name: COLUMN cal_party_prefs.first_day_of_week; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cal_party_prefs.first_day_of_week IS '
        Which day of the week will be displayed first in month and week view    
';


--
-- Name: calendars; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE calendars (
    calendar_id integer NOT NULL,
    calendar_name character varying(200),
    owner_id integer,
    package_id integer,
    private_p boolean DEFAULT false,
    CONSTRAINT calendars_private_p_ck CHECK (((private_p = true) OR (private_p = false)))
);


--
-- Name: TABLE calendars; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE calendars IS '
        Table calendars maps the many to many relationship betweens
        calendar and its owners. 
';


--
-- Name: COLUMN calendars.calendar_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN calendars.calendar_id IS '
        Primary Key
';


--
-- Name: COLUMN calendars.calendar_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN calendars.calendar_name IS '
        the name of the calendar. This would be unique to avoid confusion
';


--
-- Name: COLUMN calendars.owner_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN calendars.owner_id IS '
        the individual or party that owns the calendar
';


--
-- Name: COLUMN calendars.package_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN calendars.package_id IS '
        keep track of package instances
';


--
-- Name: categories; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE categories (
    category_id integer NOT NULL,
    tree_id integer,
    parent_id integer,
    deprecated_p character(1) DEFAULT 'f'::bpchar,
    left_ind integer,
    right_ind integer,
    CONSTRAINT cat_deprecated_p_ck CHECK (((deprecated_p = 't'::bpchar) OR (deprecated_p = 'f'::bpchar)))
);


--
-- Name: TABLE categories; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE categories IS '
  Information about the categories in the tree structure.
';


--
-- Name: COLUMN categories.category_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN categories.category_id IS '
  ID of a category.
';


--
-- Name: COLUMN categories.tree_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN categories.tree_id IS '
  ID of a tree (see category_trees).
';


--
-- Name: COLUMN categories.parent_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN categories.parent_id IS '
  Points to a parent category in the tree or null (if topmost category).
';


--
-- Name: COLUMN categories.deprecated_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN categories.deprecated_p IS '
  Marks categories to be no longer supported.
';


--
-- Name: COLUMN categories.left_ind; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN categories.left_ind IS '
  Left index in nested set structure of a tree.
';


--
-- Name: COLUMN categories.right_ind; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN categories.right_ind IS '
  Right index in nested set structure of a tree.
';


--
-- Name: category_links; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_links (
    link_id integer NOT NULL,
    from_category_id integer NOT NULL,
    to_category_id integer NOT NULL
);


--
-- Name: TABLE category_links; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_links IS '
  Stores directed graph of linked categories. If category A
  and category B are linked, then any categorization on A
  will result in an additional categorization in B.
';


--
-- Name: COLUMN category_links.link_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_links.link_id IS '
  Primary key.
';


--
-- Name: COLUMN category_links.from_category_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_links.from_category_id IS '
  Category the link is coming from. Any categorization in this
  category will trigger a categorization in the other category.
';


--
-- Name: COLUMN category_links.to_category_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_links.to_category_id IS '
  Category the link is coming to. Any categorization in the other
  category will trigger a categorization in this category.
';


--
-- Name: category_links_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE category_links_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: category_object_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_object_map (
    category_id integer NOT NULL,
    object_id integer NOT NULL
);


--
-- Name: TABLE category_object_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_object_map IS '
  Maps categories to objects and thus categorizes and object.
';


--
-- Name: COLUMN category_object_map.category_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_object_map.category_id IS '
  ID of the mapped category (see categories).
';


--
-- Name: COLUMN category_object_map.object_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_object_map.object_id IS '
  ID of the mapped object.
';


--
-- Name: category_object_map_tree; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW category_object_map_tree AS
    SELECT c.category_id, c.tree_id, m.object_id FROM category_object_map m, categories c WHERE (c.category_id = m.category_id);


--
-- Name: category_search; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_search (
    query_id integer NOT NULL,
    search_text character varying(200) NOT NULL,
    locale character varying(5) NOT NULL,
    queried_count integer DEFAULT 1 NOT NULL,
    last_queried timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL
);


--
-- Name: TABLE category_search; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_search IS '
  Stores users multilingual search texts for category synonyms.
';


--
-- Name: COLUMN category_search.query_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search.query_id IS '
  Primary key.
';


--
-- Name: COLUMN category_search.search_text; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search.search_text IS '
  Actual search text in given language.
';


--
-- Name: COLUMN category_search.locale; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search.locale IS '
  Language of the search text.
';


--
-- Name: COLUMN category_search.queried_count; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search.queried_count IS '
  Counts how often this search text has been used by users.
';


--
-- Name: COLUMN category_search.last_queried; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search.last_queried IS '
  Date of last usage of this search text.
  A sweeper will delete search texts not used for a while.
';


--
-- Name: category_search_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE category_search_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: category_search_index; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_search_index (
    query_id integer NOT NULL,
    trigram character(3) NOT NULL
);


--
-- Name: TABLE category_search_index; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_search_index IS '
  Stores the search text cut down in portions of 3 characters
  to be used in search.
';


--
-- Name: COLUMN category_search_index.query_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search_index.query_id IS '
  Id of the search text refered to.
';


--
-- Name: COLUMN category_search_index.trigram; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search_index.trigram IS '
  3 character part of the search text.
';


--
-- Name: category_search_results; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_search_results (
    query_id integer NOT NULL,
    synonym_id integer NOT NULL,
    similarity integer NOT NULL
);


--
-- Name: TABLE category_search_results; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_search_results IS '
  Stores the result of a users search in synonyms,
  stores matching synonyms and their degree of similarity
  to the search text.
';


--
-- Name: COLUMN category_search_results.query_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search_results.query_id IS '
  Id of the search text.
';


--
-- Name: COLUMN category_search_results.synonym_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search_results.synonym_id IS '
  Id of the synonym found.
';


--
-- Name: COLUMN category_search_results.similarity; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_search_results.similarity IS '
  Percent of similarity between search text and found synonym.
';


--
-- Name: category_synonym_index; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_synonym_index (
    synonym_id integer NOT NULL,
    trigram character(3) NOT NULL
);


--
-- Name: TABLE category_synonym_index; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_synonym_index IS '
  Stores the synonym cut down in portions of 3 characters
  to be used in search.
';


--
-- Name: COLUMN category_synonym_index.synonym_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_synonym_index.synonym_id IS '
  Id of the synonym refered to.
';


--
-- Name: COLUMN category_synonym_index.trigram; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_synonym_index.trigram IS '
  3 character part of the synonym.
';


--
-- Name: category_synonyms; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_synonyms (
    synonym_id integer NOT NULL,
    category_id integer NOT NULL,
    locale character varying(5) NOT NULL,
    name character varying(100) NOT NULL,
    synonym_p character(1) DEFAULT 't'::bpchar,
    CONSTRAINT category_synonyms_synonym_p_ck CHECK (((synonym_p = 't'::bpchar) OR (synonym_p = 'f'::bpchar)))
);


--
-- Name: TABLE category_synonyms; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_synonyms IS '
  Stores multilingual synonyms of the categories.
';


--
-- Name: COLUMN category_synonyms.synonym_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_synonyms.synonym_id IS '
  Primary key.
';


--
-- Name: COLUMN category_synonyms.category_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_synonyms.category_id IS '
  Category the synonyms are refering to.
';


--
-- Name: COLUMN category_synonyms.locale; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_synonyms.locale IS '
  Language of the synonym.
';


--
-- Name: COLUMN category_synonyms.name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_synonyms.name IS '
  Actual synonym of the category in given language.
';


--
-- Name: COLUMN category_synonyms.synonym_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_synonyms.synonym_p IS '
  Marks if the entry is a synonym to be edited by user or is a copy
  of a category translation and cannot be edited directly.
';


--
-- Name: category_synonyms_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE category_synonyms_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: category_temp; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_temp (
    category_id integer
);


--
-- Name: TABLE category_temp; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_temp IS '
  Used mainly for multi-dimensional browsing to use only bind vars
  in queries
';


--
-- Name: category_translations; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_translations (
    category_id integer NOT NULL,
    locale character varying(5) NOT NULL,
    name character varying(200),
    description character varying(4000)
);


--
-- Name: TABLE category_translations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_translations IS '
  Translations for names and descriptions of categories in different languages.
';


--
-- Name: COLUMN category_translations.category_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_translations.category_id IS '
  ID of a category (see categories).
';


--
-- Name: COLUMN category_translations.locale; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_translations.locale IS '
  ACS-Lang style locale if language ad country.
';


--
-- Name: COLUMN category_translations.name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_translations.name IS '
  Name of the category in the specified language.
';


--
-- Name: COLUMN category_translations.description; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_translations.description IS '
  Description of the category in the specified language.
';


--
-- Name: category_tree_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_tree_map (
    tree_id integer NOT NULL,
    object_id integer NOT NULL,
    subtree_category_id integer,
    assign_single_p character(1) DEFAULT 'f'::bpchar,
    require_category_p character(1) DEFAULT 'f'::bpchar,
    CONSTRAINT cat_tree_map_categ_p_ck CHECK (((require_category_p = 't'::bpchar) OR (require_category_p = 'f'::bpchar))),
    CONSTRAINT cat_tree_map_single_p_ck CHECK (((assign_single_p = 't'::bpchar) OR (assign_single_p = 'f'::bpchar)))
);


--
-- Name: TABLE category_tree_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_tree_map IS '
  Maps trees to objects (usually package instances) so that
  other objects can be categorized.
';


--
-- Name: COLUMN category_tree_map.tree_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_tree_map.tree_id IS '
  ID of the mapped tree (see category_trees).
';


--
-- Name: COLUMN category_tree_map.object_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_tree_map.object_id IS '
  ID of the mapped object (usually an apm_package if trees are to be used
  in a whole package instance, i.e. file-storage).
';


--
-- Name: COLUMN category_tree_map.subtree_category_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_tree_map.subtree_category_id IS '
  If a subtree is mapped, then this is the ID of the category on top
  of the subtree, null otherwise.
';


--
-- Name: COLUMN category_tree_map.assign_single_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_tree_map.assign_single_p IS '
  Are the users allowed to assign multiple or only a single category
  to objects?
';


--
-- Name: COLUMN category_tree_map.require_category_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_tree_map.require_category_p IS '
  Do the users have to assign at least one category to objects?
';


--
-- Name: category_tree_translations; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_tree_translations (
    tree_id integer NOT NULL,
    locale character varying(5) NOT NULL,
    name character varying(50) NOT NULL,
    description character varying(1000)
);


--
-- Name: TABLE category_tree_translations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_tree_translations IS '
  Translations for names and descriptions of trees in different languages.
';


--
-- Name: COLUMN category_tree_translations.tree_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_tree_translations.tree_id IS '
  ID of a tree (see category_trees).
';


--
-- Name: COLUMN category_tree_translations.locale; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_tree_translations.locale IS '
  ACS-Lang style locale if language ad country.
';


--
-- Name: COLUMN category_tree_translations.name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_tree_translations.name IS '
  Name of the tree in the specified language.
';


--
-- Name: COLUMN category_tree_translations.description; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_tree_translations.description IS '
  Description of the tree in the specified language.
';


--
-- Name: category_trees; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE category_trees (
    tree_id integer NOT NULL,
    site_wide_p character(1) DEFAULT 't'::bpchar,
    CONSTRAINT cat_trees_site_wide_p_ck CHECK (((site_wide_p = 't'::bpchar) OR (site_wide_p = 'f'::bpchar)))
);


--
-- Name: TABLE category_trees; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE category_trees IS '
  This is general data for each category tree.
';


--
-- Name: COLUMN category_trees.tree_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_trees.tree_id IS '
  ID of a tree.
';


--
-- Name: COLUMN category_trees.site_wide_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN category_trees.site_wide_p IS '
  Declares if a tree is site-wide or local (only usable by users/groups
  that have permissions).
';


--
-- Name: cc_users; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW cc_users AS
    SELECT o.object_id, o.object_type, o.context_id, o.security_inherit_p, o.creation_user, o.creation_date, o.creation_ip, o.last_modified, o.modifying_user, o.modifying_ip, o.tree_sortkey, o.max_child_sortkey, pa.party_id, pa.email, pa.url, pe.person_id, pe.first_names, pe.last_name, u.user_id, u.password, u.salt, u.screen_name, u.priv_name, u.priv_email, u.email_verified_p, u.email_bouncing_p, u.no_alerts_until, u.last_visit, u.second_to_last_visit, u.n_sessions, u.password_question, u.password_answer, u.password_changed_date, u.authority_id, u.username, u.auth_token, mr.member_state, mr.rel_id FROM acs_objects o, parties pa, persons pe, users u, group_member_map m, membership_rels mr WHERE ((((((((o.object_id = pa.party_id) AND (pa.party_id = pe.person_id)) AND (pe.person_id = u.user_id)) AND (u.user_id = m.member_id)) AND (m.group_id = acs__magic_object_id('registered_users'::character varying))) AND (m.rel_id = mr.rel_id)) AND (m.container_id = m.group_id)) AND ((m.rel_type)::text = 'membership_rel'::text));


--
-- Name: comp_or_member_rel_types; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW comp_or_member_rel_types AS
    SELECT o.object_type AS rel_type FROM acs_object_types o, acs_object_types o1 WHERE ((((o1.object_type)::text = ('composition_rel'::character varying)::text) OR ((o1.object_type)::text = ('membership_rel'::character varying)::text)) AND ((o.tree_sortkey >= o1.tree_sortkey) AND (o.tree_sortkey <= tree_right(o1.tree_sortkey))));


--
-- Name: composition_rels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE composition_rels (
    rel_id integer NOT NULL
);


--
-- Name: rel_constraints; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE rel_constraints (
    constraint_id integer NOT NULL,
    constraint_name character varying(100) NOT NULL,
    rel_segment integer NOT NULL,
    rel_side character(3) DEFAULT 'two'::bpchar NOT NULL,
    required_rel_segment integer NOT NULL,
    CONSTRAINT rc_rel_side_ck CHECK (((rel_side = 'one'::bpchar) OR (rel_side = 'two'::bpchar)))
);


--
-- Name: TABLE rel_constraints; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE rel_constraints IS '
  Defines relational constraints. The relational constraints system is
  intended to support applications in modelling and applying
  constraint rules on inter-party relatinships based on relational
  party segmentation.
';


--
-- Name: COLUMN rel_constraints.constraint_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rel_constraints.constraint_name IS '
  The user-defined name of this constraint.
';


--
-- Name: COLUMN rel_constraints.rel_segment; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rel_constraints.rel_segment IS '
  The segment for which the constraint is defined.
';


--
-- Name: COLUMN rel_constraints.rel_side; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rel_constraints.rel_side IS '
  The side of the relation the constraint applies to.
';


--
-- Name: COLUMN rel_constraints.required_rel_segment; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rel_constraints.required_rel_segment IS '
  The segment in which elements must be in to satisfy the constraint.
';


--
-- Name: rel_segment_party_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_segment_party_map AS
    SELECT rs.segment_id, gem.element_id AS party_id, gem.rel_id, gem.rel_type, gem.group_id, gem.container_id, gem.ancestor_rel_type FROM rel_segments rs, group_element_map gem, acs_object_types o1, acs_object_types o2 WHERE ((((gem.group_id = rs.group_id) AND ((o1.object_type)::text = (gem.rel_type)::text)) AND ((o2.object_type)::text = (rs.rel_type)::text)) AND ((o1.tree_sortkey >= o2.tree_sortkey) AND (o1.tree_sortkey <= tree_right(o2.tree_sortkey))));


--
-- Name: constrained_rels1; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW constrained_rels1 AS
    SELECT rel.constraint_id, rel.constraint_name, r.rel_id, r.container_id, r.party_id, r.rel_type, rel.rel_segment, rel.rel_side, rel.required_rel_segment FROM rel_constraints rel, rel_segment_party_map r WHERE ((rel.rel_side = 'one'::bpchar) AND (rel.rel_segment = r.segment_id));


--
-- Name: constrained_rels2; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW constrained_rels2 AS
    SELECT rel.constraint_id, rel.constraint_name, r.rel_id, r.container_id, r.party_id, r.rel_type, rel.rel_segment, rel.rel_side, rel.required_rel_segment FROM rel_constraints rel, rel_segment_party_map r WHERE ((rel.rel_side = 'two'::bpchar) AND (rel.rel_segment = r.segment_id));


--
-- Name: content_item_globals; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW content_item_globals AS
    SELECT (-100) AS c_root_folder_id;


--
-- Name: content_item_gp_session_id; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE content_item_gp_session_id
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: content_template_globals; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW content_template_globals AS
    SELECT (-200) AS c_root_folder_id;


--
-- Name: cr_child_rels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_child_rels (
    rel_id integer NOT NULL,
    parent_id integer NOT NULL,
    child_id integer NOT NULL,
    relation_tag character varying(100),
    order_n integer
);


--
-- Name: TABLE cr_child_rels; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_child_rels IS '
  Provides for richer parent-child relationships than the simple
  link encapsulated in the primary table.  May be subclassed to provide
  additional attributes.
';


--
-- Name: cr_content_mime_type_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_content_mime_type_map (
    content_type character varying(100) NOT NULL,
    mime_type character varying(200) NOT NULL
);


--
-- Name: TABLE cr_content_mime_type_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_content_mime_type_map IS '
  A mapping table that restricts the MIME types associated with a 
  content type.
';


--
-- Name: cr_content_text; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_content_text (
    revision_id integer NOT NULL,
    content integer
);


--
-- Name: TABLE cr_content_text; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_content_text IS '
  A temporary table for holding text extracted from the content blob.
  Provides a workaround for the fact that blob_to_string(content) has
  4000 character limit.
';


--
-- Name: cr_doc_filter; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_doc_filter (
    revision_id integer NOT NULL,
    content integer
);


--
-- Name: TABLE cr_doc_filter; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_doc_filter IS '
  A temporary table for holding binary documents that are to be converted
  into HTML (or plain text) prior to insertion into the repository.
';


--
-- Name: cr_dummy; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_dummy (
    val integer
);


--
-- Name: cr_extension_mime_type_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_extension_mime_type_map (
    extension character varying(200) NOT NULL,
    mime_type character varying(200)
);


--
-- Name: TABLE cr_extension_mime_type_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_extension_mime_type_map IS '
  a mapping table for extension to mime_type in db version of ns_guesstype data
';


--
-- Name: cr_extlinks; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_extlinks (
    extlink_id integer NOT NULL,
    url character varying(1000) NOT NULL,
    label character varying(1000) NOT NULL,
    description text
);


--
-- Name: TABLE cr_extlinks; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_extlinks IS '
  Extlinks are pointers to items anywhere on the web which the publisher wishes
  to categorize, index and relate to items in the content repository.
';


--
-- Name: cr_files_to_delete; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_files_to_delete (
    path character varying(250),
    storage_area_key character varying(100)
);


--
-- Name: TABLE cr_files_to_delete; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_files_to_delete IS '
  Table to store files to be deleted by a scheduled sweep.
  Since binaries are stored in filesystem and attributes in database,
  need a way to delete both atomically.  So any process to delete file-system cr_revisions,
  copies the file path to this table as part of the delete transaction.  Sweep
  run later to remove the files from filesystem once database info is successfully deleted.
';


--
-- Name: cr_folder_type_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_folder_type_map (
    folder_id integer NOT NULL,
    content_type character varying(100) NOT NULL
);


--
-- Name: TABLE cr_folder_type_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_folder_type_map IS '
  A one-to-many mapping table of content folders to content types. 
  Basically, this table restricts the content types a folder may contain.
  Future releases will add numeric and tagged constraints similar to
  thos available for content types.  
';


--
-- Name: cr_folders; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_folders (
    folder_id integer NOT NULL,
    label character varying(1000),
    description text,
    has_child_folders boolean DEFAULT false,
    has_child_symlinks boolean DEFAULT false,
    package_id integer
);


--
-- Name: TABLE cr_folders; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_folders IS '
  Folders are used to support a virtual file system within the content
  repository.
';


--
-- Name: cr_item_keyword_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_item_keyword_map (
    item_id integer NOT NULL,
    keyword_id integer NOT NULL
);


--
-- Name: cr_item_publish_audit; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_item_publish_audit (
    item_id integer,
    old_revision integer,
    new_revision integer,
    old_status character varying(40),
    new_status character varying(40),
    publish_date timestamp with time zone NOT NULL
);


--
-- Name: TABLE cr_item_publish_audit; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_item_publish_audit IS '
  An audit table (populated by a trigger on cr_items.live_revision)
  that is used to keep track of the publication history of an item.
';


--
-- Name: cr_item_rels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_item_rels (
    rel_id integer NOT NULL,
    item_id integer,
    related_object_id integer,
    relation_tag character varying(100),
    order_n integer
);


--
-- Name: TABLE cr_item_rels; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_item_rels IS '
  Describes all relations from one item to any number of other
  objects.
';


--
-- Name: COLUMN cr_item_rels.relation_tag; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cr_item_rels.relation_tag IS '
  A token for lightweight classification of item relationships.
  If additional attributes are required, then a subtype of
  item_rel may be created.
';


--
-- Name: COLUMN cr_item_rels.order_n; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cr_item_rels.order_n IS '
  Optional column for specifying a sort order.  Note that the ordering
  method is application-dependent (it may be by relation type or
  across multiple relation types).
';


--
-- Name: cr_item_template_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_item_template_map (
    item_id integer NOT NULL,
    template_id integer NOT NULL,
    use_context character varying(100) NOT NULL
);


--
-- Name: TABLE cr_item_template_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_item_template_map IS '
  Allows a template to be assigned to a specific item.
';


--
-- Name: cr_keywords; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_keywords (
    keyword_id integer NOT NULL,
    parent_id integer,
    heading character varying(600) NOT NULL,
    description text,
    has_children boolean,
    tree_sortkey bit varying
);


--
-- Name: TABLE cr_keywords; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_keywords IS '
  Stores a subject taxonomy for classifying content items, analogous
  to the system used by a library.
';


--
-- Name: COLUMN cr_keywords.heading; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cr_keywords.heading IS '
  A subject heading.  This will become a message ID in the next
  release so it should never be referenced directly (only through
  the API)
';


--
-- Name: COLUMN cr_keywords.description; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cr_keywords.description IS '
  Description of a subject heading.  This will be a message ID in the next
  release so it should never be referenced directly (only through
  the API)
';


--
-- Name: cr_locales; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_locales (
    locale character varying(4) NOT NULL,
    label character varying(200) NOT NULL,
    nls_language character varying(30) NOT NULL,
    nls_territory character varying(30),
    nls_charset character varying(30)
);


--
-- Name: TABLE cr_locales; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_locales IS '
  Locale definitions in Oracle consist of a language, and optionally
  territory and character set.  (Languages are associated with default
  territories and character sets when not defined).  The formats
  for numbers, currency, dates, etc. are determined by the territory.
';


--
-- Name: cr_mime_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_mime_types (
    label character varying(200),
    mime_type character varying(200) NOT NULL,
    file_extension character varying(200)
);


--
-- Name: TABLE cr_mime_types; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_mime_types IS '
  file_extension is not used to recognize MIME types, but to associate
  a file extension to the file after its MIME type is specified.
';


--
-- Name: cr_news; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_news (
    news_id integer NOT NULL,
    package_id integer NOT NULL,
    archive_date timestamp with time zone,
    approval_user integer,
    approval_date timestamp with time zone,
    approval_ip character varying(50),
    lead character varying(4000)
);


--
-- Name: cr_text; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_text (
    text_data text
);


--
-- Name: TABLE cr_text; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_text IS '
  A simple placeholder table for generating input views, so that a
  complete revision may be added with a single INSERT statement.
';


--
-- Name: cr_newsi; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW cr_newsi AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.title AS object_title, acs_objects.package_id AS object_package_id, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, acs_objects.max_child_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, cr_news.news_id, cr_news.package_id, cr_news.archive_date, cr_news.approval_user, cr_news.approval_date, cr_news.approval_ip, cr_news.lead FROM acs_objects, cr_revisions cr, cr_text, cr_news WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = cr_news.news_id));


--
-- Name: cr_newsx; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW cr_newsx AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.title AS object_title, acs_objects.package_id AS object_package_id, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, acs_objects.max_child_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id, cr_news.news_id, cr_news.package_id, cr_news.archive_date, cr_news.approval_user, cr_news.approval_date, cr_news.approval_ip, cr_news.lead FROM acs_objects, cr_revisions cr, cr_items i, cr_text, cr_news WHERE (((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id)) AND (acs_objects.object_id = cr_news.news_id));


--
-- Name: cr_release_periods; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_release_periods (
    item_id integer NOT NULL,
    start_when timestamp with time zone DEFAULT now(),
    end_when timestamp with time zone DEFAULT (date(now()) + 7300)
);


--
-- Name: cr_symlinks; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_symlinks (
    symlink_id integer NOT NULL,
    target_id integer NOT NULL,
    label character varying(1000)
);


--
-- Name: TABLE cr_symlinks; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_symlinks IS '
  Symlinks are pointers to items within the content repository.
';


--
-- Name: cr_resolved_items; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW cr_resolved_items AS
    SELECT i.parent_id, i.item_id, i.name, CASE WHEN (s.target_id IS NULL) THEN 'f'::text ELSE 't'::text END AS is_symlink, CASE WHEN (s.target_id IS NOT NULL) THEN s.target_id WHEN (i.item_id IS NOT NULL) THEN i.item_id ELSE NULL::integer END AS resolved_id, s.label FROM (cr_items i LEFT JOIN cr_symlinks s ON ((i.item_id = s.symlink_id)));


--
-- Name: cr_revision_attributes; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_revision_attributes (
    revision_id integer NOT NULL,
    attributes text
);


--
-- Name: COLUMN cr_revision_attributes.attributes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cr_revision_attributes.attributes IS '
  An XML document representing the compiled attributes for a revision
';


--
-- Name: cr_revisionsi; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW cr_revisionsi AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language FROM acs_objects, cr_revisions cr, cr_text WHERE (acs_objects.object_id = cr.revision_id);


--
-- Name: cr_revisionsx; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW cr_revisionsx AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id FROM acs_objects, cr_revisions cr, cr_items i, cr_text WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id));


--
-- Name: cr_scheduled_release_job; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_scheduled_release_job (
    job_id integer,
    last_exec timestamp with time zone
);


--
-- Name: TABLE cr_scheduled_release_job; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_scheduled_release_job IS '
  One-row table to track job ID of scheduled release update.
';


--
-- Name: cr_scheduled_release_log; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_scheduled_release_log (
    exec_date timestamp with time zone DEFAULT now() NOT NULL,
    items_released integer NOT NULL,
    items_expired integer NOT NULL,
    err_num integer,
    err_msg character varying(500)
);


--
-- Name: TABLE cr_scheduled_release_log; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_scheduled_release_log IS '
  Maintains a record, including any exceptions that may
  have aborted processing, for each scheduled update of live content.
';


--
-- Name: cr_template_use_contexts; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_template_use_contexts (
    use_context character varying(100) NOT NULL
);


--
-- Name: TABLE cr_template_use_contexts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_template_use_contexts IS '
  A simple table (for now) for constraining template use contexts.
';


--
-- Name: cr_templates; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_templates (
    template_id integer NOT NULL
);


--
-- Name: TABLE cr_templates; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_templates IS '
  Templates are a special class of text objects that are used for specifying
  the layout of a content item.  They may be mapped to content types for
  defaults, or may be mapped to individual content items.
';


--
-- Name: cr_type_children; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_type_children (
    parent_type character varying(100) NOT NULL,
    child_type character varying(100) NOT NULL,
    relation_tag character varying(100) NOT NULL,
    min_n integer,
    max_n integer
);


--
-- Name: TABLE cr_type_children; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_type_children IS '
  Constrains the allowable content types which a content type may
  contain.
';


--
-- Name: cr_type_relations; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_type_relations (
    content_type character varying(100) NOT NULL,
    target_type character varying(100) NOT NULL,
    relation_tag character varying(100) NOT NULL,
    min_n integer,
    max_n integer
);


--
-- Name: TABLE cr_type_relations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_type_relations IS '
  Constrains the allowable object types to which a content type may
  relate (see above).
';


--
-- Name: cr_type_template_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_type_template_map (
    content_type character varying(100) NOT NULL,
    template_id integer NOT NULL,
    use_context character varying(100) NOT NULL,
    is_default boolean DEFAULT false
);


--
-- Name: TABLE cr_type_template_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_type_template_map IS '
  A simple mapping template among content types and templates.
  Used to determine the default template to use in any particular
  context, as well as for building any UI that allows publishers
  to choose from a palette of templates.
';


--
-- Name: COLUMN cr_type_template_map.use_context; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN cr_type_template_map.use_context IS '
  A token to indicate the context in which a template is appropriate, 
  such as admin or public.  Should be constrained when it becomes
  clearer how this will be used.
';


--
-- Name: cr_xml_doc_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE cr_xml_doc_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: cr_xml_docs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE cr_xml_docs (
    doc_id integer NOT NULL,
    doc text
);


--
-- Name: TABLE cr_xml_docs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE cr_xml_docs IS '
  A temporary table for holding uploaded XML documents for the
  duration of a transaction, until they can be inserted into
  the content repository.
';


--
-- Name: dav_site_node_folder_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE dav_site_node_folder_map (
    node_id integer,
    folder_id integer,
    enabled_p boolean
);


--
-- Name: download_archive_revisions; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_archive_revisions (
    revision_id integer NOT NULL,
    approved_p boolean,
    approved_date timestamp with time zone,
    approved_user integer,
    approved_comment text,
    file_size integer NOT NULL
);


--
-- Name: download_arch_revisions_obj; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_arch_revisions_obj AS
    SELECT dar.revision_id, dar.approved_p, dar.approved_date, dar.approved_user, dar.approved_comment, dar.file_size, o.object_id, o.object_type, o.context_id, o.security_inherit_p, o.creation_user, o.creation_date, o.creation_ip, o.last_modified, o.modifying_user, o.modifying_ip, o.tree_sortkey, r.item_id AS archive_id, r.title AS file_name, r.description AS version_name, r.publish_date, r.mime_type, r.content FROM download_archive_revisions dar, acs_objects o, cr_revisions r WHERE ((dar.revision_id = o.object_id) AND (dar.revision_id = r.revision_id));


--
-- Name: download_archive_descs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_archive_descs (
    archive_desc_id integer NOT NULL
);


--
-- Name: download_archive_descsi; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_archive_descsi AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, download_archive_descs.archive_desc_id FROM acs_objects, cr_revisions cr, cr_text, download_archive_descs WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = download_archive_descs.archive_desc_id));


--
-- Name: download_archive_descsx; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_archive_descsx AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id, download_archive_descs.archive_desc_id FROM acs_objects, cr_revisions cr, cr_items i, cr_text, download_archive_descs WHERE (((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id)) AND (acs_objects.object_id = download_archive_descs.archive_desc_id));


--
-- Name: download_archive_metadata; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_archive_metadata (
    metadata_id integer NOT NULL,
    repository_id integer,
    archive_type_id integer,
    sort_key integer NOT NULL,
    pretty_name character varying(100) NOT NULL,
    data_type character varying(30),
    required_p boolean,
    linked_p boolean,
    mainpage_p boolean,
    computed_p boolean,
    CONSTRAINT download_data_type_ck CHECK (((((((((data_type)::text = ('text'::character varying)::text) OR ((data_type)::text = ('shorttext'::character varying)::text)) OR ((data_type)::text = ('boolean'::character varying)::text)) OR ((data_type)::text = ('number'::character varying)::text)) OR ((data_type)::text = ('integer'::character varying)::text)) OR ((data_type)::text = ('date'::character varying)::text)) OR ((data_type)::text = ('choice'::character varying)::text)))
);


--
-- Name: TABLE download_archive_metadata; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE download_archive_metadata IS '
 This table stores information about all metadata stored for each archive in a given
 repository.';


--
-- Name: download_archive_type_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE download_archive_type_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: download_archive_type_sequence; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_archive_type_sequence AS
    SELECT nextval(('download_archive_type_seq'::text)::regclass) AS nextval;


--
-- Name: download_archive_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_archive_types (
    archive_type_id integer NOT NULL,
    repository_id integer,
    pretty_name character varying(100) NOT NULL,
    description character varying(500) NOT NULL
);


--
-- Name: TABLE download_archive_types; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE download_archive_types IS '
 This table stores the types of archives that can be stored in a given download repository.
';


--
-- Name: download_archives; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_archives (
    archive_id integer NOT NULL,
    archive_type_id integer,
    archive_desc_id integer
);


--
-- Name: download_archives_obj; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_archives_obj AS
    SELECT cri.parent_id AS repository_id, cri.name AS archive_name, cri.latest_revision, cri.live_revision, da.archive_id, da.archive_type_id, da.archive_desc_id, desc_item.title AS summary, desc_item.description, desc_item.mime_type AS description_type, desc_item.creation_user, desc_item.creation_date, desc_item.creation_ip FROM download_archives da, cr_items cri, download_archive_descsi desc_item WHERE ((da.archive_desc_id = desc_item.revision_id) AND (da.archive_id = cri.item_id));


--
-- Name: download_archivesi; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_archivesi AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, download_archives.archive_id, download_archives.archive_type_id, download_archives.archive_desc_id FROM acs_objects, cr_revisions cr, cr_text, download_archives WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = download_archives.archive_id));


--
-- Name: download_archivesx; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_archivesx AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id, download_archives.archive_id, download_archives.archive_type_id, download_archives.archive_desc_id FROM acs_objects, cr_revisions cr, cr_items i, cr_text, download_archives WHERE (((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id)) AND (acs_objects.object_id = download_archives.archive_id));


--
-- Name: download_downloads; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_downloads (
    download_id integer NOT NULL,
    user_id integer,
    revision_id integer,
    download_date timestamp with time zone NOT NULL,
    download_hostname character varying(400),
    download_ip character varying(20),
    user_agent character varying(200),
    reason_id integer,
    reason text
);


--
-- Name: download_downloads_repository; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_downloads_repository AS
    SELECT dd.download_id, dd.user_id, dd.revision_id, dd.download_date, dd.download_hostname, dd.download_ip, dd.user_agent, dd.reason_id, dd.reason, (SELECT da.repository_id FROM download_archives_obj da, cr_revisions r WHERE ((dd.revision_id = r.revision_id) AND (r.item_id = da.archive_id))) AS repository_id FROM download_downloads dd;


--
-- Name: download_downloads_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE download_downloads_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: download_downloads_sequence; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_downloads_sequence AS
    SELECT nextval(('download_downloads_seq'::text)::regclass) AS nextval;


--
-- Name: download_md_choice_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE download_md_choice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: download_md_choice_id_sequence; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_md_choice_id_sequence AS
    SELECT nextval(('download_md_choice_id_seq'::text)::regclass) AS nextval;


--
-- Name: download_metadata_choices; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_metadata_choices (
    choice_id integer NOT NULL,
    metadata_id integer NOT NULL,
    label character varying(500) NOT NULL,
    numeric_value numeric,
    sort_order integer
);


--
-- Name: download_reasons; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_reasons (
    download_reason_id integer NOT NULL,
    repository_id integer,
    reason character varying(500) NOT NULL
);


--
-- Name: download_reasons_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE download_reasons_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: download_reasons_sequence; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_reasons_sequence AS
    SELECT nextval(('download_reasons_seq'::text)::regclass) AS nextval;


--
-- Name: download_repository; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_repository (
    repository_id integer NOT NULL
);


--
-- Name: TABLE download_repository; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE download_repository IS '
This table stores the actual download repositories.  Each repository has a title
and description of the repository.  Meta information about what can be stored in
the repository is keyed to this table';


--
-- Name: download_repository_obj; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_repository_obj AS
    SELECT dr.repository_id, o.object_id, o.object_type, o.context_id, o.security_inherit_p, o.creation_user, o.creation_date, o.creation_ip, o.last_modified, o.modifying_user, o.modifying_ip, o.tree_sortkey, i.parent_id, r.title, r.description, r.content AS help_text FROM download_repository dr, acs_objects o, cr_items i, cr_revisions r WHERE (((dr.repository_id = o.object_id) AND (i.item_id = o.object_id)) AND (r.revision_id = i.live_revision));


--
-- Name: download_repositoryi; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_repositoryi AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, download_repository.repository_id FROM acs_objects, cr_revisions cr, cr_text, download_repository WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = download_repository.repository_id));


--
-- Name: download_repositoryx; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW download_repositoryx AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id, download_repository.repository_id FROM acs_objects, cr_revisions cr, cr_items i, cr_text, download_repository WHERE (((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id)) AND (acs_objects.object_id = download_repository.repository_id));


--
-- Name: download_revision_data; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE download_revision_data (
    revision_id integer,
    metadata_id integer,
    choice_id integer,
    boolean_answer boolean,
    clob_answer text,
    number_answer numeric,
    varchar_answer text,
    date_answer timestamp with time zone
);


--
-- Name: enabled_locales; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW enabled_locales AS
    SELECT ad_locales.locale, ad_locales.language, ad_locales.country, ad_locales.variant, ad_locales.label, ad_locales.nls_language, ad_locales.nls_territory, ad_locales.nls_charset, ad_locales.mime_charset, ad_locales.default_p, ad_locales.enabled_p FROM ad_locales WHERE (ad_locales.enabled_p = true);


--
-- Name: etp_auto_page_number_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW etp_auto_page_number_seq AS
    SELECT nextval(('t_etp_auto_page_number_seq'::text)::regclass) AS nextval;


--
-- Name: etp_page_revisions; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE etp_page_revisions (
    etp_page_revision_id integer NOT NULL
);


--
-- Name: etp_page_revisionsi; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW etp_page_revisionsi AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, etp_page_revisions.etp_page_revision_id FROM acs_objects, cr_revisions cr, cr_text, etp_page_revisions WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = etp_page_revisions.etp_page_revision_id));


--
-- Name: etp_page_revisionsx; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW etp_page_revisionsx AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id, etp_page_revisions.etp_page_revision_id FROM acs_objects, cr_revisions cr, cr_items i, cr_text, etp_page_revisions WHERE (((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id)) AND (acs_objects.object_id = etp_page_revisions.etp_page_revision_id));


--
-- Name: forums_forums; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE forums_forums (
    forum_id integer NOT NULL,
    name character varying(200) NOT NULL,
    charter character varying(2000),
    presentation_type character varying(100) NOT NULL,
    posting_policy character varying(100) NOT NULL,
    max_child_sortkey bit varying,
    enabled_p character(1) DEFAULT 't'::bpchar NOT NULL,
    package_id integer NOT NULL,
    last_post timestamp with time zone,
    thread_count integer DEFAULT 0,
    approved_thread_count integer DEFAULT 0,
    CONSTRAINT forums_enabled_p_ck CHECK (((enabled_p = 't'::bpchar) OR (enabled_p = 'f'::bpchar))),
    CONSTRAINT forums_posting_policy_ck CHECK (((((posting_policy)::text = ('open'::character varying)::text) OR ((posting_policy)::text = ('moderated'::character varying)::text)) OR ((posting_policy)::text = ('closed'::character varying)::text))),
    CONSTRAINT forums_presentation_type_ck CHECK ((((presentation_type)::text = ('flat'::character varying)::text) OR ((presentation_type)::text = ('threaded'::character varying)::text)))
);


--
-- Name: forums_forums_enabled; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW forums_forums_enabled AS
    SELECT forums_forums.forum_id, forums_forums.name, forums_forums.charter, forums_forums.presentation_type, forums_forums.posting_policy, forums_forums.max_child_sortkey, forums_forums.enabled_p, forums_forums.package_id, forums_forums.last_post, forums_forums.thread_count, forums_forums.approved_thread_count FROM forums_forums WHERE (forums_forums.enabled_p = 't'::bpchar);


--
-- Name: forums_messages; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE forums_messages (
    message_id integer NOT NULL,
    forum_id integer,
    subject character varying(200),
    content text,
    user_id integer NOT NULL,
    posting_date timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    state character varying(100),
    parent_id integer,
    open_p character(1) DEFAULT 't'::bpchar NOT NULL,
    tree_sortkey bit varying,
    max_child_sortkey bit varying,
    last_child_post timestamp with time zone,
    format character varying(30) DEFAULT 'text/plain'::character varying,
    reply_count integer DEFAULT 0,
    approved_reply_count integer DEFAULT 0,
    last_poster integer,
    CONSTRAINT forum_mess_open_p_ck CHECK (((open_p = 't'::bpchar) OR (open_p = 'f'::bpchar))),
    CONSTRAINT forum_mess_state_ck CHECK (((((state)::text = ('pending'::character varying)::text) OR ((state)::text = ('approved'::character varying)::text)) OR ((state)::text = ('rejected'::character varying)::text))),
    CONSTRAINT forums_mess_format_ck CHECK ((((((format)::text = 'text/enhanced'::text) OR ((format)::text = 'text/plain'::text)) OR ((format)::text = 'text/fixed-width'::text)) OR ((format)::text = 'text/html'::text)))
);


--
-- Name: forums_messages_approved; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW forums_messages_approved AS
    SELECT forums_messages.message_id, forums_messages.forum_id, forums_messages.subject, forums_messages.content, forums_messages.user_id, forums_messages.posting_date, forums_messages.state, forums_messages.parent_id, forums_messages.open_p, forums_messages.tree_sortkey, forums_messages.max_child_sortkey, forums_messages.last_child_post, forums_messages.format, forums_messages.reply_count, forums_messages.approved_reply_count, forums_messages.last_poster FROM forums_messages WHERE ((forums_messages.state)::text = 'approved'::text);


--
-- Name: forums_messages_pending; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW forums_messages_pending AS
    SELECT forums_messages.message_id, forums_messages.forum_id, forums_messages.subject, forums_messages.content, forums_messages.user_id, forums_messages.posting_date, forums_messages.state, forums_messages.parent_id, forums_messages.open_p, forums_messages.tree_sortkey, forums_messages.max_child_sortkey, forums_messages.last_child_post, forums_messages.format, forums_messages.reply_count, forums_messages.approved_reply_count, forums_messages.last_poster FROM forums_messages WHERE ((forums_messages.state)::text = 'pending'::text);


--
-- Name: fs_files; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW fs_files AS
    SELECT cr_revisions.item_id AS file_id, cr_revisions.revision_id AS live_revision, cr_revisions.mime_type AS type, cr_revisions.title AS file_upload_name, cr_revisions.content_length AS content_size, cr_items.name, acs_objects.last_modified, cr_items.parent_id, cr_items.name AS key FROM cr_revisions, cr_items, acs_objects WHERE ((((cr_revisions.revision_id = cr_items.live_revision) AND (cr_revisions.item_id = cr_items.item_id)) AND ((cr_items.content_type)::text = ('file_storage_object'::character varying)::text)) AND (cr_revisions.revision_id = acs_objects.object_id));


--
-- Name: fs_folders; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW fs_folders AS
    SELECT cr_folders.folder_id, cr_folders.label AS name, acs_objects.last_modified, (SELECT count(*) AS count FROM cr_items ci2 WHERE (((ci2.content_type)::text <> ('content_folder'::character varying)::text) AND ((ci2.tree_sortkey >= ci.tree_sortkey) AND (ci2.tree_sortkey <= tree_right(ci.tree_sortkey))))) AS content_size, ci.parent_id, ci.name AS key FROM cr_folders, cr_items ci, acs_objects WHERE ((cr_folders.folder_id = ci.item_id) AND (cr_folders.folder_id = acs_objects.object_id));


--
-- Name: fs_objects; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW fs_objects AS
    SELECT cr_items.item_id AS object_id, cr_items.live_revision, CASE WHEN ((cr_items.content_type)::text = 'content_folder'::text) THEN 'folder'::character varying WHEN ((cr_items.content_type)::text = 'content_extlink'::text) THEN 'url'::character varying ELSE cr_revisions.mime_type END AS type, CASE WHEN ((cr_items.content_type)::text = 'content_folder'::text) THEN (SELECT count(*) AS count FROM cr_items ci2 WHERE ((((ci2.content_type)::text = 'content_extlink'::text) OR ((ci2.content_type)::text = 'file_storage_object'::text)) AND ((ci2.tree_sortkey >= cr_items.tree_sortkey) AND (ci2.tree_sortkey <= tree_right(cr_items.tree_sortkey))))) ELSE (cr_revisions.content_length)::bigint END AS content_size, CASE WHEN ((cr_items.content_type)::text = 'content_folder'::text) THEN cr_folders.label WHEN ((cr_items.content_type)::text = 'content_extlink'::text) THEN cr_extlinks.label ELSE cr_items.name END AS name, cr_items.name AS file_upload_name, cr_revisions.title, cr_revisions.mime_type, acs_objects.last_modified, cr_extlinks.url, cr_items.parent_id, cr_items.name AS key, CASE WHEN ((cr_items.content_type)::text = 'content_folder'::text) THEN 0 ELSE 1 END AS sort_key, cr_mime_types.label AS pretty_type FROM (((((cr_items LEFT JOIN cr_extlinks ON ((cr_items.item_id = cr_extlinks.extlink_id))) LEFT JOIN cr_folders ON ((cr_items.item_id = cr_folders.folder_id))) LEFT JOIN cr_revisions ON ((cr_items.live_revision = cr_revisions.revision_id))) LEFT JOIN cr_mime_types ON (((cr_revisions.mime_type)::text = (cr_mime_types.mime_type)::text))) JOIN acs_objects ON ((cr_items.item_id = acs_objects.object_id)));


--
-- Name: fs_root_folders; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE fs_root_folders (
    package_id integer NOT NULL,
    folder_id integer
);


--
-- Name: fs_root_foldersi; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW fs_root_foldersi AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, fs_root_folders.package_id, fs_root_folders.folder_id FROM acs_objects, cr_revisions cr, cr_text, fs_root_folders WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = fs_root_folders.folder_id));


--
-- Name: fs_root_foldersx; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW fs_root_foldersx AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id, fs_root_folders.package_id, fs_root_folders.folder_id FROM acs_objects, cr_revisions cr, cr_items i, cr_text, fs_root_folders WHERE (((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id)) AND (acs_objects.object_id = fs_root_folders.folder_id));


--
-- Name: fs_rss_subscrs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE fs_rss_subscrs (
    subscr_id integer NOT NULL,
    folder_id integer NOT NULL,
    short_name character varying(80) NOT NULL,
    feed_title character varying(200) NOT NULL,
    max_items integer DEFAULT 15 NOT NULL,
    descend_p boolean DEFAULT true NOT NULL,
    include_revisions_p boolean DEFAULT false NOT NULL,
    enclosure_match_patterns character varying(200)
);


--
-- Name: fs_urls_full; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW fs_urls_full AS
    SELECT cr_extlinks.extlink_id AS url_id, cr_extlinks.url, cr_items.parent_id AS folder_id, cr_extlinks.label AS name, cr_extlinks.description, acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey FROM cr_extlinks, cr_items, acs_objects WHERE ((cr_extlinks.extlink_id = cr_items.item_id) AND (cr_items.item_id = acs_objects.object_id));


--
-- Name: general_comments; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE general_comments (
    comment_id integer NOT NULL,
    object_id integer,
    category character varying(1000)
);


--
-- Name: TABLE general_comments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE general_comments IS '
    Extends the acs_messages table to hold item level data.
';


--
-- Name: COLUMN general_comments.object_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN general_comments.object_id IS '
    The id of the object to associate message with
';


--
-- Name: COLUMN general_comments.category; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN general_comments.category IS '
    This feature is not complete. The purpose is to allow separation of 
    comments into categories.  
';


--
-- Name: general_objects; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE general_objects (
    object_id integer NOT NULL,
    on_which_table character varying(30) NOT NULL,
    on_what_id integer NOT NULL
);


--
-- Name: TABLE general_objects; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE general_objects IS '
 This table can be used to treat non-acs_objects as acs_objects for
 purposes of access control, categorization, etc.
';


--
-- Name: get_path_abs_cursor; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE get_path_abs_cursor (
    sid integer NOT NULL,
    pos integer NOT NULL,
    name text,
    parent_id integer,
    tree_level integer
);


--
-- Name: get_path_cursors; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE get_path_cursors (
    rel_cursor_pos integer,
    abs_cursor_pos integer
);


--
-- Name: get_path_rel_cursor; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE get_path_rel_cursor (
    sid integer NOT NULL,
    pos integer NOT NULL,
    parent_id integer,
    tree_level integer
);


--
-- Name: group_component_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW group_component_map AS
    SELECT group_element_map.group_id, group_element_map.element_id AS component_id, group_element_map.rel_id, group_element_map.container_id, group_element_map.rel_type FROM group_element_map WHERE ((group_element_map.ancestor_rel_type)::text = ('composition_rel'::character varying)::text);


--
-- Name: group_component_index; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW group_component_index AS
    SELECT group_component_map.group_id, group_component_map.component_id, group_component_map.rel_id, group_component_map.container_id, group_component_map.rel_type FROM group_component_map;


--
-- Name: group_distinct_member_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW group_distinct_member_map AS
    SELECT DISTINCT group_approved_member_map.group_id, group_approved_member_map.member_id FROM group_approved_member_map ORDER BY group_approved_member_map.group_id, group_approved_member_map.member_id;


--
-- Name: group_member_index; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW group_member_index AS
    SELECT group_member_map.group_id, group_member_map.member_id, group_member_map.rel_id, group_member_map.container_id, group_member_map.rel_type FROM group_member_map;


--
-- Name: groups; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE groups (
    group_id integer NOT NULL,
    group_name character varying(100) NOT NULL,
    join_policy character varying(30) DEFAULT 'open'::character varying NOT NULL,
    CONSTRAINT groups_join_policy_ck CHECK (((((join_policy)::text = ('open'::character varying)::text) OR ((join_policy)::text = ('needs approval'::character varying)::text)) OR ((join_policy)::text = ('closed'::character varying)::text)))
);


--
-- Name: group_rel_type_combos; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW group_rel_type_combos AS
    SELECT groups.group_id, comp_or_member_rel_types.rel_type FROM groups, comp_or_member_rel_types;


--
-- Name: group_rels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE group_rels (
    group_rel_id integer NOT NULL,
    rel_type character varying(100) NOT NULL,
    group_id integer NOT NULL
);


--
-- Name: TABLE group_rels; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE group_rels IS '
  Stores the relationship types available for use by each group. Only
  relationship types in this table are offered for adding
  relations. Note that there is no restriction that says groups can
  only have relationship types specified for their group type. The
  <code>group_type_rels</code> table just stores defaults for groups
  of a new type.
';


--
-- Name: group_type_rels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE group_type_rels (
    group_rel_type_id integer NOT NULL,
    rel_type character varying(100) NOT NULL,
    group_type character varying(100) NOT NULL
);


--
-- Name: TABLE group_type_rels; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE group_type_rels IS '
  Stores the default relationship types available for use by groups of
  a given type. We May want to generalize this table to object_types and
  put it in the relationships sql file, though there is no need to do so
  right now.
';


--
-- Name: group_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE group_types (
    group_type character varying(100) NOT NULL,
    default_join_policy character varying(30) DEFAULT 'open'::character varying NOT NULL,
    CONSTRAINT group_types_join_policy_ck CHECK (((((default_join_policy)::text = ('open'::character varying)::text) OR ((default_join_policy)::text = ('needs approval'::character varying)::text)) OR ((default_join_policy)::text = ('closed'::character varying)::text)))
);


--
-- Name: TABLE group_types; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE group_types IS '
 This table holds additional knowledge level attributes for the
 group type and its subtypes.
';


--
-- Name: guard_list; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE guard_list (
    session_id integer NOT NULL,
    rcnt integer NOT NULL,
    ky character varying(100)
);


--
-- Name: host_node_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE host_node_map (
    host character varying(200),
    node_id integer NOT NULL
);


--
-- Name: images; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE images (
    image_id integer NOT NULL,
    width integer,
    height integer
);


--
-- Name: imagesi; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW imagesi AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, images.image_id, images.width, images.height FROM acs_objects, cr_revisions cr, cr_text, images WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = images.image_id));


--
-- Name: imagesx; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW imagesx AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id, images.image_id, images.width, images.height FROM acs_objects, cr_revisions cr, cr_items i, cr_text, images WHERE (((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id)) AND (acs_objects.object_id = images.image_id));


--
-- Name: invalid_uninstalled_bindings; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW invalid_uninstalled_bindings AS
    SELECT c.contract_id, c.contract_name, i.impl_id, i.impl_name, i.impl_owner_name, i.impl_pretty_name FROM acs_sc_contracts c, acs_sc_impls i WHERE ((((c.contract_name)::text = (i.impl_contract_name)::text) AND (NOT (EXISTS (SELECT 1 FROM acs_sc_bindings b WHERE ((b.contract_id = c.contract_id) AND (b.impl_id = i.impl_id)))))) AND (EXISTS (SELECT 1 FROM acs_sc_operations o WHERE ((o.contract_id = c.contract_id) AND (NOT (EXISTS (SELECT 1 FROM acs_sc_impl_aliases a WHERE ((((a.impl_contract_name)::text = (c.contract_name)::text) AND (a.impl_id = i.impl_id)) AND ((a.impl_operation_name)::text = (o.operation_name)::text)))))))));


--
-- Name: journal_entries; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE journal_entries (
    journal_id integer NOT NULL,
    object_id integer,
    action character varying(100),
    action_pretty text,
    msg text
);


--
-- Name: TABLE journal_entries; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE journal_entries IS '
  Keeps track of actions performed on objects, e.g. banning a user,
  starting or finishing a workflow task, etc.
';


--
-- Name: lang_message_keys; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE lang_message_keys (
    message_key character varying(200) NOT NULL,
    package_key character varying(100) NOT NULL,
    description text
);


--
-- Name: lang_messages; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE lang_messages (
    message_key character varying(200) NOT NULL,
    package_key character varying(100) NOT NULL,
    locale character varying(30) NOT NULL,
    message text,
    upgrade_status character varying(30),
    creation_date timestamp with time zone DEFAULT now() NOT NULL,
    creation_user integer,
    deleted_p boolean DEFAULT false,
    sync_time timestamp with time zone,
    conflict_p boolean DEFAULT false,
    CONSTRAINT lang_messages_us_ck CHECK ((((((upgrade_status)::text = 'no_upgrade'::text) OR ((upgrade_status)::text = 'added'::text)) OR ((upgrade_status)::text = 'deleted'::text)) OR ((upgrade_status)::text = 'updated'::text)))
);


--
-- Name: lang_messages_audit; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE lang_messages_audit (
    message_key character varying(200) NOT NULL,
    package_key character varying(100) NOT NULL,
    locale character varying(30) NOT NULL,
    old_message text,
    comment_text text,
    overwrite_date timestamp with time zone DEFAULT now() NOT NULL,
    overwrite_user integer,
    deleted_p boolean DEFAULT false,
    sync_time timestamp with time zone,
    conflict_p boolean DEFAULT false,
    upgrade_status character varying(30),
    audit_id integer NOT NULL,
    CONSTRAINT lang_messages_us_ck CHECK ((((((upgrade_status)::text = 'no_upgrade'::text) OR ((upgrade_status)::text = 'added'::text)) OR ((upgrade_status)::text = 'deleted'::text)) OR ((upgrade_status)::text = 'updated'::text)))
);


--
-- Name: lang_messages_audit_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE lang_messages_audit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: lang_messages_tmp; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE lang_messages_tmp (
    message_key character varying(200),
    package_key character varying(100),
    locale character varying(30),
    message text,
    upgrade_status character varying(30)
);


--
-- Name: lang_translate_columns; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE lang_translate_columns (
    column_id integer NOT NULL,
    on_which_table character varying(50),
    on_what_column character varying(50),
    required_p boolean,
    short_p boolean
);


--
-- Name: lang_translation_registry; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE lang_translation_registry (
    on_which_table character varying(50) NOT NULL,
    on_what_id integer NOT NULL,
    locale character varying(30) NOT NULL
);


--
-- Name: lob_data; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE lob_data (
    lob_id integer NOT NULL,
    segment integer NOT NULL,
    byte_len integer NOT NULL,
    data bytea NOT NULL
);


--
-- Name: lob_sequence; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE lob_sequence
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: lobs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE lobs (
    lob_id integer NOT NULL,
    refcount integer DEFAULT 0 NOT NULL
);


--
-- Name: logger_entries; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE logger_entries (
    entry_id integer NOT NULL,
    project_id integer,
    variable_id integer,
    value real NOT NULL,
    time_stamp timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    description character varying(4000)
);


--
-- Name: TABLE logger_entries; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE logger_entries IS '
 This is the center piece of the logger datamodel that holds the actually reported
 data - namely numbers bound to points in time. Given the HR-XML
 Time and Reporting standard (see http://www.hr-xml.org) we considered allowing 
 for explicit start and end times. However, in the interest of simplicity
 for the initial release of the package we opted against this. The HR-XML spec talks
 about three categories of reports - time events, time intervals, and
 expenses incurred. Of those we are initially only supporting the latter two
 and for time intervals we don''t support any explicit start and end time (only a timestamp
 and a value). Support for those remaining HR-XML use cases can be added on later without
 much difficulty.
';


--
-- Name: logger_project_pkg_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE logger_project_pkg_map (
    project_id integer,
    package_id integer
);


--
-- Name: TABLE logger_project_pkg_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE logger_project_pkg_map IS '
  Each project can be mounted in multiple package instances.
';


--
-- Name: logger_project_var_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE logger_project_var_map (
    project_id integer NOT NULL,
    variable_id integer NOT NULL,
    primary_p boolean NOT NULL
);


--
-- Name: COLUMN logger_project_var_map.primary_p; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN logger_project_var_map.primary_p IS '
  Every project must have a primary variable which represents what we are 
  most interested in logging and reporting in that project 
  - typically time spent on various tasks.
';


--
-- Name: logger_projections; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE logger_projections (
    projection_id integer NOT NULL,
    name character varying(1000),
    description character varying(4000),
    project_id integer NOT NULL,
    variable_id integer NOT NULL,
    start_time timestamp with time zone NOT NULL,
    end_time timestamp with time zone NOT NULL,
    value numeric NOT NULL
);


--
-- Name: TABLE logger_projections; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE logger_projections IS '
  This table allows a project admin to specify expected or targeted logging values
  over a particular time period.
';


--
-- Name: COLUMN logger_projections.value; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN logger_projections.value IS '
  For additive variables the projection value will represent the expected or targeted 
  sum of entries during the time range and for non-additive variables it will 
  represent an average.
';


--
-- Name: logger_projections_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE logger_projections_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: logger_projects; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE logger_projects (
    project_id integer NOT NULL,
    name character varying(1000),
    description character varying(4000),
    active_p boolean DEFAULT true NOT NULL,
    project_lead integer NOT NULL
);


--
-- Name: TABLE logger_projects; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE logger_projects IS '
  Log entries are grouped by projects. Once we have a dedicated
  project management package for OpenACS this table will be superseeded by
  tables in that package. In order to make such a change easier in the future
  we are not referencing the logger_projects table directly in the logger datamodel
  but instead reference acs_objects.
';


--
-- Name: logger_variables; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE logger_variables (
    variable_id integer NOT NULL,
    name character varying(200),
    unit character varying(200),
    type character varying(50) DEFAULT 'additive'::character varying NOT NULL,
    package_id integer,
    CONSTRAINT logger_variables_type_ck CHECK ((((type)::text = ('additive'::character varying)::text) OR ((type)::text = ('non-additive'::character varying)::text)))
);


--
-- Name: COLUMN logger_variables.type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN logger_variables.type IS '
  Indicates if entries of this variable should be added together or not. 
  Examples of additive variables are time and money spent at different times during
  a project. A non-additive variable would be the amount of money in a bank account.
';


--
-- Name: COLUMN logger_variables.package_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN logger_variables.package_id IS '
  The id of the package that the variable was created in.
';


--
-- Name: na_aggregators; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE na_aggregators (
    aggregator_id integer NOT NULL,
    aggregator_name character varying(100) NOT NULL,
    description text,
    package_id integer NOT NULL,
    maintainer_id integer NOT NULL,
    public_p boolean DEFAULT true,
    number_shown integer DEFAULT 100,
    aggregator_bottom integer
);


--
-- Name: na_items; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE na_items (
    item_id integer DEFAULT nextval(('na_items_item_id_seq'::text)::regclass) NOT NULL,
    source_id integer NOT NULL,
    link character varying(500),
    guid character varying(500),
    original_guid character varying(500),
    permalink_p boolean DEFAULT true,
    title character varying(500),
    author character varying(100),
    comment_page character varying(200),
    description text,
    content_encoded text,
    creation_date timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone,
    pub_date timestamp with time zone
);


--
-- Name: na_items_item_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE na_items_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: na_presubscribed_feeds; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE na_presubscribed_feeds (
    source_id integer NOT NULL,
    package_id integer NOT NULL
);


--
-- Name: na_presubscribed_feeds_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE na_presubscribed_feeds_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: na_purges; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE na_purges (
    purge_id integer NOT NULL,
    top integer NOT NULL,
    bottom integer NOT NULL,
    aggregator_id integer NOT NULL,
    purge_date timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone
);


--
-- Name: na_purges_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE na_purges_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: na_saved_items; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE na_saved_items (
    item_id integer NOT NULL,
    aggregator_id integer NOT NULL
);


--
-- Name: na_sources; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE na_sources (
    source_id integer NOT NULL,
    feed_url character varying(500) NOT NULL,
    link character varying(500),
    title character varying(500),
    description character varying(500),
    updates integer DEFAULT 0,
    last_scanned timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone,
    last_modified character varying(100),
    last_modified_stamp timestamp with time zone,
    last_scan_ok_p boolean DEFAULT true,
    stacktrace text,
    rss_source text,
    listed_p boolean DEFAULT true
);


--
-- Name: na_subscriptions; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE na_subscriptions (
    aggregator_id integer NOT NULL,
    source_id integer NOT NULL,
    source_title character varying(100),
    show_description_p boolean DEFAULT true NOT NULL,
    creation_date timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone
);


--
-- Name: na_user_preferences; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE na_user_preferences (
    user_id integer NOT NULL,
    default_aggregator integer,
    package_id integer NOT NULL
);


--
-- Name: na_weblogs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE na_weblogs (
    weblog_id integer NOT NULL,
    package_id integer NOT NULL,
    user_id integer NOT NULL,
    weblog_name character varying(100) NOT NULL,
    blog_type character varying(100) NOT NULL,
    base_url character varying(500) NOT NULL,
    server character varying(500),
    port integer,
    path character varying(100),
    blogid integer,
    username character varying(200),
    password character varying(200)
);


--
-- Name: news_item_full_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW news_item_full_active AS
    SELECT ci.item_id, cn.package_id, cr.revision_id, cr.title AS publish_title, cn.lead AS publish_lead, cr.content AS publish_body, CASE WHEN ((cr.mime_type)::text = 'text/html'::text) THEN 't'::text ELSE 'f'::text END AS html_p, cr.publish_date, cn.archive_date, news__status(cr.publish_date, cn.archive_date) AS status, ci.name AS item_name, ps.person_id AS creator_id, (((ps.first_names)::text || ' '::text) || (ps.last_name)::text) AS item_creator FROM cr_items ci, cr_revisions cr, cr_news cn, acs_objects ao, persons ps WHERE (((((cr.item_id = ci.item_id) AND ((cr.revision_id = ci.live_revision) OR ((ci.live_revision IS NULL) AND (cr.revision_id = content_item__get_latest_revision(ci.item_id))))) AND (cr.revision_id = cn.news_id)) AND (ci.item_id = ao.object_id)) AND (ao.creation_user = ps.person_id));


--
-- Name: news_item_revisions; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW news_item_revisions AS
    SELECT cr.item_id, cr.revision_id, ci.live_revision, cr.title AS publish_title, cn.lead AS publish_lead, cr.content AS publish_body, cr.publish_date, cn.archive_date, cr.description AS log_entry, CASE WHEN ((cr.mime_type)::text = 'text/html'::text) THEN 't'::text ELSE 'f'::text END AS html_p, cr.mime_type, cn.package_id, (ao.creation_date)::date AS creation_date, news__status(cr.publish_date, cn.archive_date) AS status, CASE WHEN (EXISTS (SELECT 1 FROM cr_revisions cr2 WHERE ((cr2.revision_id = cn.news_id) AND (cr2.publish_date IS NULL)))) THEN 1 ELSE 0 END AS approval_needed_p, (((ps.first_names)::text || ' '::text) || (ps.last_name)::text) AS item_creator, ao.creation_user, ao.creation_ip, ci.name AS item_name FROM cr_revisions cr, cr_news cn, cr_items ci, acs_objects ao, persons ps WHERE ((((cr.revision_id = ao.object_id) AND (cr.revision_id = cn.news_id)) AND (ci.item_id = cr.item_id)) AND (ao.creation_user = ps.person_id));


--
-- Name: news_item_unapproved; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW news_item_unapproved AS
    SELECT cr.revision_id, ci.name AS item_name, (((ps.first_names)::text || (' '::character varying)::text) || (ps.last_name)::text) AS item_creator, ao.creation_ip AS item_creation_ip, date(ao.creation_date) AS creation_date FROM cr_revisions cr, cr_items ci, acs_objects ao, persons ps WHERE (((ci.item_id = cr.item_id) AND (cr.revision_id = ao.object_id)) AND (ao.creation_user = ps.person_id));


--
-- Name: news_items_approved; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW news_items_approved AS
    SELECT ci.item_id, cn.package_id, cr.title AS publish_title, cn.lead AS publish_lead, cr.content AS publish_body, CASE WHEN ((cr.mime_type)::text = 'text/html'::text) THEN 't'::text ELSE 'f'::text END AS html_p, to_char(cr.publish_date, 'Mon dd, yyyy'::text) AS pretty_publish_date, cr.publish_date, ao.creation_user, (((ps.first_names)::text || ' '::text) || (ps.last_name)::text) AS item_creator, (cn.archive_date)::date AS archive_date FROM cr_items ci, cr_revisions cr, cr_news cn, acs_objects ao, persons ps WHERE (((((ci.item_id = cr.item_id) AND (ci.live_revision = cr.revision_id)) AND (cr.revision_id = cn.news_id)) AND (cr.revision_id = ao.object_id)) AND (ao.creation_user = ps.person_id));


--
-- Name: news_items_live_or_submitted; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW news_items_live_or_submitted AS
    SELECT ci.item_id, cn.news_id, cn.package_id, cr.publish_date, cn.archive_date, cr.title AS publish_title, cn.lead AS publish_lead, cr.content AS publish_body, CASE WHEN ((cr.mime_type)::text = 'text/html'::text) THEN 't'::text ELSE 'f'::text END AS html_p, ao.creation_user, (((ps.first_names)::text || ' '::text) || (ps.last_name)::text) AS item_creator, (ao.creation_date)::date AS creation_date, ci.live_revision, news__status(cr.publish_date, cn.archive_date) AS status FROM cr_items ci, cr_revisions cr, cr_news cn, acs_objects ao, persons ps WHERE ((((((ci.item_id = cr.item_id) AND (ci.live_revision = cr.revision_id)) AND (cr.revision_id = cn.news_id)) AND (cr.revision_id = ao.object_id)) AND (ao.creation_user = ps.person_id)) OR ((((((ci.live_revision IS NULL) AND (ci.item_id = cr.item_id)) AND (cr.revision_id = content_item__get_latest_revision(ci.item_id))) AND (cr.revision_id = cn.news_id)) AND (cr.revision_id = ao.object_id)) AND (ao.creation_user = ps.person_id)));


--
-- Name: news_items_unapproved; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW news_items_unapproved AS
    SELECT ci.item_id, cr.title AS publish_title, cn.lead AS publish_lead, cn.package_id, (ao.creation_date)::date AS creation_date, (((ps.first_names)::text || ' '::text) || (ps.last_name)::text) AS item_creator FROM cr_items ci, cr_revisions cr, cr_news cn, acs_objects ao, persons ps WHERE ((((((cr.revision_id = ao.object_id) AND (ao.creation_user = ps.person_id)) AND (cr.revision_id = content_item__get_live_revision(ci.item_id))) AND (cr.revision_id = cn.news_id)) AND (cr.item_id = ci.item_id)) AND (cr.publish_date IS NULL));


--
-- Name: notification_delivery_methods; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notification_delivery_methods (
    delivery_method_id integer NOT NULL,
    sc_impl_id integer NOT NULL,
    short_name character varying(100) NOT NULL,
    pretty_name character varying(200) NOT NULL
);


--
-- Name: notification_email_hold; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notification_email_hold (
    reply_id integer NOT NULL,
    to_addr text,
    headers text,
    body text
);


--
-- Name: notification_intervals; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notification_intervals (
    interval_id integer NOT NULL,
    name character varying(200) NOT NULL,
    n_seconds integer NOT NULL
);


--
-- Name: notification_replies; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notification_replies (
    reply_id integer NOT NULL,
    object_id integer NOT NULL,
    type_id integer NOT NULL,
    from_user integer NOT NULL,
    subject character varying(100),
    content text,
    reply_date timestamp with time zone
);


--
-- Name: notification_requests; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notification_requests (
    request_id integer NOT NULL,
    type_id integer,
    user_id integer,
    object_id integer,
    interval_id integer NOT NULL,
    delivery_method_id integer NOT NULL,
    format character varying(100) DEFAULT 'text'::character varying,
    dynamic_p boolean DEFAULT false,
    CONSTRAINT notif_request_format_ch CHECK ((((format)::text = ('text'::character varying)::text) OR ((format)::text = ('html'::character varying)::text)))
);


--
-- Name: notification_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notification_types (
    type_id integer NOT NULL,
    sc_impl_id integer NOT NULL,
    short_name character varying(100) NOT NULL,
    pretty_name character varying(200) NOT NULL,
    description character varying(2000)
);


--
-- Name: notification_types_del_methods; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notification_types_del_methods (
    type_id integer NOT NULL,
    delivery_method_id integer NOT NULL
);


--
-- Name: notification_types_intervals; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notification_types_intervals (
    type_id integer NOT NULL,
    interval_id integer NOT NULL
);


--
-- Name: notification_user_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notification_user_map (
    notification_id integer NOT NULL,
    user_id integer NOT NULL,
    sent_date timestamp with time zone
);


--
-- Name: notifications; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE notifications (
    notification_id integer NOT NULL,
    type_id integer,
    object_id integer,
    notif_date timestamp with time zone NOT NULL,
    response_id integer,
    notif_subject character varying(1000),
    notif_text text,
    notif_html text,
    notif_user integer
);


--
-- Name: orphan_implementations; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW orphan_implementations AS
    SELECT i.impl_id, i.impl_name, i.impl_owner_name, i.impl_contract_name, i.impl_pretty_name FROM acs_sc_impls i WHERE ((NOT (EXISTS (SELECT 1 FROM acs_sc_bindings b WHERE (b.impl_id = i.impl_id)))) AND (NOT (EXISTS (SELECT 1 FROM acs_sc_contracts c WHERE ((c.contract_name)::text = (i.impl_contract_name)::text)))));


--
-- Name: pages; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE pages (
    package_id integer NOT NULL,
    content text NOT NULL
);


--
-- Name: recurrences; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE recurrences (
    recurrence_id integer NOT NULL,
    interval_type integer NOT NULL,
    every_nth_interval integer,
    days_of_week character varying(20),
    recur_until timestamp with time zone,
    db_populated_until timestamp with time zone,
    custom_func character varying(255),
    CONSTRAINT recurs_every_nth_interval_ck CHECK ((every_nth_interval > 0))
);


--
-- Name: TABLE recurrences; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE recurrences IS '
    Desribes how an event recurs.
';


--
-- Name: COLUMN recurrences.interval_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN recurrences.interval_type IS '
    One of day, week, month_by_date, month_by_day, last_of_month, year, custom.
';


--
-- Name: COLUMN recurrences.every_nth_interval; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN recurrences.every_nth_interval IS '
    Indicates how many of the given intervals between recurrences.
';


--
-- Name: COLUMN recurrences.days_of_week; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN recurrences.days_of_week IS '
    For weekly recurrences, stores which days of the week the event recurs on.
';


--
-- Name: COLUMN recurrences.recur_until; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN recurrences.recur_until IS '
    Indicates when this event should stop recurring.  Null indicates
    recur indefinitely.
';


--
-- Name: COLUMN recurrences.db_populated_until; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN recurrences.db_populated_until IS '
    Indicates the date of the last recurrence added. Used to determine if more
    recurrences need to be added.
';


--
-- Name: COLUMN recurrences.custom_func; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN recurrences.custom_func IS '
    Stores the name of a PL/SQL function that can be called to generate dates
    for special recurrences.
';


--
-- Name: partially_populated_event_ids; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW partially_populated_event_ids AS
    SELECT min(e.event_id) AS event_id, r.db_populated_until FROM acs_events e, recurrences r WHERE ((e.recurrence_id = r.recurrence_id) AND ((r.recur_until > r.db_populated_until) OR (r.recur_until IS NULL))) GROUP BY r.recurrence_id, r.db_populated_until;


--
-- Name: VIEW partially_populated_event_ids; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW partially_populated_event_ids IS '
    This view returns the first event_id and db_populated_until column
    for any recurrences that have not been completely populated.
';


--
-- Name: partially_populated_events; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW partially_populated_events AS
    SELECT e.event_id, e.timespan_id, e.activity_id, e.recurrence_id, p.db_populated_until FROM acs_events e, partially_populated_event_ids p WHERE (e.event_id = p.event_id);


--
-- Name: VIEW partially_populated_events; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW partially_populated_events IS '
    This view returns information about recurring events that have not been
    completely populated (such as indefinitely recurring events.)
';


--
-- Name: rel_segment_group_rel_type_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_segment_group_rel_type_map AS
    SELECT s.segment_id, gcm.component_id AS group_id, acs_rel_types.rel_type FROM rel_segments s, (SELECT group_component_map.group_id, group_component_map.component_id FROM group_component_map UNION ALL SELECT groups.group_id, groups.group_id AS component_id FROM groups) gcm, acs_rel_types, acs_object_types o1, acs_object_types o2 WHERE ((((s.group_id = gcm.group_id) AND ((s.rel_type)::text = (o2.object_type)::text)) AND ((o1.object_type)::text = (acs_rel_types.rel_type)::text)) AND ((o1.tree_sortkey >= o2.tree_sortkey) AND (o1.tree_sortkey <= tree_right(o2.tree_sortkey))));


--
-- Name: rc_all_constraints; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rc_all_constraints AS
    SELECT group_rel_types.group_id, group_rel_types.rel_type, rel_constraints.rel_segment, rel_constraints.rel_side, rel_constraints.required_rel_segment FROM rel_constraints, rel_segment_group_rel_type_map group_rel_types, rel_segments req_seg WHERE (((rel_constraints.rel_segment = group_rel_types.segment_id) AND (rel_constraints.required_rel_segment = req_seg.segment_id)) AND (NOT ((req_seg.group_id = group_rel_types.group_id) AND ((req_seg.rel_type)::text = (group_rel_types.rel_type)::text))));


--
-- Name: rc_required_rel_segments; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rc_required_rel_segments AS
    SELECT DISTINCT rc_all_constraints.group_id, rc_all_constraints.rel_type, rc_all_constraints.required_rel_segment FROM rc_all_constraints WHERE (rc_all_constraints.rel_side = 'two'::bpchar) ORDER BY rc_all_constraints.group_id, rc_all_constraints.rel_type, rc_all_constraints.required_rel_segment;


--
-- Name: parties_in_required_segs; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW parties_in_required_segs AS
    SELECT required_segs.group_id, required_segs.rel_type, seg_parties.party_id, seg_parties.segment_id, count(*) AS num_matching_segs FROM rc_required_rel_segments required_segs, rel_segment_party_map seg_parties WHERE (required_segs.required_rel_segment = seg_parties.segment_id) GROUP BY required_segs.group_id, required_segs.rel_type, seg_parties.party_id, seg_parties.segment_id;


--
-- Name: party_element_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW party_element_map AS
    ((SELECT DISTINCT group_element_map.group_id AS party_id, group_element_map.element_id FROM group_element_map ORDER BY group_element_map.group_id, group_element_map.element_id) UNION (SELECT DISTINCT rel_segment_party_map.segment_id AS party_id, rel_segment_party_map.party_id AS element_id FROM rel_segment_party_map ORDER BY rel_segment_party_map.segment_id, rel_segment_party_map.party_id)) UNION SELECT parties.party_id, parties.party_id AS element_id FROM parties;


--
-- Name: party_names; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW party_names AS
    SELECT p.party_id, CASE WHEN (groups.group_id IS NULL) THEN (CASE WHEN (persons.person_id IS NULL) THEN (p.email)::text ELSE (((persons.first_names)::text || (' '::character varying)::text) || (persons.last_name)::text) END)::character varying ELSE groups.group_name END AS party_name FROM ((parties p LEFT JOIN groups ON ((p.party_id = groups.group_id))) LEFT JOIN persons ON ((p.party_id = persons.person_id)));


--
-- Name: pinds_blog_categories; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE pinds_blog_categories (
    category_id integer NOT NULL,
    package_id integer,
    name character varying(4000) NOT NULL,
    short_name character varying(4000) NOT NULL
);


--
-- Name: pinds_blog_entries; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE pinds_blog_entries (
    entry_id integer NOT NULL,
    package_id integer,
    title character varying(500),
    title_url character varying(500),
    category_id integer,
    content character varying(32000),
    content_format character varying(50) DEFAULT 'text/html'::character varying NOT NULL,
    entry_date timestamp with time zone,
    draft_p character(1) DEFAULT 'f'::bpchar,
    deleted_p character(1) DEFAULT 'f'::bpchar,
    CONSTRAINT pinds_blog_entries_deleted_ck CHECK (((deleted_p = 't'::bpchar) OR (deleted_p = 'f'::bpchar))),
    CONSTRAINT pinds_blog_entries_draft_ck CHECK (((draft_p = 't'::bpchar) OR (draft_p = 'f'::bpchar)))
);


--
-- Name: previous_place_list; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE previous_place_list (
    session_id integer NOT NULL,
    rcnt integer NOT NULL,
    ky character varying(100)
);


--
-- Name: rc_all_constraints_view; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rc_all_constraints_view AS
    SELECT rc_all_constraints.group_id, rc_all_constraints.rel_type, rc_all_constraints.rel_segment, rc_all_constraints.rel_side, rc_all_constraints.required_rel_segment FROM rc_all_constraints WHERE (rc_all_constraints.rel_side = 'one'::bpchar);


--
-- Name: rc_all_distinct_constraints; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rc_all_distinct_constraints AS
    SELECT DISTINCT rc_all_constraints.group_id, rc_all_constraints.rel_type, rc_all_constraints.rel_segment, rc_all_constraints.rel_side, rc_all_constraints.required_rel_segment FROM rc_all_constraints ORDER BY rc_all_constraints.group_id, rc_all_constraints.rel_type, rc_all_constraints.rel_segment, rc_all_constraints.rel_side, rc_all_constraints.required_rel_segment;


--
-- Name: total_num_required_segs; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW total_num_required_segs AS
    SELECT rc_required_rel_segments.group_id, rc_required_rel_segments.rel_type, count(*) AS total FROM rc_required_rel_segments GROUP BY rc_required_rel_segments.group_id, rc_required_rel_segments.rel_type;


--
-- Name: rc_parties_in_required_segs; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rc_parties_in_required_segs AS
    SELECT parties_in_required_segs.group_id, parties_in_required_segs.rel_type, parties_in_required_segs.party_id FROM parties_in_required_segs, total_num_required_segs WHERE (((parties_in_required_segs.group_id = total_num_required_segs.group_id) AND ((parties_in_required_segs.rel_type)::text = (total_num_required_segs.rel_type)::text)) AND (parties_in_required_segs.num_matching_segs = total_num_required_segs.total)) UNION ALL SELECT group_rel_type_combos.group_id, group_rel_type_combos.rel_type, parties.party_id FROM (rc_required_rel_segments RIGHT JOIN group_rel_type_combos ON (((rc_required_rel_segments.group_id = group_rel_type_combos.group_id) AND ((rc_required_rel_segments.rel_type)::text = (group_rel_type_combos.rel_type)::text)))), parties WHERE (rc_required_rel_segments.group_id IS NULL);


--
-- Name: rc_segment_required_seg_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE rc_segment_required_seg_map (
    rel_segment integer NOT NULL,
    rel_side character(3) NOT NULL,
    required_rel_segment integer NOT NULL,
    CONSTRAINT rc_rel_side_ck CHECK (((rel_side = 'one'::bpchar) OR (rel_side = 'two'::bpchar)))
);


--
-- Name: rc_segment_dependency_levels; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rc_segment_dependency_levels AS
    SELECT rc_segment_required_seg_map.rel_segment AS segment_id, count(*) AS dependency_level FROM rc_segment_required_seg_map WHERE (rc_segment_required_seg_map.rel_side = 'two'::bpchar) GROUP BY rc_segment_required_seg_map.rel_segment;


--
-- Name: side_one_constraints; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW side_one_constraints AS
    SELECT required_segs.group_id, required_segs.rel_type, count(*) AS num_satisfied FROM rc_all_constraints required_segs, rel_segment_party_map map WHERE (((required_segs.rel_side = 'one'::bpchar) AND (required_segs.required_rel_segment = map.segment_id)) AND (required_segs.group_id = map.party_id)) GROUP BY required_segs.group_id, required_segs.rel_type;


--
-- Name: total_side_one_constraints; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW total_side_one_constraints AS
    SELECT rc_all_constraints.group_id, rc_all_constraints.rel_type, count(*) AS total FROM rc_all_constraints WHERE (rc_all_constraints.rel_side = 'one'::bpchar) GROUP BY rc_all_constraints.group_id, rc_all_constraints.rel_type;


--
-- Name: rc_valid_rel_types; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rc_valid_rel_types AS
    SELECT side_one_constraints.group_id, side_one_constraints.rel_type FROM side_one_constraints, total_side_one_constraints WHERE (((side_one_constraints.group_id = total_side_one_constraints.group_id) AND ((side_one_constraints.rel_type)::text = (total_side_one_constraints.rel_type)::text)) AND (side_one_constraints.num_satisfied = total_side_one_constraints.total)) UNION ALL SELECT group_rel_type_combos.group_id, group_rel_type_combos.rel_type FROM (rc_all_constraints_view RIGHT JOIN group_rel_type_combos ON (((rc_all_constraints_view.group_id = group_rel_type_combos.group_id) AND ((rc_all_constraints_view.rel_type)::text = (group_rel_type_combos.rel_type)::text)))) WHERE (rc_all_constraints_view.group_id IS NULL);


--
-- Name: rc_violations_by_removing_rel; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rc_violations_by_removing_rel AS
    SELECT r.rel_type AS viol_rel_type, r.rel_id AS viol_rel_id, r.object_id_one AS viol_object_id_one, r.object_id_two AS viol_object_id_two, s.rel_id, cons.constraint_id, cons.constraint_name, map.segment_id, map.party_id, map.group_id, map.container_id, map.ancestor_rel_type FROM acs_rels r, rel_segment_party_map map, rel_constraints cons, (SELECT s.segment_id, r.rel_id, r.object_id_two FROM rel_segments s, acs_rels r WHERE ((r.object_id_one = s.group_id) AND ((r.rel_type)::text = (s.rel_type)::text))) s WHERE (((((map.party_id = r.object_id_two) AND (map.rel_id = r.rel_id)) AND (r.object_id_two = s.object_id_two)) AND (cons.rel_segment = map.segment_id)) AND (cons.required_rel_segment = s.segment_id));


--
-- Name: recurrence_interval_types; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE recurrence_interval_types (
    interval_type integer NOT NULL,
    interval_name character varying(50) NOT NULL
);


--
-- Name: recurrence_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW recurrence_seq AS
    SELECT nextval(('recurrence_sequence'::text)::regclass) AS nextval;


--
-- Name: recurrence_sequence; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE recurrence_sequence
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: registered_users; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW registered_users AS
    SELECT p.email, p.url, pe.first_names, pe.last_name, u.user_id, u.password, u.salt, u.screen_name, u.priv_name, u.priv_email, u.email_verified_p, u.email_bouncing_p, u.no_alerts_until, u.last_visit, u.second_to_last_visit, u.n_sessions, u.password_question, u.password_answer, u.password_changed_date, u.authority_id, u.username, u.auth_token, mr.member_state FROM parties p, persons pe, users u, group_member_map m, membership_rels mr WHERE (((((((((p.party_id = pe.person_id) AND (pe.person_id = u.user_id)) AND (u.user_id = m.member_id)) AND (m.rel_id = mr.rel_id)) AND (m.group_id = acs__magic_object_id('registered_users'::character varying))) AND (m.container_id = m.group_id)) AND ((m.rel_type)::text = 'membership_rel'::text)) AND ((mr.member_state)::text = 'approved'::text)) AND (u.email_verified_p = true));


--
-- Name: rel_constraints_violated_one; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_constraints_violated_one AS
    SELECT c.constraint_id, c.constraint_name, c.rel_id, c.container_id, c.party_id, c.rel_type, c.rel_segment, c.rel_side, c.required_rel_segment FROM (constrained_rels1 c LEFT JOIN rel_segment_party_map rspm ON (((rspm.segment_id = c.required_rel_segment) AND (rspm.party_id = c.container_id)))) WHERE (rspm.party_id IS NULL);


--
-- Name: rel_constraints_violated_two; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_constraints_violated_two AS
    SELECT c.constraint_id, c.constraint_name, c.rel_id, c.container_id, c.party_id, c.rel_type, c.rel_segment, c.rel_side, c.required_rel_segment FROM (constrained_rels2 c LEFT JOIN rel_segment_party_map rspm ON (((rspm.segment_id = c.required_rel_segment) AND (rspm.party_id = c.party_id)))) WHERE (rspm.party_id IS NULL);


--
-- Name: rel_seg_distinct_member_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_seg_distinct_member_map AS
    SELECT DISTINCT rel_seg_approved_member_map.segment_id, rel_seg_approved_member_map.member_id FROM rel_seg_approved_member_map ORDER BY rel_seg_approved_member_map.segment_id, rel_seg_approved_member_map.member_id;


--
-- Name: rel_segment_distinct_party_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_segment_distinct_party_map AS
    SELECT DISTINCT rel_segment_party_map.segment_id, rel_segment_party_map.party_id, rel_segment_party_map.ancestor_rel_type FROM rel_segment_party_map ORDER BY rel_segment_party_map.segment_id, rel_segment_party_map.party_id, rel_segment_party_map.ancestor_rel_type;


--
-- Name: rel_segment_member_map; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_segment_member_map AS
    SELECT rel_segment_party_map.segment_id, rel_segment_party_map.party_id AS member_id, rel_segment_party_map.rel_id, rel_segment_party_map.rel_type, rel_segment_party_map.group_id, rel_segment_party_map.container_id FROM rel_segment_party_map WHERE ((rel_segment_party_map.ancestor_rel_type)::text = ('membership_rel'::character varying)::text);


--
-- Name: rel_types_valid_obj_one_types; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_types_valid_obj_one_types AS
    SELECT rt.rel_type, th.object_type FROM acs_rel_types rt, (SELECT acs_object_type_supertype_map.object_type, acs_object_type_supertype_map.ancestor_type FROM acs_object_type_supertype_map UNION ALL SELECT acs_object_types.object_type, acs_object_types.object_type AS ancestor_type FROM acs_object_types) th WHERE ((rt.object_type_one)::text = (th.ancestor_type)::text);


--
-- Name: rel_types_valid_obj_two_types; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rel_types_valid_obj_two_types AS
    SELECT rt.rel_type, th.object_type FROM acs_rel_types rt, (SELECT acs_object_type_supertype_map.object_type, acs_object_type_supertype_map.ancestor_type FROM acs_object_type_supertype_map UNION ALL SELECT acs_object_types.object_type, acs_object_types.object_type AS ancestor_type FROM acs_object_types) th WHERE ((rt.object_type_two)::text = (th.ancestor_type)::text);


--
-- Name: rl_resource_category; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE rl_resource_category (
    category_id integer NOT NULL,
    category_type integer,
    short_name character varying(100),
    description character varying(1000)
);


--
-- Name: rl_resource_category_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE rl_resource_category_map (
    resource_item_id integer NOT NULL,
    category_id integer NOT NULL
);


--
-- Name: TABLE rl_resource_category_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE rl_resource_category_map IS '
  Keeps track of which resources are within each category
';


--
-- Name: rl_resource_category_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE rl_resource_category_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: rl_resource_category_type; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE rl_resource_category_type (
    category_id integer NOT NULL,
    short_name character varying(100),
    description character varying(1000),
    ordering integer
);


--
-- Name: TABLE rl_resource_category_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE rl_resource_category_type IS '
  The actual category for the resource. For a category type of Country, this might be
  Canada, for example.
';


--
-- Name: rl_resource_category_type_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE rl_resource_category_type_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: rl_resources; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE rl_resources (
    resource_item_id integer NOT NULL,
    resource_number integer,
    approved_p character(1),
    CONSTRAINT rl_resources_approved_ck CHECK (((approved_p = 't'::bpchar) OR (approved_p = 'f'::bpchar)))
);


--
-- Name: rl_resources_number_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE rl_resources_number_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: rl_resources_revisions; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE rl_resources_revisions (
    resource_revision_id integer NOT NULL
);


--
-- Name: rl_resources_revisionsi; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rl_resources_revisionsi AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, rl_resources_revisions.resource_revision_id FROM acs_objects, cr_revisions cr, cr_text, rl_resources_revisions WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = rl_resources_revisions.resource_revision_id));


--
-- Name: rl_resources_revisionsx; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW rl_resources_revisionsx AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id, rl_resources_revisions.resource_revision_id FROM acs_objects, cr_revisions cr, cr_items i, cr_text, rl_resources_revisions WHERE (((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id)) AND (acs_objects.object_id = rl_resources_revisions.resource_revision_id));


--
-- Name: rss_gen_subscrs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE rss_gen_subscrs (
    subscr_id integer NOT NULL,
    impl_id integer NOT NULL,
    summary_context_id character varying(100) NOT NULL,
    timeout integer NOT NULL,
    lastbuild timestamp with time zone,
    last_ttb integer,
    channel_title character varying(200),
    channel_link character varying(1000)
);


--
-- Name: TABLE rss_gen_subscrs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE rss_gen_subscrs IS '
   Table for storing the different parts of the site we will generate
   summaries for.
';


--
-- Name: COLUMN rss_gen_subscrs.subscr_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rss_gen_subscrs.subscr_id IS '
   Subscriptions are ACS objects.  They will typically inherit
   permission from a package instance.
';


--
-- Name: COLUMN rss_gen_subscrs.impl_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rss_gen_subscrs.impl_id IS '
   The implementation which will provide summary information and
   update status.
';


--
-- Name: COLUMN rss_gen_subscrs.summary_context_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rss_gen_subscrs.summary_context_id IS '
   An identifier unique to the site section whose content is to be
   summarized.  A context identifier need not be a package instance
   id.  We will suggest a convention but the format is entirely up to
   the implementors.
';


--
-- Name: COLUMN rss_gen_subscrs.timeout; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rss_gen_subscrs.timeout IS '
   The minimum number of seconds between summary builds. 
';


--
-- Name: COLUMN rss_gen_subscrs.lastbuild; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rss_gen_subscrs.lastbuild IS '
   Accounting column for use by rss generation service.
';


--
-- Name: COLUMN rss_gen_subscrs.last_ttb; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rss_gen_subscrs.last_ttb IS '
   Another accounting column.  The last time to build (in seconds).
';


--
-- Name: COLUMN rss_gen_subscrs.channel_title; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rss_gen_subscrs.channel_title IS '
   Used for display purposes.
';


--
-- Name: COLUMN rss_gen_subscrs.channel_link; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN rss_gen_subscrs.channel_link IS '
   Used for display purposes.
';


SET default_with_oids = false;

--
-- Name: schema_migrations; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE schema_migrations (
    version character varying(255) NOT NULL
);


SET default_with_oids = true;

--
-- Name: search_observer_queue; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE search_observer_queue (
    object_id integer,
    event_date timestamp with time zone DEFAULT now(),
    event character varying(6),
    CONSTRAINT search_observer_queue_event_ck CHECK (((((event)::text = ('INSERT'::character varying)::text) OR ((event)::text = ('DELETE'::character varying)::text)) OR ((event)::text = ('UPDATE'::character varying)::text)))
);


--
-- Name: sec_id_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW sec_id_seq AS
    SELECT nextval(('t_sec_id_seq'::text)::regclass) AS nextval;


--
-- Name: sec_security_token_id_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW sec_security_token_id_seq AS
    SELECT nextval(('t_sec_security_token_id_seq'::text)::regclass) AS nextval;


--
-- Name: sec_session_properties; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE sec_session_properties (
    session_id integer NOT NULL,
    module character varying(50) NOT NULL,
    property_name character varying(50) NOT NULL,
    property_value text,
    secure_p boolean,
    last_hit integer NOT NULL
);


--
-- Name: secret_tokens; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE secret_tokens (
    token_id integer NOT NULL,
    token character(40),
    token_timestamp timestamp with time zone
);


--
-- Name: site_node_object_mappings; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE site_node_object_mappings (
    object_id integer NOT NULL,
    node_id integer NOT NULL
);


--
-- Name: site_nodes; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE site_nodes (
    node_id integer NOT NULL,
    parent_id integer,
    name character varying(100),
    directory_p boolean NOT NULL,
    pattern_p boolean DEFAULT false NOT NULL,
    object_id integer,
    tree_sortkey bit varying,
    CONSTRAINT site_nodes_name_ck CHECK (((name)::text !~~ '%/%'::text))
);


--
-- Name: site_nodes_selection; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE site_nodes_selection (
    node_id integer NOT NULL,
    view_p boolean
);


--
-- Name: subsite_callbacks; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE subsite_callbacks (
    callback_id integer NOT NULL,
    event_type character varying(100) NOT NULL,
    object_type character varying(100) NOT NULL,
    callback character varying(300) NOT NULL,
    callback_type character varying(100) NOT NULL,
    sort_order integer DEFAULT 1 NOT NULL,
    CONSTRAINT sgc_callback_type_ck CHECK (((callback_type)::text = ('tcl'::character varying)::text)),
    CONSTRAINT sgc_event_type_ck CHECK (((((event_type)::text = ('insert'::character varying)::text) OR ((event_type)::text = ('update'::character varying)::text)) OR ((event_type)::text = ('delete'::character varying)::text))),
    CONSTRAINT sgc_sort_order_ck CHECK ((sort_order >= 1))
);


--
-- Name: TABLE subsite_callbacks; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE subsite_callbacks IS '
	Applications can register callbacks that are triggered
	whenever a group of a specified type is created. The callback
	must expect the following arguments: 
	  * object_id: The object that just got created
	  * node_id: The node_id where the object got created
	  * package_id: The package_id from where the object got created
	These are passed in the following way:
	  * tcl procedure: Using named parameters (e.g. -object_id $object_id)
	All callbacks must accept all of these parameters.
';


--
-- Name: COLUMN subsite_callbacks.event_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN subsite_callbacks.event_type IS '
	The type of event we are monitoring. The keywords here are used
	by the applications to determine which callbacks to trigger.
';


--
-- Name: COLUMN subsite_callbacks.object_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN subsite_callbacks.object_type IS '
	The object type to monitor. Whenever an object of this type is
	created, the subsite package will check for a registered
	callbacks.
';


--
-- Name: COLUMN subsite_callbacks.callback; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN subsite_callbacks.callback IS '
	The actual callback. This can be the name of a plsql function
	or procedure, a url stub relative to the node at which package
	id is mounted, or the name of a tcl function.
';


--
-- Name: COLUMN subsite_callbacks.callback_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN subsite_callbacks.callback_type IS ' 
	The type of the callback. This determines how the callback is
	executed. Currenlty only a tcl type is supported but other
	types may be added in the future. 
';


--
-- Name: COLUMN subsite_callbacks.sort_order; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN subsite_callbacks.sort_order IS '
	The order in which the callbacks should fire. This is
	important when you need to ensure that one event fires before
	another (e.g. you must mount a portals application before the
	bboard application)
';


--
-- Name: syndication; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE syndication (
    object_id integer NOT NULL,
    last_updated timestamp with time zone DEFAULT now() NOT NULL,
    rss_xml_frag text,
    body text,
    url text
);


--
-- Name: TABLE syndication; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE syndication IS 'stores xml fragments for consolidating into rss feeds. Also stores an html version of the content item
         and it''s url from the link field of the rss';


--
-- Name: t_acs_attribute_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_acs_attribute_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: t_acs_attribute_value_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_acs_attribute_value_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: t_acs_log_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_acs_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: t_acs_object_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_acs_object_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: t_acs_rel_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_acs_rel_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: t_anon_func_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_anon_func_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: t_etp_auto_page_number_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_etp_auto_page_number_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: t_sec_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_sec_id_seq
    START WITH 1
    INCREMENT BY 100
    NO MAXVALUE
    NO MINVALUE
    CACHE 100;


--
-- Name: t_sec_security_token_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_sec_security_token_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 100;


--
-- Name: t_wf_task_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_wf_task_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: t_wf_token_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE t_wf_token_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: target_place_list; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE target_place_list (
    session_id integer NOT NULL,
    rcnt integer NOT NULL,
    ky character varying(100)
);


--
-- Name: timespan_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW timespan_seq AS
    SELECT nextval(('timespan_sequence'::text)::regclass) AS nextval FROM dual;


--
-- Name: timespan_sequence; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE timespan_sequence
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: timezone_rules; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE timezone_rules (
    tz_id integer,
    abbrev character varying(10) NOT NULL,
    utc_start timestamp with time zone NOT NULL,
    utc_end timestamp with time zone NOT NULL,
    local_start timestamp with time zone NOT NULL,
    local_end timestamp with time zone NOT NULL,
    gmt_offset text NOT NULL,
    isdst_p boolean
);


--
-- Name: timezone_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE timezone_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: timezones; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE timezones (
    tz_id integer NOT NULL,
    tz character varying(100) NOT NULL,
    gmt_offset text NOT NULL
);


--
-- Name: trackback_pings; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE trackback_pings (
    tb_url character varying(1000),
    name character varying(1000),
    comment_id integer
);


--
-- Name: ttl_area_assignments; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ttl_area_assignments (
    area_id integer NOT NULL,
    user_id integer NOT NULL,
    date_assigned timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone
);


--
-- Name: ttl_areas; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ttl_areas (
    area_id integer NOT NULL,
    active_p boolean DEFAULT true,
    name character varying(200) NOT NULL
);


--
-- Name: ttl_assignments; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ttl_assignments (
    ticket_id integer NOT NULL,
    user_id integer NOT NULL,
    date_assigned timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone
);


--
-- Name: ttl_comments; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ttl_comments (
    comment_id integer NOT NULL,
    active_p boolean DEFAULT true,
    ticket_id integer NOT NULL,
    creation_user integer NOT NULL,
    creation_date timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone,
    message text,
    message_format character varying(10) DEFAULT 'formatted'::character varying,
    CONSTRAINT ttl_comments_message_format_ck CHECK (((((message_format)::text = ('plain'::character varying)::text) OR ((message_format)::text = ('formatted'::character varying)::text)) OR ((message_format)::text = ('html'::character varying)::text)))
);


--
-- Name: ttl_prefs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ttl_prefs (
    user_id integer NOT NULL,
    sort character varying(100),
    mine_p boolean,
    status character varying(100),
    area_id integer
);


--
-- Name: ttl_status; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ttl_status (
    status character varying(20) NOT NULL,
    status_name character varying(100) NOT NULL,
    sort_key integer
);


--
-- Name: ttl_tickets; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ttl_tickets (
    ticket_id integer NOT NULL,
    active_p boolean DEFAULT true,
    area_id integer,
    name character varying(200) NOT NULL,
    type character varying(20),
    status character varying(20),
    url character varying(400),
    deadline timestamp with time zone,
    message text,
    message_format character varying(10) DEFAULT 'formatted'::character varying,
    priority integer DEFAULT 2,
    CONSTRAINT ttl_tickets_message_format_ck CHECK (((((message_format)::text = ('plain'::character varying)::text) OR ((message_format)::text = ('formatted'::character varying)::text)) OR ((message_format)::text = ('html'::character varying)::text)))
);


--
-- Name: ttl_v_areas; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ttl_v_areas AS
    SELECT o.object_id, o.object_type, o.context_id, o.security_inherit_p, o.creation_user, o.creation_date, o.creation_ip, o.last_modified, o.modifying_user, o.modifying_ip, o.tree_sortkey, a.area_id, a.active_p, a.name FROM acs_objects o, ttl_areas a WHERE (o.object_id = a.area_id);


--
-- Name: ttl_va_comments; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ttl_va_comments AS
    SELECT ttl_comments.comment_id, ttl_comments.active_p, ttl_comments.ticket_id, ttl_comments.creation_user, ttl_comments.creation_date, ttl_comments.message, ttl_comments.message_format FROM ttl_comments WHERE (ttl_comments.active_p = true);


--
-- Name: ttl_v_comments_latest; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ttl_v_comments_latest AS
    SELECT c.comment_id, c.active_p, c.ticket_id, c.creation_user, c.creation_date, c.message, c.message_format FROM ttl_va_comments c WHERE (c.comment_id = (SELECT max(c2.comment_id) AS max FROM ttl_comments c2 WHERE (c.ticket_id = c2.ticket_id)));


--
-- Name: ttl_v_tickets; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ttl_v_tickets AS
    SELECT o.object_id, o.object_type, o.context_id, o.security_inherit_p, o.creation_user, o.creation_date, o.creation_ip, o.last_modified, o.modifying_user, o.modifying_ip, o.tree_sortkey, t.ticket_id, t.active_p, t.area_id, t.name, t.type, t.status, t.url, t.deadline, t.message, t.message_format, t.priority FROM acs_objects o, ttl_tickets t WHERE (t.ticket_id = o.object_id);


--
-- Name: ttl_v_users; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ttl_v_users AS
    SELECT acs_permissions.object_id AS package_id, acs_permissions.grantee_id AS user_id, acs_permissions.privilege FROM acs_permissions WHERE ((acs_permissions.privilege)::text = ('write'::character varying)::text);


--
-- Name: ttl_va_areas; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ttl_va_areas AS
    SELECT ttl_v_areas.object_id, ttl_v_areas.object_type, ttl_v_areas.context_id, ttl_v_areas.security_inherit_p, ttl_v_areas.creation_user, ttl_v_areas.creation_date, ttl_v_areas.creation_ip, ttl_v_areas.last_modified, ttl_v_areas.modifying_user, ttl_v_areas.modifying_ip, ttl_v_areas.tree_sortkey, ttl_v_areas.area_id, ttl_v_areas.active_p, ttl_v_areas.name FROM ttl_v_areas WHERE (ttl_v_areas.active_p = true);


--
-- Name: ttl_va_tickets; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ttl_va_tickets AS
    SELECT ttl_v_tickets.object_id, ttl_v_tickets.object_type, ttl_v_tickets.context_id, ttl_v_tickets.security_inherit_p, ttl_v_tickets.creation_user, ttl_v_tickets.creation_date, ttl_v_tickets.creation_ip, ttl_v_tickets.last_modified, ttl_v_tickets.modifying_user, ttl_v_tickets.modifying_ip, ttl_v_tickets.tree_sortkey, ttl_v_tickets.ticket_id, ttl_v_tickets.active_p, ttl_v_tickets.area_id, ttl_v_tickets.name, ttl_v_tickets.type, ttl_v_tickets.status, ttl_v_tickets.url, ttl_v_tickets.deadline, ttl_v_tickets.message, ttl_v_tickets.message_format, ttl_v_tickets.priority FROM ttl_v_tickets WHERE (ttl_v_tickets.active_p = true);


--
-- Name: user_col_comments; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW user_col_comments AS
    SELECT upper((c.relname)::text) AS table_name, upper((a.attname)::text) AS column_name, col_description(a.attrelid, (a.attnum)::integer) AS comments FROM (pg_class c LEFT JOIN pg_attribute a ON ((a.attrelid = c.oid))) WHERE (a.attnum > 0);


--
-- Name: user_portraits; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE user_portraits (
    user_id integer NOT NULL
);


--
-- Name: user_preferences; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE user_preferences (
    user_id integer NOT NULL,
    prefer_text_only_p boolean DEFAULT false,
    language_preference character(2) DEFAULT 'en'::bpchar,
    dont_spam_me_p boolean DEFAULT false,
    email_type character varying(64),
    locale character varying(30),
    timezone character varying(100)
);


--
-- Name: user_tab_columns; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW user_tab_columns AS
    SELECT upper((c.relname)::text) AS table_name, upper((a.attname)::text) AS column_name, upper((t.typname)::text) AS data_type FROM pg_class c, pg_attribute a, pg_type t WHERE (((c.oid = a.attrelid) AND (a.atttypid = t.oid)) AND (a.attnum > 0));


--
-- Name: user_tab_comments; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW user_tab_comments AS
    SELECT upper((c.relname)::text) AS table_name, CASE WHEN (c.relkind = 'r'::"char") THEN 'TABLE'::text WHEN (c.relkind = 'v'::"char") THEN 'VIEW'::text ELSE (c.relkind)::text END AS table_type, d.description AS comments FROM (pg_class c LEFT JOIN pg_description d ON ((c.oid = d.objoid))) WHERE (d.objsubid = 0);


--
-- Name: users_email_image; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE users_email_image (
    email_image_id integer NOT NULL
);


--
-- Name: users_email_imagei; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW users_email_imagei AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.title AS object_title, acs_objects.package_id AS object_package_id, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, acs_objects.max_child_sortkey, cr.revision_id, cr.title, cr.item_id, content_revision__get_content(cr.revision_id) AS data, cr_text.text_data AS text, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, users_email_image.email_image_id FROM acs_objects, cr_revisions cr, cr_text, users_email_image WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = users_email_image.email_image_id));


--
-- Name: users_email_imagex; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW users_email_imagex AS
    SELECT acs_objects.object_id, acs_objects.object_type, acs_objects.title AS object_title, acs_objects.package_id AS object_package_id, acs_objects.context_id, acs_objects.security_inherit_p, acs_objects.creation_user, acs_objects.creation_date, acs_objects.creation_ip, acs_objects.last_modified, acs_objects.modifying_user, acs_objects.modifying_ip, acs_objects.tree_sortkey, acs_objects.max_child_sortkey, cr.revision_id, cr.title, cr.item_id, cr.description, cr.publish_date, cr.mime_type, cr.nls_language, i.name, i.parent_id, users_email_image.email_image_id FROM acs_objects, cr_revisions cr, cr_items i, cr_text, users_email_image WHERE (((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id)) AND (acs_objects.object_id = users_email_image.email_image_id));


--
-- Name: valid_uninstalled_bindings; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW valid_uninstalled_bindings AS
    SELECT c.contract_id, c.contract_name, i.impl_id, i.impl_name, i.impl_owner_name, i.impl_pretty_name FROM acs_sc_contracts c, acs_sc_impls i WHERE ((((c.contract_name)::text = (i.impl_contract_name)::text) AND (NOT (EXISTS (SELECT 1 FROM acs_sc_bindings b WHERE ((b.contract_id = c.contract_id) AND (b.impl_id = i.impl_id)))))) AND (NOT (EXISTS (SELECT 1 FROM acs_sc_operations o WHERE ((o.contract_id = c.contract_id) AND (NOT (EXISTS (SELECT 1 FROM acs_sc_impl_aliases a WHERE ((((a.impl_contract_name)::text = (c.contract_name)::text) AND (a.impl_id = i.impl_id)) AND ((a.impl_operation_name)::text = (o.operation_name)::text))))))))));


--
-- Name: weblogger_blogroll_entries; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE weblogger_blogroll_entries (
    link_id integer NOT NULL,
    package_id integer,
    name character varying(500) NOT NULL,
    url character varying(1000) NOT NULL,
    sort_order integer DEFAULT 0
);


--
-- Name: weblogger_channels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE weblogger_channels (
    channel_id integer NOT NULL,
    package_id integer,
    user_id integer
);


--
-- Name: weblogger_ping_urls; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE weblogger_ping_urls (
    package_id integer NOT NULL,
    ping_url character varying(500) NOT NULL,
    creation_date timestamp with time zone DEFAULT now()
);


--
-- Name: weblogger_technorati_cache; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE weblogger_technorati_cache (
    package_id integer,
    name character varying(500),
    url character varying(500),
    creation_date timestamp with time zone DEFAULT now()
);


--
-- Name: wf_arcs; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_arcs (
    workflow_key character varying(100) NOT NULL,
    transition_key character varying(100) NOT NULL,
    place_key character varying(100) NOT NULL,
    direction character varying(3) NOT NULL,
    guard_callback character varying(100),
    guard_custom_arg text,
    guard_description character varying(500),
    CONSTRAINT wf_arc_direction_ck CHECK (((((direction)::text = (''::character varying)::text) OR ((direction)::text = ('in'::character varying)::text)) OR ((direction)::text = ('out'::character varying)::text))),
    CONSTRAINT wf_arc_guard_on_in_arc_ck CHECK ((((guard_callback)::text = (''::character varying)::text) OR ((direction)::text = ('out'::character varying)::text)))
);


--
-- Name: TABLE wf_arcs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_arcs IS '
  The arcs of the workflow petri net.
  Arcs always go between a transition and a place.
  The direction is relative to the transition here, i.e.
  in means it goes into the transition, out means it goes
  away from the transition.
';


--
-- Name: wf_article_cases; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_article_cases (
    case_id integer NOT NULL
);


--
-- Name: wf_attribute_value_audit; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_attribute_value_audit (
    case_id integer NOT NULL,
    attribute_id integer NOT NULL,
    journal_id integer NOT NULL,
    attr_value text
);


--
-- Name: TABLE wf_attribute_value_audit; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_attribute_value_audit IS '
  This table holds all the attribute values that has been set, 
  so we can track changes over the lifetime of a case.
';


--
-- Name: wf_case_assignments; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_case_assignments (
    case_id integer NOT NULL,
    workflow_key character varying(100),
    role_key character varying(100) NOT NULL,
    party_id integer NOT NULL
);


--
-- Name: TABLE wf_case_assignments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_case_assignments IS '
  Manual per-case assignments of roles to parties.
';


--
-- Name: wf_case_deadlines; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_case_deadlines (
    case_id integer NOT NULL,
    workflow_key character varying(100),
    transition_key character varying(100) NOT NULL,
    deadline timestamp with time zone NOT NULL
);


--
-- Name: TABLE wf_case_deadlines; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_case_deadlines IS '
  Manual deadlines for the individual transitions (tasks) on a per-case basis.
';


--
-- Name: wf_cases; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_cases (
    case_id integer NOT NULL,
    workflow_key character varying(100),
    context_key character varying(100),
    object_id integer,
    state character varying(40) DEFAULT 'created'::character varying,
    CONSTRAINT wf_cases_state_ck CHECK (((((((state)::text = ('created'::character varying)::text) OR ((state)::text = ('active'::character varying)::text)) OR ((state)::text = ('suspended'::character varying)::text)) OR ((state)::text = ('canceled'::character varying)::text)) OR ((state)::text = ('finished'::character varying)::text)))
);


--
-- Name: TABLE wf_cases; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_cases IS '
  The instance of a process, e.g. the case of publishing one article, 
  the case of handling one insurance claim, the case of handling
  one ecommerce order, of fixing one ticket-tracker ticket.
';


--
-- Name: COLUMN wf_cases.object_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN wf_cases.object_id IS '
  A case is generally about some other object, e.g., an insurance claim, an article,
  a ticket, an order, etc. This is the place to store the reference to that object.
  It is not uncommong to have more than one case for the same object, e.g., we might 
  have one process for evaluating and honoring an insurance claim, and another for archiving
  legal information about a claim.
';


--
-- Name: wf_context_assignments; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_context_assignments (
    context_key character varying(100) NOT NULL,
    workflow_key character varying(100) NOT NULL,
    role_key character varying(100) NOT NULL,
    party_id integer NOT NULL
);


--
-- Name: TABLE wf_context_assignments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_context_assignments IS '
  Static (default) per-context assignments of roles to parties. 
';


--
-- Name: wf_context_role_info; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_context_role_info (
    context_key character varying(100) NOT NULL,
    workflow_key character varying(100) NOT NULL,
    role_key character varying(100) NOT NULL,
    assignment_callback character varying(100),
    assignment_custom_arg character varying(4000)
);


--
-- Name: TABLE wf_context_role_info; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_context_role_info IS '
  This table holds context-dependent info for roles, currently only the assignment callback
';


--
-- Name: wf_context_task_panels; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_context_task_panels (
    context_key character varying(100) NOT NULL,
    workflow_key character varying(100) NOT NULL,
    transition_key character varying(100) NOT NULL,
    sort_order integer NOT NULL,
    header character varying(200) NOT NULL,
    template_url character varying(500) NOT NULL,
    overrides_action_p character(1) DEFAULT 'f'::bpchar,
    only_display_when_started_p character(1) DEFAULT 'f'::bpchar,
    CONSTRAINT wf_context_panels_display_p_ck CHECK (((only_display_when_started_p = 't'::bpchar) OR (only_display_when_started_p = 'f'::bpchar))),
    CONSTRAINT wf_context_panels_ovrd_p_ck CHECK (((overrides_action_p = 't'::bpchar) OR (overrides_action_p = 'f'::bpchar)))
);


--
-- Name: TABLE wf_context_task_panels; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_context_task_panels IS '
  Holds information about the panels to be displayed on the task page.
';


--
-- Name: wf_context_transition_info; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_context_transition_info (
    context_key character varying(100) NOT NULL,
    workflow_key character varying(100) NOT NULL,
    transition_key character varying(100) NOT NULL,
    estimated_minutes integer,
    instructions text,
    enable_callback character varying(100),
    enable_custom_arg text,
    fire_callback character varying(100),
    fire_custom_arg text,
    time_callback character varying(100),
    time_custom_arg text,
    deadline_callback character varying(100),
    deadline_custom_arg text,
    deadline_attribute_name character varying(100),
    hold_timeout_callback character varying(100),
    hold_timeout_custom_arg text,
    notification_callback character varying(100),
    notification_custom_arg text,
    unassigned_callback character varying(100),
    unassigned_custom_arg text
);


--
-- Name: TABLE wf_context_transition_info; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_context_transition_info IS '
  This table holds information that pertains to a transition in a specific context.
  It will specifically hold 
';


--
-- Name: wf_context_workflow_info; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_context_workflow_info (
    context_key character varying(100) NOT NULL,
    workflow_key character varying(100) NOT NULL,
    principal_party integer
);


--
-- Name: TABLE wf_context_workflow_info; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_context_workflow_info IS '
  Holds context-dependent information about the workflow, specifically the 
  principal user.
';


--
-- Name: wf_contexts; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_contexts (
    context_key character varying(100) NOT NULL,
    context_name character varying(100) NOT NULL
);


--
-- Name: TABLE wf_contexts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_contexts IS '
  The context of a workflow holds everything that''s not directly 
  part of the Petri Net structure, the stuff that''s likely to
  be changed as the workflow is applied in a real business, and that
  you will want to customize across different departments of the 
  same business. It includes assignments of transitions to parties,
  the call-backs, etc.
';


--
-- Name: wf_places; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_places (
    place_key character varying(100) NOT NULL,
    workflow_key character varying(100) NOT NULL,
    place_name character varying(100) NOT NULL,
    sort_order integer,
    CONSTRAINT wf_place_order_ck CHECK ((sort_order > 0))
);


--
-- Name: TABLE wf_places; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_places IS '
  The circles of the petri net. These hold the tokens representing the overall
  state of the workflow.
';


--
-- Name: wf_tokens; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_tokens (
    token_id integer NOT NULL,
    case_id integer,
    workflow_key character varying(100),
    place_key character varying(100),
    state character varying(40) DEFAULT 'free'::character varying,
    locked_task_id integer,
    produced_date timestamp with time zone DEFAULT now(),
    locked_date timestamp with time zone,
    canceled_date timestamp with time zone,
    consumed_date timestamp with time zone,
    produced_journal_id integer,
    locked_journal_id integer,
    canceled_journal_id integer,
    consumed_journal_id integer,
    CONSTRAINT wf_tokens_state_ck CHECK ((((((state)::text = ('free'::character varying)::text) OR ((state)::text = ('locked'::character varying)::text)) OR ((state)::text = ('canceled'::character varying)::text)) OR ((state)::text = ('consumed'::character varying)::text)))
);


--
-- Name: TABLE wf_tokens; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_tokens IS '
  Where the tokens currently are, and what task is laying hands on it, if any.
  A token is sort of the instance of a place, except there''ll be one row here per
  token, and there can be more than one token per place.
';


--
-- Name: wf_transitions; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_transitions (
    transition_key character varying(100) NOT NULL,
    transition_name character varying(100) NOT NULL,
    workflow_key character varying(100) NOT NULL,
    role_key character varying(100),
    sort_order integer,
    trigger_type character varying(40),
    CONSTRAINT wf_transition_order_ck CHECK ((sort_order > 0)),
    CONSTRAINT wf_transition_trigger_type_ck CHECK (((((((trigger_type)::text = (''::character varying)::text) OR ((trigger_type)::text = ('automatic'::character varying)::text)) OR ((trigger_type)::text = ('user'::character varying)::text)) OR ((trigger_type)::text = ('message'::character varying)::text)) OR ((trigger_type)::text = ('time'::character varying)::text)))
);


--
-- Name: TABLE wf_transitions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_transitions IS '
  The squares in the petri net. The things that somebody (or something) actually does.
';


--
-- Name: wf_transition_contexts; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW wf_transition_contexts AS
    SELECT t.transition_key, t.transition_name, t.workflow_key, t.sort_order, t.trigger_type, t.role_key, c.context_key, c.context_name FROM wf_transitions t, wf_contexts c;


--
-- Name: wf_transition_info; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW wf_transition_info AS
    SELECT t.transition_key, t.transition_name, t.workflow_key, t.sort_order, t.trigger_type, t.context_key, t.role_key, ct.estimated_minutes, ct.instructions, ct.enable_callback, ct.enable_custom_arg, ct.fire_callback, ct.fire_custom_arg, ct.time_callback, ct.time_custom_arg, ct.deadline_callback, ct.deadline_custom_arg, ct.deadline_attribute_name, ct.hold_timeout_callback, ct.hold_timeout_custom_arg, ct.notification_callback, ct.notification_custom_arg, ct.unassigned_callback, ct.unassigned_custom_arg FROM (wf_transition_contexts t LEFT JOIN wf_context_transition_info ct ON (((((ct.workflow_key)::text = (t.workflow_key)::text) AND ((ct.transition_key)::text = (t.transition_key)::text)) AND ((ct.context_key)::text = (t.context_key)::text))));


--
-- Name: wf_transition_places; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW wf_transition_places AS
    SELECT a.workflow_key, t.transition_key, p.place_key, p.place_name, p.sort_order, a.direction, a.guard_callback, a.guard_custom_arg, a.guard_description FROM wf_arcs a, wf_places p, wf_transitions t WHERE (((((a.transition_key)::text = (t.transition_key)::text) AND ((a.workflow_key)::text = (t.workflow_key)::text)) AND ((p.place_key)::text = (a.place_key)::text)) AND ((p.workflow_key)::text = (a.workflow_key)::text));


--
-- Name: wf_enabled_transitions; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW wf_enabled_transitions AS
    SELECT c.case_id, t.transition_key, t.transition_name, t.workflow_key, t.sort_order, t.trigger_type, t.context_key, t.role_key, t.enable_callback, t.enable_custom_arg, t.fire_callback, t.fire_custom_arg, t.time_callback, t.time_custom_arg, t.deadline_callback, t.deadline_custom_arg, t.deadline_attribute_name, t.hold_timeout_callback, t.hold_timeout_custom_arg, t.notification_callback, t.notification_custom_arg, t.estimated_minutes, t.instructions, t.unassigned_callback, t.unassigned_custom_arg FROM wf_transition_info t, wf_cases c WHERE (((((t.workflow_key)::text = (c.workflow_key)::text) AND ((t.context_key)::text = (c.context_key)::text)) AND ((c.state)::text = ('active'::character varying)::text)) AND (NOT (EXISTS (SELECT tp.place_key FROM wf_transition_places tp WHERE (((((tp.transition_key)::text = (t.transition_key)::text) AND ((tp.workflow_key)::text = (t.workflow_key)::text)) AND ((tp.direction)::text = ('in'::character varying)::text)) AND (NOT (EXISTS (SELECT tk.token_id FROM wf_tokens tk WHERE ((((tk.place_key)::text = (tp.place_key)::text) AND (tk.case_id = c.case_id)) AND ((tk.state)::text = ('free'::character varying)::text))))))))));


--
-- Name: wf_roles; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_roles (
    role_key character varying(100) NOT NULL,
    workflow_key character varying(100) NOT NULL,
    role_name character varying(100) NOT NULL,
    sort_order integer,
    CONSTRAINT wf_roles_order_ck CHECK ((sort_order > 0))
);


--
-- Name: TABLE wf_roles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_roles IS '
  A process has certain roles associated with it, such as "submitter", 
  "reviewer", "editor", "claimant", etc. For each transition, then, you
  specify what role is to perform that task. Thus, two or more tasks can be
  performed by one and the same role, so that when the role is reassigned,
  it reflects assignments of both tasks. Users and parties are then assigned
  to roles instead of directly to tasks.
';


--
-- Name: wf_role_info; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW wf_role_info AS
    SELECT r.role_key, r.role_name, r.workflow_key, c.context_key, cr.assignment_callback, cr.assignment_custom_arg FROM wf_contexts c, (wf_roles r LEFT JOIN wf_context_role_info cr ON ((((cr.workflow_key)::text = (r.workflow_key)::text) AND ((cr.role_key)::text = (r.role_key)::text)))) WHERE ((cr.context_key)::text = (c.context_key)::text);


--
-- Name: wf_task_assignments; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_task_assignments (
    task_id integer NOT NULL,
    party_id integer NOT NULL
);


--
-- Name: wf_task_id_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW wf_task_id_seq AS
    SELECT nextval(('t_wf_task_id_seq'::text)::regclass) AS nextval;


--
-- Name: wf_tasks; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_tasks (
    task_id integer NOT NULL,
    case_id integer,
    workflow_key character varying(100),
    transition_key character varying(100),
    state character varying(40) DEFAULT 'enabled'::character varying,
    enabled_date timestamp with time zone DEFAULT now(),
    started_date timestamp with time zone,
    canceled_date timestamp with time zone,
    finished_date timestamp with time zone,
    overridden_date timestamp with time zone,
    trigger_time timestamp with time zone,
    deadline timestamp with time zone,
    estimated_minutes integer,
    holding_user integer,
    hold_timeout timestamp with time zone,
    CONSTRAINT wf_task_state_ck CHECK (((((((state)::text = ('enabled'::character varying)::text) OR ((state)::text = ('started'::character varying)::text)) OR ((state)::text = ('canceled'::character varying)::text)) OR ((state)::text = ('finished'::character varying)::text)) OR ((state)::text = ('overridden'::character varying)::text)))
);


--
-- Name: TABLE wf_tasks; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_tasks IS '
  The tasks that need to be done, who can do it, and what state it''s in.
  A task is the instance of a transition.
';


--
-- Name: wf_token_id_seq; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW wf_token_id_seq AS
    SELECT nextval(('t_wf_token_id_seq'::text)::regclass) AS nextval;


--
-- Name: wf_transition_attribute_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_transition_attribute_map (
    workflow_key character varying(100) NOT NULL,
    transition_key character varying(100) NOT NULL,
    sort_order integer NOT NULL,
    attribute_id integer NOT NULL
);


--
-- Name: TABLE wf_transition_attribute_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_transition_attribute_map IS '
  The workflow attributes that should be set when
  the given transition is fired.
';


--
-- Name: wf_transition_role_assign_map; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_transition_role_assign_map (
    workflow_key character varying(100) NOT NULL,
    transition_key character varying(100) NOT NULL,
    assign_role_key character varying(100) NOT NULL
);


--
-- Name: TABLE wf_transition_role_assign_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_transition_role_assign_map IS '
  When part of the output of one task is to assign users to a role,
  specify that this is the case by inserting a row here.
';


--
-- Name: COLUMN wf_transition_role_assign_map.transition_key; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN wf_transition_role_assign_map.transition_key IS '
  transition_key is the assigning transition.
';


--
-- Name: COLUMN wf_transition_role_assign_map.assign_role_key; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN wf_transition_role_assign_map.assign_role_key IS '
  assign_role_key is the role being assigned a user to.
';


--
-- Name: wf_user_tasks; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW wf_user_tasks AS
    SELECT DISTINCT ta.task_id, ta.case_id, ta.workflow_key, ta.transition_key, tr.transition_name, ta.enabled_date, ta.started_date, u.user_id, ta.state, ta.holding_user, ta.hold_timeout, ta.deadline, ta.estimated_minutes FROM wf_tasks ta, wf_task_assignments tasgn, wf_cases c, wf_transition_info tr, party_approved_member_map m, users u WHERE ((((((((((((ta.state)::text = ('enabled'::character varying)::text) OR ((ta.state)::text = ('started'::character varying)::text)) AND (c.case_id = ta.case_id)) AND ((c.state)::text = ('active'::character varying)::text)) AND ((tr.transition_key)::text = (ta.transition_key)::text)) AND ((tr.workflow_key)::text = (ta.workflow_key)::text)) AND ((tr.trigger_type)::text = ('user'::character varying)::text)) AND ((tr.context_key)::text = (c.context_key)::text)) AND (tasgn.task_id = ta.task_id)) AND (m.party_id = tasgn.party_id)) AND (u.user_id = m.member_id)) ORDER BY ta.task_id, ta.case_id, ta.workflow_key, ta.transition_key, tr.transition_name, ta.enabled_date, ta.started_date, u.user_id, ta.state, ta.holding_user, ta.hold_timeout, ta.deadline, ta.estimated_minutes;


--
-- Name: wf_workflows; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE wf_workflows (
    workflow_key character varying(100) NOT NULL,
    description text
);


--
-- Name: TABLE wf_workflows; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE wf_workflows IS '
  Parent table for the workflow definition.
';


--
-- Name: workflow_session_id; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE workflow_session_id
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


--
-- Name: acs_act_obj_mp_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_activity_object_map
    ADD CONSTRAINT acs_act_obj_mp_pk PRIMARY KEY (activity_id, object_id);


--
-- Name: acs_activities_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_activities
    ADD CONSTRAINT acs_activities_pk PRIMARY KEY (activity_id);


--
-- Name: acs_attribute_descriptions_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_attribute_descriptions
    ADD CONSTRAINT acs_attribute_descriptions_pk PRIMARY KEY (object_type, attribute_name, description_key);


--
-- Name: acs_attribute_values_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_attribute_values
    ADD CONSTRAINT acs_attribute_values_pk PRIMARY KEY (object_id, attribute_id);


--
-- Name: acs_attributes_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_attributes
    ADD CONSTRAINT acs_attributes_pk PRIMARY KEY (attribute_id);


--
-- Name: acs_cont_content_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_contents
    ADD CONSTRAINT acs_cont_content_id_pk PRIMARY KEY (content_id);


--
-- Name: acs_data_links_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_data_links
    ADD CONSTRAINT acs_data_links_pk PRIMARY KEY (rel_id);


--
-- Name: acs_data_links_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_data_links
    ADD CONSTRAINT acs_data_links_un UNIQUE (object_id_one, object_id_two);


--
-- Name: acs_datatypes_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_datatypes
    ADD CONSTRAINT acs_datatypes_pk PRIMARY KEY (datatype);


--
-- Name: acs_enum_values_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_enum_values
    ADD CONSTRAINT acs_enum_values_pk PRIMARY KEY (attribute_id, enum_value);


--
-- Name: acs_events_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_events
    ADD CONSTRAINT acs_events_pk PRIMARY KEY (event_id);


--
-- Name: acs_evnt_party_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_event_party_map
    ADD CONSTRAINT acs_evnt_party_map_pk PRIMARY KEY (event_id, party_id);


--
-- Name: acs_function_args_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_function_args
    ADD CONSTRAINT acs_function_args_pk PRIMARY KEY (function, arg_seq);


--
-- Name: acs_function_args_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_function_args
    ADD CONSTRAINT acs_function_args_un UNIQUE (function, arg_name);


--
-- Name: acs_logs_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_logs
    ADD CONSTRAINT acs_logs_pk PRIMARY KEY (log_id);


--
-- Name: acs_magic_objects_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_magic_objects
    ADD CONSTRAINT acs_magic_objects_pk PRIMARY KEY (name);


--
-- Name: acs_mail_bodies_body_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_bodies
    ADD CONSTRAINT acs_mail_bodies_body_id_pk PRIMARY KEY (body_id);


--
-- Name: acs_mail_gc_objs_object_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_gc_objects
    ADD CONSTRAINT acs_mail_gc_objs_object_id_pk PRIMARY KEY (gc_object_id);


--
-- Name: acs_mail_links_ml_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_links
    ADD CONSTRAINT acs_mail_links_ml_id_pk PRIMARY KEY (mail_link_id);


--
-- Name: acs_mail_lite_bou_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_lite_bounce
    ADD CONSTRAINT acs_mail_lite_bou_pk PRIMARY KEY (user_id);


--
-- Name: acs_mail_lite_log_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_lite_mail_log
    ADD CONSTRAINT acs_mail_lite_log_pk PRIMARY KEY (user_id);


--
-- Name: acs_mail_lite_notif_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_lite_bounce_notif
    ADD CONSTRAINT acs_mail_lite_notif_pk PRIMARY KEY (user_id);


--
-- Name: acs_mail_lite_queue_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_lite_queue
    ADD CONSTRAINT acs_mail_lite_queue_pk PRIMARY KEY (message_id);


--
-- Name: acs_mail_multipart_parts_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_multipart_parts
    ADD CONSTRAINT acs_mail_multipart_parts_pk PRIMARY KEY (multipart_id, sequence_number);


--
-- Name: acs_mail_multiparts_mp_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_multiparts
    ADD CONSTRAINT acs_mail_multiparts_mp_id_pk PRIMARY KEY (multipart_id);


--
-- Name: acs_mail_queue_in_mlid_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_queue_incoming
    ADD CONSTRAINT acs_mail_queue_in_mlid_pk PRIMARY KEY (message_id);


--
-- Name: acs_mail_queue_ml_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_queue_messages
    ADD CONSTRAINT acs_mail_queue_ml_id_pk PRIMARY KEY (message_id);


--
-- Name: acs_mail_queue_out_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_mail_queue_outgoing
    ADD CONSTRAINT acs_mail_queue_out_pk PRIMARY KEY (message_id, envelope_to);


--
-- Name: acs_messages_outgoing_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_messages_outgoing
    ADD CONSTRAINT acs_messages_outgoing_pk PRIMARY KEY (message_id, to_address);


--
-- Name: acs_messages_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_messages
    ADD CONSTRAINT acs_messages_pk PRIMARY KEY (message_id);


--
-- Name: acs_named_objs_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_named_objects
    ADD CONSTRAINT acs_named_objs_pk PRIMARY KEY (object_id);


--
-- Name: acs_object_context_index_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_object_context_index
    ADD CONSTRAINT acs_object_context_index_pk PRIMARY KEY (object_id, ancestor_id);


--
-- Name: acs_object_type_tables_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_object_type_tables
    ADD CONSTRAINT acs_object_type_tables_pk PRIMARY KEY (object_type, table_name);


--
-- Name: acs_object_types_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_object_types
    ADD CONSTRAINT acs_object_types_pk PRIMARY KEY (object_type);


--
-- Name: acs_objects_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_objects
    ADD CONSTRAINT acs_objects_pk PRIMARY KEY (object_id);


--
-- Name: acs_objects_tree_sortkey_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_objects
    ADD CONSTRAINT acs_objects_tree_sortkey_un UNIQUE (tree_sortkey);


--
-- Name: acs_permissions_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_permissions
    ADD CONSTRAINT acs_permissions_pk PRIMARY KEY (object_id, grantee_id, privilege);


--
-- Name: acs_privilege_hierarchy_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_privilege_hierarchy
    ADD CONSTRAINT acs_privilege_hierarchy_pk PRIMARY KEY (privilege, child_privilege);


--
-- Name: acs_privileges_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_privileges
    ADD CONSTRAINT acs_privileges_pk PRIMARY KEY (privilege);


--
-- Name: acs_rel_roles_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_rel_roles
    ADD CONSTRAINT acs_rel_roles_pk PRIMARY KEY (role);


--
-- Name: acs_rel_types_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_rel_types
    ADD CONSTRAINT acs_rel_types_pk PRIMARY KEY (rel_type);


--
-- Name: acs_rels_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_rels
    ADD CONSTRAINT acs_rels_pk PRIMARY KEY (rel_id);


--
-- Name: acs_sc_contracts_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_sc_contracts
    ADD CONSTRAINT acs_sc_contracts_pk PRIMARY KEY (contract_id);


--
-- Name: acs_sc_impls_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_sc_impls
    ADD CONSTRAINT acs_sc_impls_pk PRIMARY KEY (impl_id);


--
-- Name: acs_sc_msg_types_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_sc_msg_types
    ADD CONSTRAINT acs_sc_msg_types_pk PRIMARY KEY (msg_type_id);


--
-- Name: acs_sc_operations_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_pk PRIMARY KEY (operation_id);


--
-- Name: acs_static_a_v_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_static_attr_values
    ADD CONSTRAINT acs_static_a_v_pk PRIMARY KEY (object_type, attribute_id);


--
-- Name: ad_locale_abbrev_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ad_locales
    ADD CONSTRAINT ad_locale_abbrev_pk PRIMARY KEY (locale);


--
-- Name: ad_template_sample_users_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ad_template_sample_users
    ADD CONSTRAINT ad_template_sample_users_pkey PRIMARY KEY (user_id);


--
-- Name: admin_rel_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY admin_rels
    ADD CONSTRAINT admin_rel_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: am_meeting_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY am_meeting
    ADD CONSTRAINT am_meeting_pk PRIMARY KEY (meeting_id);


--
-- Name: am_meeting_todo_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY am_meeting_todo
    ADD CONSTRAINT am_meeting_todo_pk PRIMARY KEY (todo_id);


--
-- Name: am_meeting_type_par_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY am_meeting_type_participants
    ADD CONSTRAINT am_meeting_type_par_pk PRIMARY KEY (type_id, user_id);


--
-- Name: am_meeting_type_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY am_meeting_type
    ADD CONSTRAINT am_meeting_type_pk PRIMARY KEY (type_id);


--
-- Name: apm_package_db_types_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_package_db_types
    ADD CONSTRAINT apm_package_db_types_pk PRIMARY KEY (db_type_key);


--
-- Name: apm_package_deps_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_package_dependencies
    ADD CONSTRAINT apm_package_deps_id_pk PRIMARY KEY (dependency_id);


--
-- Name: apm_package_types_p_key_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_package_types
    ADD CONSTRAINT apm_package_types_p_key_pk PRIMARY KEY (package_key);


--
-- Name: apm_package_vers_attr_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_package_version_attr
    ADD CONSTRAINT apm_package_vers_attr_pk PRIMARY KEY (version_id, attribute_name);


--
-- Name: apm_package_vers_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_package_versions
    ADD CONSTRAINT apm_package_vers_id_pk PRIMARY KEY (version_id);


--
-- Name: apm_packages_pack_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_packages
    ADD CONSTRAINT apm_packages_pack_id_pk PRIMARY KEY (package_id);


--
-- Name: apm_parameter_values_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_parameter_values
    ADD CONSTRAINT apm_parameter_values_pk PRIMARY KEY (value_id);


--
-- Name: apm_parameters_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_parameters
    ADD CONSTRAINT apm_parameters_pk PRIMARY KEY (parameter_id);


--
-- Name: app_groups_group_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY application_groups
    ADD CONSTRAINT app_groups_group_id_pk PRIMARY KEY (group_id);


--
-- Name: applications_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_applications
    ADD CONSTRAINT applications_pk PRIMARY KEY (application_id);


--
-- Name: arr_package_name_uq; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_reference_repositories
    ADD CONSTRAINT arr_package_name_uq UNIQUE (package_name);


--
-- Name: arr_repository_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_reference_repositories
    ADD CONSTRAINT arr_repository_id_pk PRIMARY KEY (repository_id);


--
-- Name: arr_table_name_uq; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY acs_reference_repositories
    ADD CONSTRAINT arr_table_name_uq UNIQUE (table_name);


--
-- Name: attach_fldr_map_package_id_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY attachments_fs_root_folder_map
    ADD CONSTRAINT attach_fldr_map_package_id_un UNIQUE (package_id);


--
-- Name: attach_fldr_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY attachments_fs_root_folder_map
    ADD CONSTRAINT attach_fldr_map_pk PRIMARY KEY (package_id, folder_id);


--
-- Name: attachments_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY attachments
    ADD CONSTRAINT attachments_pk PRIMARY KEY (object_id, item_id);


--
-- Name: auth_authorities_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY auth_authorities
    ADD CONSTRAINT auth_authorities_pk PRIMARY KEY (authority_id);


--
-- Name: auth_authority_short_name_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY auth_authorities
    ADD CONSTRAINT auth_authority_short_name_un UNIQUE (short_name);


--
-- Name: auth_batch_job_entries_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY auth_batch_job_entries
    ADD CONSTRAINT auth_batch_job_entries_pk PRIMARY KEY (entry_id);


--
-- Name: auth_batch_jobs_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY auth_batch_jobs
    ADD CONSTRAINT auth_batch_jobs_pk PRIMARY KEY (job_id);


--
-- Name: auth_driver_params_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY auth_driver_params
    ADD CONSTRAINT auth_driver_params_pk PRIMARY KEY (authority_id, impl_id, key);


--
-- Name: cal_item_cal_item_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cal_items
    ADD CONSTRAINT cal_item_cal_item_id_pk PRIMARY KEY (cal_item_id);


--
-- Name: cal_item_type_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cal_item_types
    ADD CONSTRAINT cal_item_type_id_pk PRIMARY KEY (item_type_id);


--
-- Name: cal_item_types_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cal_item_types
    ADD CONSTRAINT cal_item_types_un UNIQUE (calendar_id, item_type_id);


--
-- Name: cal_party_prefs_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cal_party_prefs
    ADD CONSTRAINT cal_party_prefs_un UNIQUE (calendar_id, party_id);


--
-- Name: calendars_calendar_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY calendars
    ADD CONSTRAINT calendars_calendar_id_pk PRIMARY KEY (calendar_id);


--
-- Name: categories_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY categories
    ADD CONSTRAINT categories_pkey PRIMARY KEY (category_id);


--
-- Name: category_links_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_links
    ADD CONSTRAINT category_links_pk PRIMARY KEY (link_id);


--
-- Name: category_links_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_links
    ADD CONSTRAINT category_links_un UNIQUE (from_category_id, to_category_id);


--
-- Name: category_object_map_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_object_map
    ADD CONSTRAINT category_object_map_pkey PRIMARY KEY (category_id, object_id);


--
-- Name: category_search_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_search
    ADD CONSTRAINT category_search_id_pk PRIMARY KEY (query_id);


--
-- Name: category_search_query_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_search
    ADD CONSTRAINT category_search_query_un UNIQUE (search_text, locale);


--
-- Name: category_search_results_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_search_results
    ADD CONSTRAINT category_search_results_pk PRIMARY KEY (query_id, synonym_id);


--
-- Name: category_synonyms_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_synonyms
    ADD CONSTRAINT category_synonyms_pk PRIMARY KEY (synonym_id);


--
-- Name: category_translations_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_translations
    ADD CONSTRAINT category_translations_pkey PRIMARY KEY (category_id, locale);


--
-- Name: category_tree_map_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_tree_map
    ADD CONSTRAINT category_tree_map_pkey PRIMARY KEY (object_id, tree_id);


--
-- Name: category_tree_translations_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_tree_translations
    ADD CONSTRAINT category_tree_translations_pkey PRIMARY KEY (tree_id, locale);


--
-- Name: category_trees_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY category_trees
    ADD CONSTRAINT category_trees_pkey PRIMARY KEY (tree_id);


--
-- Name: composition_rel_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY composition_rels
    ADD CONSTRAINT composition_rel_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: cr_child_rels_rel_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_child_rels
    ADD CONSTRAINT cr_child_rels_rel_pk PRIMARY KEY (rel_id);


--
-- Name: cr_content_mime_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_content_mime_type_map
    ADD CONSTRAINT cr_content_mime_map_pk PRIMARY KEY (content_type, mime_type);


--
-- Name: cr_content_text_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_content_text
    ADD CONSTRAINT cr_content_text_pkey PRIMARY KEY (revision_id);


--
-- Name: cr_doc_filter_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_doc_filter
    ADD CONSTRAINT cr_doc_filter_pkey PRIMARY KEY (revision_id);


--
-- Name: cr_extlinks_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_extlinks
    ADD CONSTRAINT cr_extlinks_pk PRIMARY KEY (extlink_id);


--
-- Name: cr_folder_type_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_folder_type_map
    ADD CONSTRAINT cr_folder_type_map_pk PRIMARY KEY (folder_id, content_type);


--
-- Name: cr_folders_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_folders
    ADD CONSTRAINT cr_folders_pk PRIMARY KEY (folder_id);


--
-- Name: cr_item_keyword_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_item_keyword_map
    ADD CONSTRAINT cr_item_keyword_map_pk PRIMARY KEY (item_id, keyword_id);


--
-- Name: cr_item_rels_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_item_rels
    ADD CONSTRAINT cr_item_rels_pk PRIMARY KEY (rel_id);


--
-- Name: cr_item_template_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_item_template_map
    ADD CONSTRAINT cr_item_template_map_pk PRIMARY KEY (item_id, template_id, use_context);


--
-- Name: cr_items_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_items
    ADD CONSTRAINT cr_items_pk PRIMARY KEY (item_id);


--
-- Name: cr_items_tree_sortkey_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_items
    ADD CONSTRAINT cr_items_tree_sortkey_un UNIQUE (tree_sortkey);


--
-- Name: cr_keywords_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_keywords
    ADD CONSTRAINT cr_keywords_pk PRIMARY KEY (keyword_id);


--
-- Name: cr_locale_abbrev_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_locales
    ADD CONSTRAINT cr_locale_abbrev_pk PRIMARY KEY (locale);


--
-- Name: cr_mime_type_extension_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_extension_mime_type_map
    ADD CONSTRAINT cr_mime_type_extension_map_pk PRIMARY KEY (extension);


--
-- Name: cr_mime_types_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_mime_types
    ADD CONSTRAINT cr_mime_types_pk PRIMARY KEY (mime_type);


--
-- Name: cr_news_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_news
    ADD CONSTRAINT cr_news_pk PRIMARY KEY (news_id);


--
-- Name: cr_release_periods_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_release_periods
    ADD CONSTRAINT cr_release_periods_pk PRIMARY KEY (item_id);


--
-- Name: cr_revision_attributes_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_revision_attributes
    ADD CONSTRAINT cr_revision_attributes_pk PRIMARY KEY (revision_id);


--
-- Name: cr_revisions_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_revisions
    ADD CONSTRAINT cr_revisions_pk PRIMARY KEY (revision_id);


--
-- Name: cr_symlinks_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_symlinks
    ADD CONSTRAINT cr_symlinks_pk PRIMARY KEY (symlink_id);


--
-- Name: cr_template_use_contexts_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_template_use_contexts
    ADD CONSTRAINT cr_template_use_contexts_pk PRIMARY KEY (use_context);


--
-- Name: cr_templates_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_templates
    ADD CONSTRAINT cr_templates_pk PRIMARY KEY (template_id);


--
-- Name: cr_type_children_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_type_children
    ADD CONSTRAINT cr_type_children_pk PRIMARY KEY (parent_type, child_type, relation_tag);


--
-- Name: cr_type_relations_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_type_relations
    ADD CONSTRAINT cr_type_relations_pk PRIMARY KEY (content_type, target_type, relation_tag);


--
-- Name: cr_type_template_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_type_template_map
    ADD CONSTRAINT cr_type_template_map_pk PRIMARY KEY (content_type, template_id, use_context);


--
-- Name: cr_xml_docs_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY cr_xml_docs
    ADD CONSTRAINT cr_xml_docs_pkey PRIMARY KEY (doc_id);


--
-- Name: dav_site_node_folder_map_node_id_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY dav_site_node_folder_map
    ADD CONSTRAINT dav_site_node_folder_map_node_id_un UNIQUE (node_id);


--
-- Name: download_ar_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY download_archive_revisions
    ADD CONSTRAINT download_ar_id_pk PRIMARY KEY (revision_id);


--
-- Name: download_archive_descs_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY download_archive_descs
    ADD CONSTRAINT download_archive_descs_pkey PRIMARY KEY (archive_desc_id);


--
-- Name: download_archive_reasons_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY download_reasons
    ADD CONSTRAINT download_archive_reasons_pk PRIMARY KEY (download_reason_id);


--
-- Name: download_archive_types_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY download_archive_types
    ADD CONSTRAINT download_archive_types_pk PRIMARY KEY (archive_type_id);


--
-- Name: download_archives_a_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY download_archives
    ADD CONSTRAINT download_archives_a_id_pk PRIMARY KEY (archive_id);


--
-- Name: download_downloads_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY download_downloads
    ADD CONSTRAINT download_downloads_id_pk PRIMARY KEY (download_id);


--
-- Name: download_ma_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY download_archive_metadata
    ADD CONSTRAINT download_ma_pk PRIMARY KEY (metadata_id);


--
-- Name: download_mc_choice_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY download_metadata_choices
    ADD CONSTRAINT download_mc_choice_id_pk PRIMARY KEY (choice_id);


--
-- Name: download_repository_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY download_repository
    ADD CONSTRAINT download_repository_id_pk PRIMARY KEY (repository_id);


--
-- Name: etp_page_revisions_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY etp_page_revisions
    ADD CONSTRAINT etp_page_revisions_pkey PRIMARY KEY (etp_page_revision_id);


--
-- Name: forums_forum_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY forums_forums
    ADD CONSTRAINT forums_forum_id_pk PRIMARY KEY (forum_id);


--
-- Name: forums_messages_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY forums_messages
    ADD CONSTRAINT forums_messages_pk PRIMARY KEY (message_id);


--
-- Name: fs_root_folder_package_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY fs_root_folders
    ADD CONSTRAINT fs_root_folder_package_id_pk PRIMARY KEY (package_id);


--
-- Name: fs_rss_subscrs_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY fs_rss_subscrs
    ADD CONSTRAINT fs_rss_subscrs_pk PRIMARY KEY (subscr_id);


--
-- Name: general_comments_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY general_comments
    ADD CONSTRAINT general_comments_pk PRIMARY KEY (comment_id);


--
-- Name: general_objects_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY general_objects
    ADD CONSTRAINT general_objects_pk PRIMARY KEY (object_id);


--
-- Name: get_path_abs_cursor_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY get_path_abs_cursor
    ADD CONSTRAINT get_path_abs_cursor_pkey PRIMARY KEY (sid, pos);


--
-- Name: get_path_rel_cursor_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY get_path_rel_cursor
    ADD CONSTRAINT get_path_rel_cursor_pkey PRIMARY KEY (sid, pos);


--
-- Name: group_element_index_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY group_element_index
    ADD CONSTRAINT group_element_index_pk PRIMARY KEY (element_id, group_id, rel_id);


--
-- Name: group_rels_group_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY group_rels
    ADD CONSTRAINT group_rels_group_rel_id_pk PRIMARY KEY (group_rel_id);


--
-- Name: group_types_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY group_types
    ADD CONSTRAINT group_types_pk PRIMARY KEY (group_type);


--
-- Name: groups_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY groups
    ADD CONSTRAINT groups_pk PRIMARY KEY (group_id);


--
-- Name: gtr_group_rel_type_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY group_type_rels
    ADD CONSTRAINT gtr_group_rel_type_id_pk PRIMARY KEY (group_rel_type_id);


--
-- Name: host_node_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY host_node_map
    ADD CONSTRAINT host_node_map_pk PRIMARY KEY (node_id);


--
-- Name: images_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY images
    ADD CONSTRAINT images_pk PRIMARY KEY (image_id);


--
-- Name: journal_entries_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY journal_entries
    ADD CONSTRAINT journal_entries_pk PRIMARY KEY (journal_id);


--
-- Name: lang_message_keys_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY lang_message_keys
    ADD CONSTRAINT lang_message_keys_pk PRIMARY KEY (message_key, package_key);


--
-- Name: lang_messages_audit_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY lang_messages_audit
    ADD CONSTRAINT lang_messages_audit_pk PRIMARY KEY (audit_id);


--
-- Name: lang_messages_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY lang_messages
    ADD CONSTRAINT lang_messages_pk PRIMARY KEY (message_key, package_key, locale);


--
-- Name: lang_translate_columns_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY lang_translate_columns
    ADD CONSTRAINT lang_translate_columns_pkey PRIMARY KEY (column_id);


--
-- Name: lang_translation_registry_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY lang_translation_registry
    ADD CONSTRAINT lang_translation_registry_pk PRIMARY KEY (on_what_id, on_which_table, locale);


--
-- Name: lob_data_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY lob_data
    ADD CONSTRAINT lob_data_pkey PRIMARY KEY (lob_id, segment);


--
-- Name: lobs_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY lobs
    ADD CONSTRAINT lobs_pkey PRIMARY KEY (lob_id);


--
-- Name: logger_entries_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY logger_entries
    ADD CONSTRAINT logger_entries_pk PRIMARY KEY (entry_id);


--
-- Name: logger_projections_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY logger_projections
    ADD CONSTRAINT logger_projections_pk PRIMARY KEY (projection_id);


--
-- Name: logger_projects_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY logger_projects
    ADD CONSTRAINT logger_projects_pk PRIMARY KEY (project_id);


--
-- Name: logger_variables_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY logger_variables
    ADD CONSTRAINT logger_variables_pk PRIMARY KEY (variable_id);


--
-- Name: membership_rel_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY membership_rels
    ADD CONSTRAINT membership_rel_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: na_aggregators_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY na_aggregators
    ADD CONSTRAINT na_aggregators_pk PRIMARY KEY (aggregator_id);


--
-- Name: na_items_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY na_items
    ADD CONSTRAINT na_items_pk PRIMARY KEY (item_id);


--
-- Name: na_purges_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY na_purges
    ADD CONSTRAINT na_purges_pk PRIMARY KEY (purge_id);


--
-- Name: na_saved_items_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY na_saved_items
    ADD CONSTRAINT na_saved_items_pk PRIMARY KEY (item_id, aggregator_id);


--
-- Name: na_sources_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY na_sources
    ADD CONSTRAINT na_sources_pk PRIMARY KEY (source_id);


--
-- Name: na_subscriptions_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY na_subscriptions
    ADD CONSTRAINT na_subscriptions_pk PRIMARY KEY (aggregator_id, source_id);


--
-- Name: na_user_prefs_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY na_user_preferences
    ADD CONSTRAINT na_user_prefs_pk PRIMARY KEY (user_id, package_id);


--
-- Name: notif_deliv_meth_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY notification_delivery_methods
    ADD CONSTRAINT notif_deliv_meth_pk PRIMARY KEY (delivery_method_id);


--
-- Name: notif_interv_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY notification_intervals
    ADD CONSTRAINT notif_interv_id_pk PRIMARY KEY (interval_id);


--
-- Name: notif_notif_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY notifications
    ADD CONSTRAINT notif_notif_id_pk PRIMARY KEY (notification_id);


--
-- Name: notif_repl_repl_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY notification_replies
    ADD CONSTRAINT notif_repl_repl_id_pk PRIMARY KEY (reply_id);


--
-- Name: notif_request_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY notification_requests
    ADD CONSTRAINT notif_request_id_pk PRIMARY KEY (request_id);


--
-- Name: notif_type_deliv_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY notification_types_del_methods
    ADD CONSTRAINT notif_type_deliv_pk PRIMARY KEY (type_id, delivery_method_id);


--
-- Name: notif_type_int_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY notification_types_intervals
    ADD CONSTRAINT notif_type_int_pk PRIMARY KEY (type_id, interval_id);


--
-- Name: notif_type_type_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY notification_types
    ADD CONSTRAINT notif_type_type_id_pk PRIMARY KEY (type_id);


--
-- Name: notification_email_hold_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY notification_email_hold
    ADD CONSTRAINT notification_email_hold_pk PRIMARY KEY (reply_id);


--
-- Name: pages_package_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY pages
    ADD CONSTRAINT pages_package_id_pk PRIMARY KEY (package_id);


--
-- Name: parties_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY parties
    ADD CONSTRAINT parties_pk PRIMARY KEY (party_id);


--
-- Name: party_approved_member_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY party_approved_member_map
    ADD CONSTRAINT party_approved_member_map_pk PRIMARY KEY (party_id, member_id, tag);


--
-- Name: persons_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY persons
    ADD CONSTRAINT persons_pk PRIMARY KEY (person_id);


--
-- Name: pinds_blog_categories_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY pinds_blog_categories
    ADD CONSTRAINT pinds_blog_categories_pk PRIMARY KEY (category_id);


--
-- Name: pinds_blog_entries_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY pinds_blog_entries
    ADD CONSTRAINT pinds_blog_entries_pk PRIMARY KEY (entry_id);


--
-- Name: previous_place_list_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY previous_place_list
    ADD CONSTRAINT previous_place_list_pk PRIMARY KEY (session_id, rcnt);


--
-- Name: quard_list_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY guard_list
    ADD CONSTRAINT quard_list_pk PRIMARY KEY (session_id, rcnt);


--
-- Name: recurrence_interval_type_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY recurrence_interval_types
    ADD CONSTRAINT recurrence_interval_type_pk PRIMARY KEY (interval_type);


--
-- Name: recurrences_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY recurrences
    ADD CONSTRAINT recurrences_pk PRIMARY KEY (recurrence_id);


--
-- Name: rel_constraints_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY rel_constraints
    ADD CONSTRAINT rel_constraints_pk PRIMARY KEY (constraint_id);


--
-- Name: rel_segments_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY rel_segments
    ADD CONSTRAINT rel_segments_pk PRIMARY KEY (segment_id);


--
-- Name: rl_resource_category_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY rl_resource_category
    ADD CONSTRAINT rl_resource_category_id_pk PRIMARY KEY (category_id);


--
-- Name: rl_resource_category_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY rl_resource_category_type
    ADD CONSTRAINT rl_resource_category_pk PRIMARY KEY (category_id);


--
-- Name: rl_resource_resource_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY rl_resources
    ADD CONSTRAINT rl_resource_resource_id_pk PRIMARY KEY (resource_item_id);


--
-- Name: rl_resource_revs_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY rl_resources_revisions
    ADD CONSTRAINT rl_resource_revs_id_pk PRIMARY KEY (resource_revision_id);


--
-- Name: rss_gen_subscrs_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY rss_gen_subscrs
    ADD CONSTRAINT rss_gen_subscrs_id_pk PRIMARY KEY (subscr_id);


--
-- Name: rss_gen_subscrs_impl_con_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY rss_gen_subscrs
    ADD CONSTRAINT rss_gen_subscrs_impl_con_un UNIQUE (impl_id, summary_context_id);


--
-- Name: sec_session_properties_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY sec_session_properties
    ADD CONSTRAINT sec_session_properties_pkey PRIMARY KEY (session_id, module, property_name);


--
-- Name: secret_tokens_token_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY secret_tokens
    ADD CONSTRAINT secret_tokens_token_id_pk PRIMARY KEY (token_id);


--
-- Name: services_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY apm_services
    ADD CONSTRAINT services_pk PRIMARY KEY (service_id);


--
-- Name: sgc_callback_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY subsite_callbacks
    ADD CONSTRAINT sgc_callback_id_pk PRIMARY KEY (callback_id);


--
-- Name: site_node_object_mappings_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY site_node_object_mappings
    ADD CONSTRAINT site_node_object_mappings_pk PRIMARY KEY (object_id);


--
-- Name: site_node_sel_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY site_nodes_selection
    ADD CONSTRAINT site_node_sel_id_pk PRIMARY KEY (node_id);


--
-- Name: site_nodes_node_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY site_nodes
    ADD CONSTRAINT site_nodes_node_id_pk PRIMARY KEY (node_id);


--
-- Name: syndication_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY syndication
    ADD CONSTRAINT syndication_pk PRIMARY KEY (object_id);


--
-- Name: target_place_list_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY target_place_list
    ADD CONSTRAINT target_place_list_pk PRIMARY KEY (session_id, rcnt);


--
-- Name: time_intervals_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY time_intervals
    ADD CONSTRAINT time_intervals_pk PRIMARY KEY (interval_id);


--
-- Name: timezones_tz_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY timezones
    ADD CONSTRAINT timezones_tz_id_pk PRIMARY KEY (tz_id);


--
-- Name: ttl_area_assignments_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttl_area_assignments
    ADD CONSTRAINT ttl_area_assignments_pk PRIMARY KEY (area_id, user_id);


--
-- Name: ttl_areas_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttl_areas
    ADD CONSTRAINT ttl_areas_pk PRIMARY KEY (area_id);


--
-- Name: ttl_assignments_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttl_assignments
    ADD CONSTRAINT ttl_assignments_pk PRIMARY KEY (ticket_id, user_id);


--
-- Name: ttl_comments_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttl_comments
    ADD CONSTRAINT ttl_comments_pk PRIMARY KEY (comment_id);


--
-- Name: ttl_prefs_user_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttl_prefs
    ADD CONSTRAINT ttl_prefs_user_pk PRIMARY KEY (user_id);


--
-- Name: ttl_status_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttl_status
    ADD CONSTRAINT ttl_status_pk PRIMARY KEY (status);


--
-- Name: ttl_tickets_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttl_tickets
    ADD CONSTRAINT ttl_tickets_pk PRIMARY KEY (ticket_id);


--
-- Name: user_portraits_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY user_portraits
    ADD CONSTRAINT user_portraits_pk PRIMARY KEY (user_id);


--
-- Name: user_preferences_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY user_preferences
    ADD CONSTRAINT user_preferences_pk PRIMARY KEY (user_id);


--
-- Name: users_authority_username_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_authority_username_un UNIQUE (authority_id, username);


--
-- Name: users_email_image_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY users_email_image
    ADD CONSTRAINT users_email_image_pkey PRIMARY KEY (email_image_id);


--
-- Name: users_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_pk PRIMARY KEY (user_id);


--
-- Name: weblogger_blogroll_entries_id_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY weblogger_blogroll_entries
    ADD CONSTRAINT weblogger_blogroll_entries_id_pk PRIMARY KEY (link_id);


--
-- Name: weblogger_channels_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY weblogger_channels
    ADD CONSTRAINT weblogger_channels_pk PRIMARY KEY (channel_id);


--
-- Name: weblogger_chnls_package_user_un; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY weblogger_channels
    ADD CONSTRAINT weblogger_chnls_package_user_un UNIQUE (package_id, user_id);


--
-- Name: weblogger_ping_urls_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY weblogger_ping_urls
    ADD CONSTRAINT weblogger_ping_urls_pk PRIMARY KEY (package_id, ping_url);


--
-- Name: wf_arc_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_arcs
    ADD CONSTRAINT wf_arc_pk PRIMARY KEY (workflow_key, transition_key, place_key, direction);


--
-- Name: wf_article_cases_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_article_cases
    ADD CONSTRAINT wf_article_cases_pkey PRIMARY KEY (case_id);


--
-- Name: wf_attr_val_audit_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_attribute_value_audit
    ADD CONSTRAINT wf_attr_val_audit_pk PRIMARY KEY (case_id, attribute_id, journal_id);


--
-- Name: wf_case_assign_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_case_assignments
    ADD CONSTRAINT wf_case_assign_pk PRIMARY KEY (case_id, role_key, party_id);


--
-- Name: wf_case_deadline_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_case_deadlines
    ADD CONSTRAINT wf_case_deadline_pk PRIMARY KEY (case_id, transition_key);


--
-- Name: wf_cases_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_cases
    ADD CONSTRAINT wf_cases_pk PRIMARY KEY (case_id);


--
-- Name: wf_context_assign_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_context_assignments
    ADD CONSTRAINT wf_context_assign_pk PRIMARY KEY (context_key, workflow_key, role_key, party_id);


--
-- Name: wf_context_panels_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_context_task_panels
    ADD CONSTRAINT wf_context_panels_pk PRIMARY KEY (context_key, workflow_key, transition_key, sort_order);


--
-- Name: wf_context_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_contexts
    ADD CONSTRAINT wf_context_pk PRIMARY KEY (context_key);


--
-- Name: wf_context_role_info_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_context_role_info
    ADD CONSTRAINT wf_context_role_info_pk PRIMARY KEY (context_key, workflow_key, role_key);


--
-- Name: wf_context_transition_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_context_transition_info
    ADD CONSTRAINT wf_context_transition_pk PRIMARY KEY (context_key, workflow_key, transition_key);


--
-- Name: wf_context_workflow_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_context_workflow_info
    ADD CONSTRAINT wf_context_workflow_pk PRIMARY KEY (context_key, workflow_key);


--
-- Name: wf_place_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_places
    ADD CONSTRAINT wf_place_pk PRIMARY KEY (workflow_key, place_key);


--
-- Name: wf_role_asgn_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_transition_role_assign_map
    ADD CONSTRAINT wf_role_asgn_map_pk PRIMARY KEY (workflow_key, transition_key, assign_role_key);


--
-- Name: wf_role_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_roles
    ADD CONSTRAINT wf_role_pk PRIMARY KEY (workflow_key, role_key);


--
-- Name: wf_task_assignments_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_task_assignments
    ADD CONSTRAINT wf_task_assignments_pk PRIMARY KEY (task_id, party_id);


--
-- Name: wf_task_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_tasks
    ADD CONSTRAINT wf_task_pk PRIMARY KEY (task_id);


--
-- Name: wf_token_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_tokens
    ADD CONSTRAINT wf_token_pk PRIMARY KEY (token_id);


--
-- Name: wf_trans_attr_map_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_transition_attribute_map
    ADD CONSTRAINT wf_trans_attr_map_pk PRIMARY KEY (workflow_key, transition_key, attribute_id);


--
-- Name: wf_transition_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_transitions
    ADD CONSTRAINT wf_transition_pk PRIMARY KEY (workflow_key, transition_key);


--
-- Name: wf_workflows_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY wf_workflows
    ADD CONSTRAINT wf_workflows_pk PRIMARY KEY (workflow_key);


--
-- Name: acs_attr_desc_attr_name_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_attr_desc_attr_name_idx ON acs_attribute_descriptions USING btree (attribute_name);


--
-- Name: acs_attr_desc_obj_type_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_attr_desc_obj_type_idx ON acs_attribute_descriptions USING btree (object_type);


--
-- Name: acs_attr_values_attr_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_attr_values_attr_id_idx ON acs_attribute_values USING btree (attribute_id);


--
-- Name: acs_attributes_attr_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_attributes_attr_name_un ON acs_attributes USING btree (attribute_name, object_type);


--
-- Name: acs_attributes_pretty_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_attributes_pretty_name_un ON acs_attributes USING btree (pretty_name, object_type);


--
-- Name: acs_attributes_sort_order_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_attributes_sort_order_un ON acs_attributes USING btree (attribute_id, sort_order);


--
-- Name: acs_attrs_datatype_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_attrs_datatype_idx ON acs_attributes USING btree (datatype);


--
-- Name: acs_attrs_obj_type_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_attrs_obj_type_idx ON acs_attributes USING btree (object_type);


--
-- Name: acs_attrs_tbl_name_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_attrs_tbl_name_idx ON acs_attributes USING btree (table_name);


--
-- Name: acs_data_links_id_one_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_data_links_id_one_idx ON acs_data_links USING btree (object_id_one);


--
-- Name: acs_data_links_id_two_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_data_links_id_two_idx ON acs_data_links USING btree (object_id_two);


--
-- Name: acs_enum_values_attr_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_enum_values_attr_id_idx ON acs_enum_values USING btree (attribute_id);


--
-- Name: acs_enum_values_pretty_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_enum_values_pretty_name_un ON acs_enum_values USING btree (attribute_id, pretty_name);


--
-- Name: acs_enum_values_sort_order_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_enum_values_sort_order_un ON acs_enum_values USING btree (attribute_id, sort_order);


--
-- Name: acs_events_activity_id_ids; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_events_activity_id_ids ON acs_events USING btree (activity_id);


--
-- Name: acs_events_recurrence_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_events_recurrence_id_idx ON acs_events USING btree (recurrence_id);


--
-- Name: acs_mail_bodies_body_from_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_mail_bodies_body_from_idx ON acs_mail_bodies USING btree (body_from);


--
-- Name: acs_mail_bodies_body_reply_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_mail_bodies_body_reply_idx ON acs_mail_bodies USING btree (body_reply_to);


--
-- Name: acs_mail_bodies_h_m_id_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_mail_bodies_h_m_id_un ON acs_mail_bodies USING btree (header_message_id);


--
-- Name: acs_mail_bodies_item_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_mail_bodies_item_id_idx ON acs_mail_bodies USING btree (content_item_id);


--
-- Name: acs_mail_body_hdrs_body_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_mail_body_hdrs_body_id_idx ON acs_mail_body_headers USING btree (body_id);


--
-- Name: acs_mail_links_body_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_mail_links_body_id_idx ON acs_mail_links USING btree (body_id);


--
-- Name: acs_mail_mpp_cr_item_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_mail_mpp_cr_item_id_idx ON acs_mail_multipart_parts USING btree (content_item_id);


--
-- Name: acs_messages_reply_to_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_messages_reply_to_idx ON acs_messages USING btree (reply_to);


--
-- Name: acs_messages_rfc822_id_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_messages_rfc822_id_un ON acs_messages USING btree (rfc822_id);


--
-- Name: acs_messages_sender_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_messages_sender_idx ON acs_messages USING btree (sender);


--
-- Name: acs_messages_sent_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_messages_sent_idx ON acs_messages USING btree (sent_date);


--
-- Name: acs_messages_tree_skey_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_messages_tree_skey_idx ON acs_messages USING btree (tree_sortkey);


--
-- Name: acs_mo_object_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_mo_object_id_idx ON acs_magic_objects USING btree (object_id);


--
-- Name: acs_named_objs_name_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_named_objs_name_ix ON acs_named_objects USING btree (object_name);


--
-- Name: acs_named_objs_package_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_named_objs_package_ix ON acs_named_objects USING btree (package_id);


--
-- Name: acs_obj_ctx_idx_ancestor_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_obj_ctx_idx_ancestor_idx ON acs_object_context_index USING btree (ancestor_id);


--
-- Name: acs_obj_types_pretty_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_obj_types_pretty_name_un ON acs_object_types USING btree (pretty_name);


--
-- Name: acs_obj_types_pretty_plural_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_obj_types_pretty_plural_un ON acs_object_types USING btree (pretty_plural);


--
-- Name: acs_obj_types_supertype_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_obj_types_supertype_idx ON acs_object_types USING btree (supertype);


--
-- Name: acs_obj_types_tree_skey_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_obj_types_tree_skey_idx ON acs_object_types USING btree (tree_sortkey);


--
-- Name: acs_object_rels_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_object_rels_un ON acs_rels USING btree (rel_type, object_id_one, object_id_two);


--
-- Name: acs_object_types_pkg_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_object_types_pkg_name_un ON acs_object_types USING btree (package_name);


--
-- Name: acs_object_types_table_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_object_types_table_name_un ON acs_object_types USING btree (table_name);


--
-- Name: acs_objects_context_object_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_objects_context_object_un ON acs_objects USING btree (context_id, object_id);


--
-- Name: acs_objects_creation_user_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_objects_creation_user_idx ON acs_objects USING btree (creation_user);


--
-- Name: acs_objects_modify_user_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_objects_modify_user_idx ON acs_objects USING btree (modifying_user);


--
-- Name: acs_objects_object_type_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_objects_object_type_idx ON acs_objects USING btree (object_type);


--
-- Name: acs_objects_package_object_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_objects_package_object_idx ON acs_objects USING btree (package_id, object_id);


--
-- Name: acs_objects_title_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_objects_title_idx ON acs_objects USING btree (title);


--
-- Name: acs_objtype_tbls_objtype_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_objtype_tbls_objtype_idx ON acs_object_type_tables USING btree (object_type);


--
-- Name: acs_permissions_grantee_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_permissions_grantee_idx ON acs_permissions USING btree (grantee_id);


--
-- Name: acs_permissions_privilege_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_permissions_privilege_idx ON acs_permissions USING btree (privilege);


--
-- Name: acs_priv_desc_map_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_priv_desc_map_idx ON acs_privilege_descendant_map USING btree (descendant);


--
-- Name: acs_priv_hier_child_priv_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_priv_hier_child_priv_idx ON acs_privilege_hierarchy USING btree (child_privilege);


--
-- Name: acs_rel_types_objtypeone_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_rel_types_objtypeone_idx ON acs_rel_types USING btree (object_type_one);


--
-- Name: acs_rel_types_objtypetwo_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_rel_types_objtypetwo_idx ON acs_rel_types USING btree (object_type_two);


--
-- Name: acs_rel_types_role_one_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_rel_types_role_one_idx ON acs_rel_types USING btree (role_one);


--
-- Name: acs_rel_types_role_two_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_rel_types_role_two_idx ON acs_rel_types USING btree (role_two);


--
-- Name: acs_rels_object_id_one_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_rels_object_id_one_idx ON acs_rels USING btree (object_id_one);


--
-- Name: acs_rels_object_id_two_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_rels_object_id_two_idx ON acs_rels USING btree (object_id_two);


--
-- Name: acs_sc_contracts_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_sc_contracts_name_un ON acs_sc_contracts USING btree (contract_name);


--
-- Name: acs_sc_impl_alias_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_sc_impl_alias_un ON acs_sc_impl_aliases USING btree (impl_name, impl_contract_name, impl_operation_name);


--
-- Name: acs_sc_msg_types_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX acs_sc_msg_types_name_un ON acs_sc_msg_types USING btree (msg_type_name);


--
-- Name: acs_stat_attrs_attr_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX acs_stat_attrs_attr_id_idx ON acs_static_attr_values USING btree (attribute_id);


--
-- Name: ad_locale_name_unq; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX ad_locale_name_unq ON ad_locales USING btree (label);


--
-- Name: am_meeting_mtg_type_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX am_meeting_mtg_type_id_idx ON am_meeting USING btree (type_id);


--
-- Name: am_meeting_todo_ass_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX am_meeting_todo_ass_id_idx ON am_meeting_todo USING btree (assignee);


--
-- Name: am_meeting_todo_meet_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX am_meeting_todo_meet_id_idx ON am_meeting_todo USING btree (meeting_id);


--
-- Name: apm_package_callbacks_vt_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX apm_package_callbacks_vt_un ON apm_package_callbacks USING btree (version_id, type);


--
-- Name: apm_package_deps_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX apm_package_deps_un ON apm_package_dependencies USING btree (version_id, service_uri);


--
-- Name: apm_package_types_pretty_n_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX apm_package_types_pretty_n_un ON apm_package_types USING btree (pretty_name);


--
-- Name: apm_package_types_pretty_pl_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX apm_package_types_pretty_pl_un ON apm_package_types USING btree (pretty_plural);


--
-- Name: apm_package_vers_id_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX apm_package_vers_id_name_un ON apm_package_versions USING btree (package_key, version_name);


--
-- Name: apm_package_vers_ver_uri_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX apm_package_vers_ver_uri_un ON apm_package_versions USING btree (version_uri);


--
-- Name: apm_packages_package_key_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX apm_packages_package_key_idx ON apm_packages USING btree (package_key);


--
-- Name: apm_packages_types_p_uri_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX apm_packages_types_p_uri_un ON apm_package_types USING btree (package_uri);


--
-- Name: apm_par_vals_parameter_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX apm_par_vals_parameter_idx ON apm_parameter_values USING btree (parameter_id);


--
-- Name: apm_parameter_values_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX apm_parameter_values_un ON apm_parameter_values USING btree (package_id, parameter_id);


--
-- Name: apm_parameters_package_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX apm_parameters_package_idx ON apm_parameters USING btree (package_key);


--
-- Name: apm_paramters_attr_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX apm_paramters_attr_name_un ON apm_parameters USING btree (parameter_name, package_key);


--
-- Name: apm_pkg_owners_version_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX apm_pkg_owners_version_idx ON apm_package_owners USING btree (version_id);


--
-- Name: app_groups_package_id_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX app_groups_package_id_un ON application_groups USING btree (package_id);


--
-- Name: attachments_fsr_fm_folder_id_i; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX attachments_fsr_fm_folder_id_i ON attachments_fs_root_folder_map USING btree (folder_id);


--
-- Name: attachments_item_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX attachments_item_id_idx ON attachments USING btree (item_id);


--
-- Name: auth_batch_job_ent_job_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX auth_batch_job_ent_job_idx ON auth_batch_job_entries USING btree (job_id);


--
-- Name: auth_batch_job_ent_user_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX auth_batch_job_ent_user_idx ON auth_batch_job_entries USING btree (user_id);


--
-- Name: auth_batch_jobs_auth_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX auth_batch_jobs_auth_idx ON auth_batch_jobs USING btree (authority_id);


--
-- Name: auth_batch_jobs_user_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX auth_batch_jobs_user_idx ON auth_batch_jobs USING btree (creation_user);


--
-- Name: cal_items_on_which_calendar_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cal_items_on_which_calendar_idx ON cal_items USING btree (on_which_calendar);


--
-- Name: cat_object_map_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX cat_object_map_ix ON category_object_map USING btree (object_id, category_id);


--
-- Name: cat_tree_map_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX cat_tree_map_ix ON category_tree_map USING btree (tree_id, object_id);


--
-- Name: categories_left_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX categories_left_ix ON categories USING btree (tree_id, left_ind);


--
-- Name: categories_parent_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX categories_parent_ix ON categories USING btree (parent_id, category_id);


--
-- Name: category_links_rev_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX category_links_rev_ix ON category_links USING btree (to_category_id, from_category_id);


--
-- Name: category_results_similarity_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX category_results_similarity_ix ON category_search_results USING btree (query_id, similarity);


--
-- Name: category_search_date_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX category_search_date_ix ON category_search USING btree (last_queried);


--
-- Name: category_search_ind_query_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX category_search_ind_query_ix ON category_search_index USING btree (query_id);


--
-- Name: category_search_ind_trigram_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX category_search_ind_trigram_ix ON category_search_index USING btree (trigram);


--
-- Name: category_syn_index_synonym_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX category_syn_index_synonym_ix ON category_synonym_index USING btree (synonym_id);


--
-- Name: category_syn_index_trigram_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX category_syn_index_trigram_ix ON category_synonym_index USING btree (trigram);


--
-- Name: category_synonyms_locale_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX category_synonyms_locale_ix ON category_synonyms USING btree (category_id, locale);


--
-- Name: category_synonyms_name_ix; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX category_synonyms_name_ix ON category_synonyms USING btree (category_id, name);


--
-- Name: cr_child_rels_by_parent; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_child_rels_by_parent ON cr_child_rels USING btree (parent_id);


--
-- Name: cr_child_rels_unq_id; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX cr_child_rels_unq_id ON cr_child_rels USING btree (parent_id, child_id);


--
-- Name: cr_cont_mimetypmap_mimetyp_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_cont_mimetypmap_mimetyp_idx ON cr_content_mime_type_map USING btree (mime_type);


--
-- Name: cr_extension_mime_type_map_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_extension_mime_type_map_idx ON cr_extension_mime_type_map USING btree (mime_type);


--
-- Name: cr_folder_typ_map_cont_typ_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_folder_typ_map_cont_typ_idx ON cr_folder_type_map USING btree (content_type);


--
-- Name: cr_folders_package_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_folders_package_id_idx ON cr_folders USING btree (package_id);


--
-- Name: cr_item_keyword_map_kw_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_item_keyword_map_kw_id_idx ON cr_item_keyword_map USING btree (keyword_id);


--
-- Name: cr_item_publish_audit_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_item_publish_audit_idx ON cr_item_publish_audit USING btree (item_id);


--
-- Name: cr_item_rel_unq; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX cr_item_rel_unq ON cr_item_rels USING btree (item_id, related_object_id, relation_tag);


--
-- Name: cr_item_rels_rel_obj_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_item_rels_rel_obj_id_idx ON cr_item_rels USING btree (related_object_id);


--
-- Name: cr_items_by_content_type; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_items_by_content_type ON cr_items USING btree (content_type);


--
-- Name: cr_items_by_latest_revision; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX cr_items_by_latest_revision ON cr_items USING btree (latest_revision);


--
-- Name: cr_items_by_live_revision; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX cr_items_by_live_revision ON cr_items USING btree (live_revision);


--
-- Name: cr_items_by_locale; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_items_by_locale ON cr_items USING btree (locale);


--
-- Name: cr_items_by_parent_id; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_items_by_parent_id ON cr_items USING btree (parent_id);


--
-- Name: cr_items_name; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_items_name ON cr_items USING btree (name);


--
-- Name: cr_items_unique_id; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX cr_items_unique_id ON cr_items USING btree (parent_id, item_id);


--
-- Name: cr_items_unique_name; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX cr_items_unique_name ON cr_items USING btree (parent_id, name);


--
-- Name: cr_itmap_by_item_id; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_itmap_by_item_id ON cr_item_template_map USING btree (item_id);


--
-- Name: cr_itmap_by_template_id; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_itmap_by_template_id ON cr_item_template_map USING btree (template_id);


--
-- Name: cr_itmap_by_use_context; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_itmap_by_use_context ON cr_item_template_map USING btree (use_context);


--
-- Name: cr_keywords_parent_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_keywords_parent_id_idx ON cr_keywords USING btree (parent_id);


--
-- Name: cr_locale_name_unq; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX cr_locale_name_unq ON cr_locales USING btree (label);


--
-- Name: cr_news_appuser_id_fk; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_news_appuser_id_fk ON cr_news USING btree (approval_user);


--
-- Name: cr_revisions_by_mime_type; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_revisions_by_mime_type ON cr_revisions USING btree (mime_type);


--
-- Name: cr_revisions_item_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_revisions_item_id_idx ON cr_revisions USING btree (item_id);


--
-- Name: cr_revisions_lob_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_revisions_lob_idx ON cr_revisions USING btree (lob);


--
-- Name: cr_revisions_publish_date_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_revisions_publish_date_idx ON cr_revisions USING btree (publish_date);


--
-- Name: cr_revisions_title_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_revisions_title_idx ON cr_revisions USING btree (title);


--
-- Name: cr_symlinks_by_target_id; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_symlinks_by_target_id ON cr_symlinks USING btree (target_id);


--
-- Name: cr_ttmap_by_content_type; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_ttmap_by_content_type ON cr_type_template_map USING btree (content_type);


--
-- Name: cr_ttmap_by_template_id; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_ttmap_by_template_id ON cr_type_template_map USING btree (template_id);


--
-- Name: cr_ttmap_by_use_context; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_ttmap_by_use_context ON cr_type_template_map USING btree (use_context);


--
-- Name: cr_type_children_chld_type_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_type_children_chld_type_idx ON cr_type_children USING btree (child_type);


--
-- Name: cr_type_relations_tgt_typ_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX cr_type_relations_tgt_typ_idx ON cr_type_relations USING btree (target_type);


--
-- Name: forums_forums_pkg_enable_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX forums_forums_pkg_enable_idx ON forums_forums USING btree (package_id, enabled_p);


--
-- Name: forums_mess_forum_sk_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX forums_mess_forum_sk_un ON forums_messages USING btree (forum_id, tree_sortkey);


--
-- Name: forums_mess_sk_forum_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX forums_mess_sk_forum_un ON forums_messages USING btree (tree_sortkey, forum_id);


--
-- Name: forums_messages_parent_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX forums_messages_parent_id_idx ON forums_messages USING btree (parent_id);


--
-- Name: forums_messages_user_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX forums_messages_user_id_idx ON forums_messages USING btree (user_id);


--
-- Name: fs_root_folder_folder_id_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX fs_root_folder_folder_id_un ON fs_root_folders USING btree (folder_id);


--
-- Name: general_comments_object_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX general_comments_object_id_idx ON general_comments USING btree (object_id);


--
-- Name: general_objects_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX general_objects_un ON general_objects USING btree (on_which_table, on_what_id);


--
-- Name: group_elem_idx_element_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX group_elem_idx_element_idx ON group_element_index USING btree (element_id);


--
-- Name: group_elem_idx_group_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX group_elem_idx_group_idx ON group_element_index USING btree (group_id);


--
-- Name: group_elem_idx_rel_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX group_elem_idx_rel_id_idx ON group_element_index USING btree (rel_id);


--
-- Name: group_elem_idx_rel_type_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX group_elem_idx_rel_type_idx ON group_element_index USING btree (rel_type);


--
-- Name: group_rels_group_rel_type_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX group_rels_group_rel_type_un ON group_rels USING btree (group_id, rel_type);


--
-- Name: group_rels_rel_type_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX group_rels_rel_type_idx ON group_rels USING btree (rel_type);


--
-- Name: group_type_rels_rel_type_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX group_type_rels_rel_type_idx ON group_type_rels USING btree (rel_type);


--
-- Name: gtr_group_rel_types_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX gtr_group_rel_types_un ON group_type_rels USING btree (group_type, rel_type);


--
-- Name: journal_entries_object_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX journal_entries_object_idx ON journal_entries USING btree (object_id);


--
-- Name: lob_data_index; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX lob_data_index ON lob_data USING btree (lob_id);


--
-- Name: logger_project_pkg_map_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX logger_project_pkg_map_un ON logger_project_pkg_map USING btree (project_id, package_id);


--
-- Name: logger_project_var_map_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX logger_project_var_map_un ON logger_project_var_map USING btree (project_id, variable_id);


--
-- Name: ltc_u; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX ltc_u ON lang_translate_columns USING btree (on_which_table, on_what_column);


--
-- Name: na_aggregators_package_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX na_aggregators_package_id_idx ON na_aggregators USING btree (package_id);


--
-- Name: na_items_guid_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX na_items_guid_idx ON na_items USING btree (guid);


--
-- Name: na_items_source_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX na_items_source_id_idx ON na_items USING btree (source_id);


--
-- Name: na_purges_aggregator_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX na_purges_aggregator_id_idx ON na_purges USING btree (aggregator_id);


--
-- Name: na_saved_items_aggregator_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX na_saved_items_aggregator_id_idx ON na_saved_items USING btree (aggregator_id);


--
-- Name: na_subscriptions_aid_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX na_subscriptions_aid_idx ON na_subscriptions USING btree (aggregator_id);


--
-- Name: notif_deliv_short_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX notif_deliv_short_name_un ON notification_delivery_methods USING btree (short_name);


--
-- Name: notif_interv_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX notif_interv_name_un ON notification_intervals USING btree (name);


--
-- Name: notif_repl_from_user_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX notif_repl_from_user_idx ON notification_replies USING btree (from_user);


--
-- Name: notif_repl_object_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX notif_repl_object_id_idx ON notification_replies USING btree (object_id);


--
-- Name: notif_repl_type_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX notif_repl_type_id_idx ON notification_replies USING btree (type_id);


--
-- Name: notif_type_short_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX notif_type_short_name_un ON notification_types USING btree (short_name);


--
-- Name: notification_requests_t_o_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX notification_requests_t_o_idx ON notification_requests USING btree (type_id, object_id);


--
-- Name: notification_user_map_user_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX notification_user_map_user_idx ON notification_user_map USING btree (user_id);


--
-- Name: notifications_object_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX notifications_object_id_idx ON notifications USING btree (object_id);


--
-- Name: notifications_response_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX notifications_response_id_idx ON notifications USING btree (response_id);


--
-- Name: notifications_type_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX notifications_type_id_idx ON notifications USING btree (type_id);


--
-- Name: parties_email_lower_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX parties_email_lower_idx ON parties USING btree (lower((email)::text));


--
-- Name: parties_email_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX parties_email_un ON parties USING btree (email);


--
-- Name: party_member_member_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX party_member_member_idx ON party_approved_member_map USING btree (member_id);


--
-- Name: pinds_blog_entry_pck_entr_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX pinds_blog_entry_pck_entr_idx ON pinds_blog_entries USING btree (package_id, entry_date);


--
-- Name: priv_hier_sortkey_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX priv_hier_sortkey_idx ON acs_privilege_hierarchy_index USING btree (tree_sortkey);


--
-- Name: rc_segment_required_seg_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX rc_segment_required_seg_idx ON rc_segment_required_seg_map USING btree (required_rel_segment);


--
-- Name: rc_segment_required_seg_map_uq; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX rc_segment_required_seg_map_uq ON rc_segment_required_seg_map USING btree (rel_segment, rel_side, required_rel_segment);


--
-- Name: recurrences_interval_type_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX recurrences_interval_type_idx ON recurrences USING btree (interval_type);


--
-- Name: rel_constraint_req_rel_seg_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX rel_constraint_req_rel_seg_idx ON rel_constraints USING btree (required_rel_segment);


--
-- Name: rel_constraints_uq; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX rel_constraints_uq ON rel_constraints USING btree (rel_segment, rel_side, required_rel_segment);


--
-- Name: rel_segments_grp_rel_type_uq; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX rel_segments_grp_rel_type_uq ON rel_segments USING btree (group_id, rel_type);


--
-- Name: rel_segments_rel_type_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX rel_segments_rel_type_idx ON rel_segments USING btree (rel_type);


--
-- Name: rit_interval_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX rit_interval_name_un ON recurrence_interval_types USING btree (interval_name);


--
-- Name: sec_property_names; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX sec_property_names ON sec_session_properties USING btree (property_name);


--
-- Name: site_nodes_object_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX site_nodes_object_id_idx ON site_nodes USING btree (object_id);


--
-- Name: site_nodes_parent_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX site_nodes_parent_id_idx ON site_nodes USING btree (parent_id, object_id, node_id);


--
-- Name: site_nodes_tree_skey_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX site_nodes_tree_skey_idx ON site_nodes USING btree (tree_sortkey);


--
-- Name: site_nodes_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX site_nodes_un ON site_nodes USING btree (parent_id, name);


--
-- Name: subsite_callbacks_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX subsite_callbacks_un ON subsite_callbacks USING btree (object_type, event_type, callback_type, callback);


--
-- Name: tbp_comment_id_fk_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX tbp_comment_id_fk_idx ON trackback_pings USING btree (comment_id);


--
-- Name: time_intervals_start_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX time_intervals_start_idx ON time_intervals USING btree (start_date);


--
-- Name: timespans_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX timespans_idx ON timespans USING btree (timespan_id);


--
-- Name: timespans_interval_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX timespans_interval_id_idx ON timespans USING btree (interval_id);


--
-- Name: timezone_rules_idx1; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX timezone_rules_idx1 ON timezone_rules USING btree (tz_id, utc_start, utc_end);


--
-- Name: timezone_rules_idx2; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX timezone_rules_idx2 ON timezone_rules USING btree (tz_id, local_start, local_end);


--
-- Name: unique_schema_migrations; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX unique_schema_migrations ON schema_migrations USING btree (version);


--
-- Name: users_screen_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX users_screen_name_un ON users USING btree (screen_name);


--
-- Name: users_screenname_lower_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX users_screenname_lower_idx ON users USING btree (lower((screen_name)::text));


--
-- Name: users_username_lower_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX users_username_lower_idx ON users USING btree (lower((username)::text));


--
-- Name: wf_arcs_wf_key_place_key_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_arcs_wf_key_place_key_idx ON wf_arcs USING btree (workflow_key, place_key);


--
-- Name: wf_arcs_wf_key_trans_key_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_arcs_wf_key_trans_key_idx ON wf_arcs USING btree (workflow_key, transition_key);


--
-- Name: wf_attr_val_aud_attr_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_attr_val_aud_attr_id_idx ON wf_attribute_value_audit USING btree (attribute_id);


--
-- Name: wf_case_assgn_party_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_case_assgn_party_idx ON wf_case_assignments USING btree (party_id);


--
-- Name: wf_cases_context_key_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_cases_context_key_idx ON wf_cases USING btree (context_key);


--
-- Name: wf_cases_object_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_cases_object_id_idx ON wf_cases USING btree (object_id);


--
-- Name: wf_cases_workflow_key_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_cases_workflow_key_idx ON wf_cases USING btree (workflow_key);


--
-- Name: wf_contexts_context_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX wf_contexts_context_name_un ON wf_contexts USING btree (context_name);


--
-- Name: wf_ctx_assg_workflow_trans_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_ctx_assg_workflow_trans_idx ON wf_context_assignments USING btree (workflow_key, role_key);


--
-- Name: wf_ctx_panl_workflow_trans_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_ctx_panl_workflow_trans_idx ON wf_context_task_panels USING btree (workflow_key, transition_key);


--
-- Name: wf_ctx_trans_wf_trans_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_ctx_trans_wf_trans_idx ON wf_context_transition_info USING btree (workflow_key, transition_key);


--
-- Name: wf_places_wf_key_place_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX wf_places_wf_key_place_name_un ON wf_places USING btree (workflow_key, place_name);


--
-- Name: wf_role_asgn_map_wf_as_tr_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_role_asgn_map_wf_as_tr_idx ON wf_transition_role_assign_map USING btree (workflow_key, assign_role_key);


--
-- Name: wf_role_asgn_map_wf_trans_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_role_asgn_map_wf_trans_idx ON wf_transition_role_assign_map USING btree (workflow_key, transition_key);


--
-- Name: wf_roles_wf_key_role_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX wf_roles_wf_key_role_name_un ON wf_roles USING btree (workflow_key, role_name);


--
-- Name: wf_task_asgn_party_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_task_asgn_party_id_idx ON wf_task_assignments USING btree (party_id);


--
-- Name: wf_tasks_case_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_tasks_case_id_idx ON wf_tasks USING btree (case_id);


--
-- Name: wf_tasks_holding_user_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_tasks_holding_user_idx ON wf_tasks USING btree (holding_user);


--
-- Name: wf_tokens_case_id_idx; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE INDEX wf_tokens_case_id_idx ON wf_tokens USING btree (case_id);


--
-- Name: wf_trans_wf_key_trans_name_un; Type: INDEX; Schema: public; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX wf_trans_wf_key_trans_name_un ON wf_transitions USING btree (workflow_key, transition_name);


--
-- Name: cr_revisions_r; Type: RULE; Schema: public; Owner: -
--

CREATE RULE cr_revisions_r AS ON INSERT TO cr_revisionsi DO INSTEAD UPDATE cr_dummy SET val = (SELECT content_revision__new(new.title, (new.description)::character varying, now(), new.mime_type, new.nls_language, CASE WHEN (new.text IS NULL) THEN new.data ELSE new.text END, content_symlink__resolve(new.item_id), new.revision_id, now(), new.creation_user, new.creation_ip) AS content_revision__new);


--
-- Name: download_archive_descs_r; Type: RULE; Schema: public; Owner: -
--

CREATE RULE download_archive_descs_r AS ON INSERT TO download_archive_descsi DO INSTEAD (UPDATE cr_dummy SET val = (SELECT content_revision__new(new.title, (new.description)::character varying, now(), new.mime_type, new.nls_language, CASE WHEN (new.text IS NULL) THEN new.data ELSE new.text END, content_symlink__resolve(new.item_id), new.revision_id, now(), new.creation_user, new.creation_ip) AS content_revision__new); INSERT INTO download_archive_descs (archive_desc_id) VALUES (new.revision_id); );


--
-- Name: download_archives_r; Type: RULE; Schema: public; Owner: -
--

CREATE RULE download_archives_r AS ON INSERT TO download_archivesi DO INSTEAD (UPDATE cr_dummy SET val = (SELECT content_revision__new(new.title, (new.description)::character varying, now(), new.mime_type, new.nls_language, CASE WHEN (new.text IS NULL) THEN new.data ELSE new.text END, content_symlink__resolve(new.item_id), new.revision_id, now(), new.creation_user, new.creation_ip) AS content_revision__new); INSERT INTO download_archives (archive_id) VALUES (new.revision_id); );


--
-- Name: download_repository_r; Type: RULE; Schema: public; Owner: -
--

CREATE RULE download_repository_r AS ON INSERT TO download_repositoryi DO INSTEAD (UPDATE cr_dummy SET val = (SELECT content_revision__new(new.title, (new.description)::character varying, now(), new.mime_type, new.nls_language, CASE WHEN (new.text IS NULL) THEN new.data ELSE new.text END, content_symlink__resolve(new.item_id), new.revision_id, now(), new.creation_user, new.creation_ip) AS content_revision__new); INSERT INTO download_repository (repository_id) VALUES (new.revision_id); );


--
-- Name: fs_root_folders_r; Type: RULE; Schema: public; Owner: -
--

CREATE RULE fs_root_folders_r AS ON INSERT TO fs_root_foldersi DO INSTEAD (UPDATE cr_dummy SET val = (SELECT content_revision__new(new.title, (new.description)::character varying, now(), new.mime_type, new.nls_language, CASE WHEN (new.text IS NULL) THEN new.data ELSE new.text END, content_symlink__resolve(new.item_id), new.revision_id, now(), new.creation_user, new.creation_ip) AS content_revision__new); INSERT INTO fs_root_folders (folder_id) VALUES (new.revision_id); );


--
-- Name: images_r; Type: RULE; Schema: public; Owner: -
--

CREATE RULE images_r AS ON INSERT TO imagesi DO INSTEAD (UPDATE cr_dummy SET val = (SELECT content_revision__new(new.title, (new.description)::character varying, now(), new.mime_type, new.nls_language, CASE WHEN (new.text IS NULL) THEN new.data ELSE new.text END, content_symlink__resolve(new.item_id), new.revision_id, now(), new.creation_user, new.creation_ip) AS content_revision__new); INSERT INTO images (image_id, height, width) VALUES (new.revision_id, new.height, new.width); );


--
-- Name: acs_message_insert_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_message_insert_tr
    BEFORE INSERT ON acs_messages
    FOR EACH ROW
    EXECUTE PROCEDURE acs_message_insert_tr();


--
-- Name: acs_message_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_message_update_tr
    AFTER UPDATE ON acs_messages
    FOR EACH ROW
    EXECUTE PROCEDURE acs_message_update_tr();


--
-- Name: acs_object_type_insert_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_object_type_insert_tr
    BEFORE INSERT ON acs_object_types
    FOR EACH ROW
    EXECUTE PROCEDURE acs_object_type_insert_tr();


--
-- Name: acs_object_type_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_object_type_update_tr
    AFTER UPDATE ON acs_object_types
    FOR EACH ROW
    EXECUTE PROCEDURE acs_object_type_update_tr();


--
-- Name: acs_objects_context_id_del_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_objects_context_id_del_tr
    BEFORE DELETE ON acs_objects
    FOR EACH ROW
    EXECUTE PROCEDURE acs_objects_context_id_del_tr();


--
-- Name: acs_objects_context_id_in_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_objects_context_id_in_tr
    AFTER INSERT ON acs_objects
    FOR EACH ROW
    EXECUTE PROCEDURE acs_objects_context_id_in_tr();


--
-- Name: acs_objects_context_id_up_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_objects_context_id_up_tr
    AFTER UPDATE ON acs_objects
    FOR EACH ROW
    EXECUTE PROCEDURE acs_objects_context_id_up_tr();


--
-- Name: acs_objects_insert_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_objects_insert_tr
    BEFORE INSERT ON acs_objects
    FOR EACH ROW
    EXECUTE PROCEDURE acs_objects_insert_tr();


--
-- Name: acs_objects_last_mod_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_objects_last_mod_update_tr
    BEFORE UPDATE ON acs_objects
    FOR EACH ROW
    EXECUTE PROCEDURE acs_objects_last_mod_update_tr();


--
-- Name: acs_objects_mod_ip_insert_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_objects_mod_ip_insert_tr
    BEFORE INSERT ON acs_objects
    FOR EACH ROW
    EXECUTE PROCEDURE acs_objects_mod_ip_insert_tr();


--
-- Name: acs_objects_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_objects_update_tr
    AFTER UPDATE ON acs_objects
    FOR EACH ROW
    EXECUTE PROCEDURE acs_objects_update_tr();


--
-- Name: acs_permissions_lock_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_permissions_lock_tr
    BEFORE INSERT OR DELETE OR UPDATE ON acs_permissions_lock
    FOR EACH ROW
    EXECUTE PROCEDURE acs_permissions_lock_tr();


--
-- Name: acs_priv_del_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_priv_del_tr
    BEFORE DELETE ON acs_privileges
    FOR EACH ROW
    EXECUTE PROCEDURE acs_priv_del_tr();


--
-- Name: acs_priv_hier_ins_del_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_priv_hier_ins_del_tr
    AFTER INSERT OR DELETE ON acs_privilege_hierarchy
    FOR EACH ROW
    EXECUTE PROCEDURE acs_priv_hier_ins_del_tr();


--
-- Name: acs_rels_in_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER acs_rels_in_tr
    BEFORE INSERT OR UPDATE ON acs_rels
    FOR EACH ROW
    EXECUTE PROCEDURE acs_rels_in_tr();


--
-- Name: category_synonym__insert_cat_trans_trg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER category_synonym__insert_cat_trans_trg
    AFTER INSERT ON category_translations
    FOR EACH ROW
    EXECUTE PROCEDURE category_synonym__new_cat_trans_trg();


--
-- Name: category_synonym__update_cat_trans_trg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER category_synonym__update_cat_trans_trg
    BEFORE UPDATE ON category_translations
    FOR EACH ROW
    EXECUTE PROCEDURE category_synonym__edit_cat_trans_trg();


--
-- Name: composition_rels_del_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER composition_rels_del_tr
    BEFORE DELETE ON composition_rels
    FOR EACH ROW
    EXECUTE PROCEDURE composition_rels_del_tr();


--
-- Name: composition_rels_in_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER composition_rels_in_tr
    AFTER INSERT ON composition_rels
    FOR EACH ROW
    EXECUTE PROCEDURE composition_rels_in_tr();


--
-- Name: content_item_search__utrg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER content_item_search__utrg
    BEFORE UPDATE ON cr_items
    FOR EACH ROW
    EXECUTE PROCEDURE content_item_search__utrg();


--
-- Name: content_search__dtrg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER content_search__dtrg
    AFTER DELETE ON cr_revisions
    FOR EACH ROW
    EXECUTE PROCEDURE content_search__dtrg();


--
-- Name: content_search__itrg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER content_search__itrg
    AFTER INSERT ON cr_revisions
    FOR EACH ROW
    EXECUTE PROCEDURE content_search__itrg();


--
-- Name: content_search__utrg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER content_search__utrg
    AFTER UPDATE ON cr_revisions
    FOR EACH ROW
    EXECUTE PROCEDURE content_search__utrg();


--
-- Name: cr_cleanup_cr_files_del_trg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_cleanup_cr_files_del_trg
    BEFORE DELETE ON cr_revisions
    FOR EACH ROW
    EXECUTE PROCEDURE cr_cleanup_cr_files_del_trg();


--
-- Name: cr_dummy_ins_del_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_dummy_ins_del_tr
    BEFORE INSERT OR DELETE ON cr_dummy
    FOR EACH ROW
    EXECUTE PROCEDURE cr_dummy_ins_del_tr();


--
-- Name: cr_folder_del_ri_trg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_folder_del_ri_trg
    BEFORE DELETE ON cr_items
    FOR EACH ROW
    EXECUTE PROCEDURE cr_folder_del_ri_trg();


--
-- Name: cr_folder_ins_up_ri_trg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_folder_ins_up_ri_trg
    BEFORE INSERT OR UPDATE ON cr_folders
    FOR EACH ROW
    EXECUTE PROCEDURE cr_folder_ins_up_ri_trg();


--
-- Name: cr_items_publish_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_items_publish_update_tr
    BEFORE UPDATE ON cr_items
    FOR EACH ROW
    EXECUTE PROCEDURE cr_items_publish_update_tr();


--
-- Name: cr_items_tree_insert_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_items_tree_insert_tr
    BEFORE INSERT ON cr_items
    FOR EACH ROW
    EXECUTE PROCEDURE cr_items_tree_insert_tr();


--
-- Name: cr_items_tree_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_items_tree_update_tr
    AFTER UPDATE ON cr_items
    FOR EACH ROW
    EXECUTE PROCEDURE cr_items_tree_update_tr();


--
-- Name: cr_items_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_items_update_tr
    AFTER UPDATE ON cr_items
    FOR EACH ROW
    EXECUTE PROCEDURE cr_items_update_tr();


--
-- Name: cr_keywords_tree_insert_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_keywords_tree_insert_tr
    BEFORE INSERT ON cr_keywords
    FOR EACH ROW
    EXECUTE PROCEDURE cr_keywords_tree_insert_tr();


--
-- Name: cr_keywords_tree_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_keywords_tree_update_tr
    AFTER UPDATE ON cr_keywords
    FOR EACH ROW
    EXECUTE PROCEDURE cr_keywords_tree_update_tr();


--
-- Name: cr_keywords_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_keywords_update_tr
    AFTER UPDATE ON cr_keywords
    FOR EACH ROW
    EXECUTE PROCEDURE cr_keywords_update_tr();


--
-- Name: cr_revision_del_rev_ri_trg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_revision_del_rev_ri_trg
    AFTER DELETE ON cr_revisions
    FOR EACH ROW
    EXECUTE PROCEDURE cr_revision_del_rev_ri_trg();


--
-- Name: cr_revision_del_ri_trg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_revision_del_ri_trg
    AFTER DELETE ON cr_items
    FOR EACH ROW
    EXECUTE PROCEDURE cr_revision_del_ri_trg();


--
-- Name: cr_revision_ins_ri_trg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_revision_ins_ri_trg
    AFTER INSERT ON cr_items
    FOR EACH ROW
    EXECUTE PROCEDURE cr_revision_ins_ri_trg();


--
-- Name: cr_revision_latest_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_revision_latest_tr
    AFTER INSERT ON cr_revisions
    FOR EACH ROW
    EXECUTE PROCEDURE cr_revision_latest_tr();


--
-- Name: cr_revision_up_ri_trg; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_revision_up_ri_trg
    AFTER UPDATE ON cr_items
    FOR EACH ROW
    EXECUTE PROCEDURE cr_revision_up_ri_trg();


--
-- Name: cr_revisions_lob_trig; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_revisions_lob_trig
    BEFORE INSERT OR DELETE OR UPDATE ON cr_revisions
    FOR EACH ROW
    EXECUTE PROCEDURE on_lob_ref();


--
-- Name: cr_scheduled_release_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_scheduled_release_tr
    BEFORE INSERT ON cr_scheduled_release_job
    FOR EACH ROW
    EXECUTE PROCEDURE cr_scheduled_release_tr();


--
-- Name: cr_text_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_text_tr
    BEFORE INSERT ON cr_text
    FOR EACH ROW
    EXECUTE PROCEDURE cr_text_tr();


--
-- Name: cr_type_template_map_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER cr_type_template_map_tr
    BEFORE INSERT ON cr_type_template_map
    FOR EACH ROW
    EXECUTE PROCEDURE cr_type_template_map_tr();


--
-- Name: forums_mess_insert_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER forums_mess_insert_tr
    BEFORE INSERT ON forums_messages
    FOR EACH ROW
    EXECUTE PROCEDURE forums_mess_insert_tr();


--
-- Name: fs_package_items_delete_trig; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER fs_package_items_delete_trig
    BEFORE DELETE ON fs_root_folders
    FOR EACH ROW
    EXECUTE PROCEDURE fs_package_items_delete_trig();


--
-- Name: fs_root_folder_delete_trig; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER fs_root_folder_delete_trig
    AFTER DELETE ON fs_root_folders
    FOR EACH ROW
    EXECUTE PROCEDURE fs_root_folder_delete_trig();


--
-- Name: lobs_delete_trig; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER lobs_delete_trig
    BEFORE DELETE ON lobs
    FOR EACH ROW
    EXECUTE PROCEDURE on_lobs_delete();


--
-- Name: membership_rels_del_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER membership_rels_del_tr
    BEFORE DELETE ON membership_rels
    FOR EACH ROW
    EXECUTE PROCEDURE membership_rels_del_tr();


--
-- Name: membership_rels_in_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER membership_rels_in_tr
    AFTER INSERT ON membership_rels
    FOR EACH ROW
    EXECUTE PROCEDURE membership_rels_in_tr();


--
-- Name: membership_rels_up_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER membership_rels_up_tr
    BEFORE UPDATE ON membership_rels
    FOR EACH ROW
    EXECUTE PROCEDURE membership_rels_up_tr();


--
-- Name: parties_del_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER parties_del_tr
    BEFORE DELETE ON parties
    FOR EACH ROW
    EXECUTE PROCEDURE parties_del_tr();


--
-- Name: parties_in_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER parties_in_tr
    AFTER INSERT ON parties
    FOR EACH ROW
    EXECUTE PROCEDURE parties_in_tr();


--
-- Name: rel_constraints_del_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER rel_constraints_del_tr
    AFTER DELETE ON rel_constraints
    FOR EACH ROW
    EXECUTE PROCEDURE rel_constraints_del_tr();


--
-- Name: rel_constraints_ins_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER rel_constraints_ins_tr
    AFTER INSERT ON rel_constraints
    FOR EACH ROW
    EXECUTE PROCEDURE rel_constraints_ins_tr();


--
-- Name: rel_segments_del_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER rel_segments_del_tr
    BEFORE DELETE ON rel_segments
    FOR EACH ROW
    EXECUTE PROCEDURE rel_segments_del_tr();


--
-- Name: rel_segments_in_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER rel_segments_in_tr
    BEFORE INSERT ON rel_segments
    FOR EACH ROW
    EXECUTE PROCEDURE rel_segments_in_tr();


--
-- Name: site_node_insert_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER site_node_insert_tr
    BEFORE INSERT ON site_nodes
    FOR EACH ROW
    EXECUTE PROCEDURE site_node_insert_tr();


--
-- Name: site_node_update_tr; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER site_node_update_tr
    AFTER UPDATE ON site_nodes
    FOR EACH ROW
    EXECUTE PROCEDURE site_node_update_tr();


--
-- Name: $1; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_authorities
    ADD CONSTRAINT "$1" FOREIGN KEY (get_doc_impl_id) REFERENCES acs_objects(object_id);


--
-- Name: $2; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_authorities
    ADD CONSTRAINT "$2" FOREIGN KEY (process_doc_impl_id) REFERENCES acs_objects(object_id);


--
-- Name: acs_act_obj_mp_activity_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_activity_object_map
    ADD CONSTRAINT acs_act_obj_mp_activity_id_fk FOREIGN KEY (activity_id) REFERENCES acs_activities(activity_id) ON DELETE CASCADE;


--
-- Name: acs_act_obj_mp_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_activity_object_map
    ADD CONSTRAINT acs_act_obj_mp_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_activities_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_activities
    ADD CONSTRAINT acs_activities_fk FOREIGN KEY (activity_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_attr_descs_ob_tp_at_na_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_attribute_descriptions
    ADD CONSTRAINT acs_attr_descs_ob_tp_at_na_fk FOREIGN KEY (object_type, attribute_name) REFERENCES acs_attributes(object_type, attribute_name);


--
-- Name: acs_attr_descs_obj_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_attribute_descriptions
    ADD CONSTRAINT acs_attr_descs_obj_type_fk FOREIGN KEY (object_type) REFERENCES acs_object_types(object_type);


--
-- Name: acs_attr_values_attr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_attribute_values
    ADD CONSTRAINT acs_attr_values_attr_id_fk FOREIGN KEY (attribute_id) REFERENCES acs_attributes(attribute_id);


--
-- Name: acs_attr_values_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_attribute_values
    ADD CONSTRAINT acs_attr_values_obj_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_attributes_datatype_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_attributes
    ADD CONSTRAINT acs_attributes_datatype_fk FOREIGN KEY (datatype) REFERENCES acs_datatypes(datatype);


--
-- Name: acs_attributes_object_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_attributes
    ADD CONSTRAINT acs_attributes_object_type_fk FOREIGN KEY (object_type) REFERENCES acs_object_types(object_type);


--
-- Name: acs_attrs_obj_type_tbl_name_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_attributes
    ADD CONSTRAINT acs_attrs_obj_type_tbl_name_fk FOREIGN KEY (object_type, table_name) REFERENCES acs_object_type_tables(object_type, table_name);


--
-- Name: acs_cont_content_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_contents
    ADD CONSTRAINT acs_cont_content_id_fk FOREIGN KEY (content_id) REFERENCES acs_objects(object_id);


--
-- Name: acs_data_links_one_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_data_links
    ADD CONSTRAINT acs_data_links_one_fk FOREIGN KEY (object_id_one) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_data_links_two_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_data_links
    ADD CONSTRAINT acs_data_links_two_fk FOREIGN KEY (object_id_two) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_events_activity_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_events
    ADD CONSTRAINT acs_events_activity_id_fk FOREIGN KEY (activity_id) REFERENCES acs_activities(activity_id) ON DELETE SET NULL;


--
-- Name: acs_events_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_events
    ADD CONSTRAINT acs_events_fk FOREIGN KEY (event_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_events_recurrence_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_events
    ADD CONSTRAINT acs_events_recurrence_id_fk FOREIGN KEY (recurrence_id) REFERENCES recurrences(recurrence_id);


--
-- Name: acs_evnt_party_map_evnt_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_event_party_map
    ADD CONSTRAINT acs_evnt_party_map_evnt_id_fk FOREIGN KEY (event_id) REFERENCES acs_events(event_id) ON DELETE CASCADE;


--
-- Name: acs_evnt_party_map_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_event_party_map
    ADD CONSTRAINT acs_evnt_party_map_party_id_fk FOREIGN KEY (party_id) REFERENCES parties(party_id) ON DELETE CASCADE;


--
-- Name: acs_magic_objects_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_magic_objects
    ADD CONSTRAINT acs_magic_objects_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id);


--
-- Name: acs_mail_bodies_body_from_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_bodies
    ADD CONSTRAINT acs_mail_bodies_body_from_fk FOREIGN KEY (body_from) REFERENCES parties(party_id) ON DELETE SET NULL;


--
-- Name: acs_mail_bodies_body_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_bodies
    ADD CONSTRAINT acs_mail_bodies_body_id_fk FOREIGN KEY (body_id) REFERENCES acs_mail_gc_objects(gc_object_id) ON DELETE CASCADE;


--
-- Name: acs_mail_bodies_content_iid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_bodies
    ADD CONSTRAINT acs_mail_bodies_content_iid_fk FOREIGN KEY (content_item_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_mail_bodies_reply_to_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_bodies
    ADD CONSTRAINT acs_mail_bodies_reply_to_fk FOREIGN KEY (body_reply_to) REFERENCES acs_mail_bodies(body_id) ON DELETE SET NULL;


--
-- Name: acs_mail_body_heads_body_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_body_headers
    ADD CONSTRAINT acs_mail_body_heads_body_id_fk FOREIGN KEY (body_id) REFERENCES acs_mail_bodies(body_id) ON DELETE CASCADE;


--
-- Name: acs_mail_gc_objs_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_gc_objects
    ADD CONSTRAINT acs_mail_gc_objs_object_id_fk FOREIGN KEY (gc_object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_mail_li_bou_notif_us_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_lite_bounce_notif
    ADD CONSTRAINT acs_mail_li_bou_notif_us_id_fk FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;


--
-- Name: acs_mail_links_body_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_links
    ADD CONSTRAINT acs_mail_links_body_id_fk FOREIGN KEY (body_id) REFERENCES acs_mail_bodies(body_id) ON DELETE CASCADE;


--
-- Name: acs_mail_links_ml_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_links
    ADD CONSTRAINT acs_mail_links_ml_id_fk FOREIGN KEY (mail_link_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_mail_lite_bou_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_lite_bounce
    ADD CONSTRAINT acs_mail_lite_bou_user_id_fk FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;


--
-- Name: acs_mail_lite_queue_pck_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_lite_queue
    ADD CONSTRAINT acs_mail_lite_queue_pck_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: acs_mail_mp_parts_c_itm_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_multipart_parts
    ADD CONSTRAINT acs_mail_mp_parts_c_itm_id_fk FOREIGN KEY (content_item_id) REFERENCES cr_items(item_id) ON DELETE CASCADE;


--
-- Name: acs_mail_mp_parts_mp_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_multipart_parts
    ADD CONSTRAINT acs_mail_mp_parts_mp_id_fk FOREIGN KEY (multipart_id) REFERENCES acs_mail_multiparts(multipart_id) ON DELETE CASCADE;


--
-- Name: acs_mail_multiparts_mp_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_multiparts
    ADD CONSTRAINT acs_mail_multiparts_mp_id_fk FOREIGN KEY (multipart_id) REFERENCES acs_mail_gc_objects(gc_object_id) ON DELETE CASCADE;


--
-- Name: acs_mail_queue_in_mlid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_queue_incoming
    ADD CONSTRAINT acs_mail_queue_in_mlid_fk FOREIGN KEY (message_id) REFERENCES acs_mail_queue_messages(message_id) ON DELETE CASCADE;


--
-- Name: acs_mail_queue_ml_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_queue_messages
    ADD CONSTRAINT acs_mail_queue_ml_id_fk FOREIGN KEY (message_id) REFERENCES acs_mail_links(mail_link_id) ON DELETE CASCADE;


--
-- Name: acs_mail_queue_out_mlid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_mail_queue_outgoing
    ADD CONSTRAINT acs_mail_queue_out_mlid_fk FOREIGN KEY (message_id) REFERENCES acs_mail_queue_messages(message_id) ON DELETE CASCADE;


--
-- Name: acs_messages_message_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_messages
    ADD CONSTRAINT acs_messages_message_id_fk FOREIGN KEY (message_id) REFERENCES cr_items(item_id) ON DELETE CASCADE;


--
-- Name: acs_messages_reply_to_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_messages
    ADD CONSTRAINT acs_messages_reply_to_fk FOREIGN KEY (reply_to) REFERENCES acs_messages(message_id) ON DELETE SET NULL;


--
-- Name: acs_messages_sender_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_messages
    ADD CONSTRAINT acs_messages_sender_fk FOREIGN KEY (sender) REFERENCES parties(party_id);


--
-- Name: acs_named_objs_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_named_objects
    ADD CONSTRAINT acs_named_objs_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_named_objs_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_named_objects
    ADD CONSTRAINT acs_named_objs_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: acs_obj_context_idx_anc_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_object_context_index
    ADD CONSTRAINT acs_obj_context_idx_anc_id_fk FOREIGN KEY (ancestor_id) REFERENCES acs_objects(object_id);


--
-- Name: acs_obj_context_idx_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_object_context_index
    ADD CONSTRAINT acs_obj_context_idx_obj_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id);


--
-- Name: acs_obj_type_tbls_obj_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_object_type_tables
    ADD CONSTRAINT acs_obj_type_tbls_obj_type_fk FOREIGN KEY (object_type) REFERENCES acs_object_types(object_type);


--
-- Name: acs_object_rels_one_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_rels
    ADD CONSTRAINT acs_object_rels_one_fk FOREIGN KEY (object_id_one) REFERENCES acs_objects(object_id);


--
-- Name: acs_object_rels_two_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_rels
    ADD CONSTRAINT acs_object_rels_two_fk FOREIGN KEY (object_id_two) REFERENCES acs_objects(object_id);


--
-- Name: acs_object_types_supertype_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_object_types
    ADD CONSTRAINT acs_object_types_supertype_fk FOREIGN KEY (supertype) REFERENCES acs_object_types(object_type);


--
-- Name: acs_objects_context_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_objects
    ADD CONSTRAINT acs_objects_context_id_fk FOREIGN KEY (context_id) REFERENCES acs_objects(object_id);


--
-- Name: acs_objects_modifying_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_objects
    ADD CONSTRAINT acs_objects_modifying_user_fk FOREIGN KEY (modifying_user) REFERENCES users(user_id);


--
-- Name: acs_objects_object_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_objects
    ADD CONSTRAINT acs_objects_object_type_fk FOREIGN KEY (object_type) REFERENCES acs_object_types(object_type);


--
-- Name: acs_objects_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_objects
    ADD CONSTRAINT acs_objects_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE SET NULL;


--
-- Name: acs_permissions_grantee_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_permissions
    ADD CONSTRAINT acs_permissions_grantee_id_fk FOREIGN KEY (grantee_id) REFERENCES parties(party_id);


--
-- Name: acs_permissions_on_what_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_permissions
    ADD CONSTRAINT acs_permissions_on_what_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id);


--
-- Name: acs_permissions_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_permissions
    ADD CONSTRAINT acs_permissions_priv_fk FOREIGN KEY (privilege) REFERENCES acs_privileges(privilege);


--
-- Name: acs_priv_hier_child_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_privilege_hierarchy
    ADD CONSTRAINT acs_priv_hier_child_priv_fk FOREIGN KEY (child_privilege) REFERENCES acs_privileges(privilege);


--
-- Name: acs_priv_hier_child_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_privilege_hierarchy_index
    ADD CONSTRAINT acs_priv_hier_child_priv_fk FOREIGN KEY (child_privilege) REFERENCES acs_privileges(privilege);


--
-- Name: acs_priv_hier_child_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_privilege_descendant_map
    ADD CONSTRAINT acs_priv_hier_child_priv_fk FOREIGN KEY (descendant) REFERENCES acs_privileges(privilege);


--
-- Name: acs_priv_hier_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_privilege_hierarchy
    ADD CONSTRAINT acs_priv_hier_priv_fk FOREIGN KEY (privilege) REFERENCES acs_privileges(privilege);


--
-- Name: acs_priv_hier_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_privilege_hierarchy_index
    ADD CONSTRAINT acs_priv_hier_priv_fk FOREIGN KEY (privilege) REFERENCES acs_privileges(privilege);


--
-- Name: acs_priv_hier_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_privilege_descendant_map
    ADD CONSTRAINT acs_priv_hier_priv_fk FOREIGN KEY (privilege) REFERENCES acs_privileges(privilege);


--
-- Name: acs_rel_types_obj_type_1_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_rel_types
    ADD CONSTRAINT acs_rel_types_obj_type_1_fk FOREIGN KEY (object_type_one) REFERENCES acs_object_types(object_type);


--
-- Name: acs_rel_types_obj_type_2_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_rel_types
    ADD CONSTRAINT acs_rel_types_obj_type_2_fk FOREIGN KEY (object_type_two) REFERENCES acs_object_types(object_type);


--
-- Name: acs_rel_types_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_rel_types
    ADD CONSTRAINT acs_rel_types_rel_type_fk FOREIGN KEY (rel_type) REFERENCES acs_object_types(object_type);


--
-- Name: acs_rel_types_role_1_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_rel_types
    ADD CONSTRAINT acs_rel_types_role_1_fk FOREIGN KEY (role_one) REFERENCES acs_rel_roles(role);


--
-- Name: acs_rel_types_role_2_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_rel_types
    ADD CONSTRAINT acs_rel_types_role_2_fk FOREIGN KEY (role_two) REFERENCES acs_rel_roles(role);


--
-- Name: acs_rels_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_rels
    ADD CONSTRAINT acs_rels_rel_id_fk FOREIGN KEY (rel_id) REFERENCES acs_objects(object_id);


--
-- Name: acs_rels_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_rels
    ADD CONSTRAINT acs_rels_rel_type_fk FOREIGN KEY (rel_type) REFERENCES acs_rel_types(rel_type);


--
-- Name: acs_sc_bindings_cid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_bindings
    ADD CONSTRAINT acs_sc_bindings_cid_fk FOREIGN KEY (contract_id) REFERENCES acs_sc_contracts(contract_id) ON DELETE CASCADE;


--
-- Name: acs_sc_bindings_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_bindings
    ADD CONSTRAINT acs_sc_bindings_impl_id_fk FOREIGN KEY (impl_id) REFERENCES acs_sc_impls(impl_id) ON DELETE CASCADE;


--
-- Name: acs_sc_contracts_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_contracts
    ADD CONSTRAINT acs_sc_contracts_id_fk FOREIGN KEY (contract_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_sc_impl_proc_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_impl_aliases
    ADD CONSTRAINT acs_sc_impl_proc_impl_id_fk FOREIGN KEY (impl_id) REFERENCES acs_sc_impls(impl_id) ON DELETE CASCADE;


--
-- Name: acs_sc_impls_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_impls
    ADD CONSTRAINT acs_sc_impls_impl_id_fk FOREIGN KEY (impl_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_sc_msg_type_el_emti_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_msg_type_elements
    ADD CONSTRAINT acs_sc_msg_type_el_emti_id_fk FOREIGN KEY (element_msg_type_id) REFERENCES acs_sc_msg_types(msg_type_id);


--
-- Name: acs_sc_msg_type_el_mtype_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_msg_type_elements
    ADD CONSTRAINT acs_sc_msg_type_el_mtype_id_fk FOREIGN KEY (msg_type_id) REFERENCES acs_sc_msg_types(msg_type_id) ON DELETE CASCADE;


--
-- Name: acs_sc_msg_types_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_msg_types
    ADD CONSTRAINT acs_sc_msg_types_id_fk FOREIGN KEY (msg_type_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_sc_operations_cid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_cid_fk FOREIGN KEY (contract_id) REFERENCES acs_sc_contracts(contract_id) ON DELETE CASCADE;


--
-- Name: acs_sc_operations_intype_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_intype_fk FOREIGN KEY (operation_inputtype_id) REFERENCES acs_sc_msg_types(msg_type_id);


--
-- Name: acs_sc_operations_opid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_opid_fk FOREIGN KEY (operation_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_sc_operations_outtype_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_outtype_fk FOREIGN KEY (operation_outputtype_id) REFERENCES acs_sc_msg_types(msg_type_id);


--
-- Name: acs_static_a_v_attr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_static_attr_values
    ADD CONSTRAINT acs_static_a_v_attr_id_fk FOREIGN KEY (attribute_id) REFERENCES acs_attributes(attribute_id);


--
-- Name: acs_static_a_v_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_static_attr_values
    ADD CONSTRAINT acs_static_a_v_obj_id_fk FOREIGN KEY (object_type) REFERENCES acs_object_types(object_type) ON DELETE CASCADE;


--
-- Name: ad_locale_user_prefs_users_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ad_locale_user_prefs
    ADD CONSTRAINT ad_locale_user_prefs_users_fk FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;


--
-- Name: admin_rel_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY admin_rels
    ADD CONSTRAINT admin_rel_rel_id_fk FOREIGN KEY (rel_id) REFERENCES membership_rels(rel_id);


--
-- Name: am_meeting_ass_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY am_meeting_type_participants
    ADD CONSTRAINT am_meeting_ass_fk FOREIGN KEY (user_id) REFERENCES users(user_id);


--
-- Name: am_meeting_ass_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY am_meeting_todo
    ADD CONSTRAINT am_meeting_ass_fk FOREIGN KEY (assignee) REFERENCES users(user_id);


--
-- Name: am_meeting_meet_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY am_meeting_todo
    ADD CONSTRAINT am_meeting_meet_id_fk FOREIGN KEY (meeting_id) REFERENCES am_meeting(meeting_id);


--
-- Name: am_meeting_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY am_meeting
    ADD CONSTRAINT am_meeting_type_fk FOREIGN KEY (type_id) REFERENCES am_meeting_type(type_id);


--
-- Name: am_meeting_type_par_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY am_meeting_type_participants
    ADD CONSTRAINT am_meeting_type_par_fk FOREIGN KEY (type_id) REFERENCES am_meeting_type(type_id);


--
-- Name: amo_message_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_messages_outgoing
    ADD CONSTRAINT amo_message_id_fk FOREIGN KEY (message_id) REFERENCES acs_messages(message_id) ON DELETE CASCADE;


--
-- Name: apm_pack_param_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_parameters
    ADD CONSTRAINT apm_pack_param_type_fk FOREIGN KEY (package_key) REFERENCES apm_package_types(package_key);


--
-- Name: apm_pack_values_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_parameter_values
    ADD CONSTRAINT apm_pack_values_obj_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: apm_pack_values_parm_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_parameter_values
    ADD CONSTRAINT apm_pack_values_parm_id_fk FOREIGN KEY (parameter_id) REFERENCES apm_parameters(parameter_id);


--
-- Name: apm_package_callbacks_vid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_package_callbacks
    ADD CONSTRAINT apm_package_callbacks_vid_fk FOREIGN KEY (version_id) REFERENCES apm_package_versions(version_id) ON DELETE CASCADE;


--
-- Name: apm_package_deps_version_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_package_dependencies
    ADD CONSTRAINT apm_package_deps_version_id_fk FOREIGN KEY (version_id) REFERENCES apm_package_versions(version_id) ON DELETE CASCADE;


--
-- Name: apm_package_owners_ver_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_package_owners
    ADD CONSTRAINT apm_package_owners_ver_id_fk FOREIGN KEY (version_id) REFERENCES apm_package_versions(version_id) ON DELETE CASCADE;


--
-- Name: apm_package_ver_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_package_versions
    ADD CONSTRAINT apm_package_ver_item_id_fk FOREIGN KEY (item_id) REFERENCES cr_items(item_id);


--
-- Name: apm_package_vers_attr_vid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_package_version_attr
    ADD CONSTRAINT apm_package_vers_attr_vid_fk FOREIGN KEY (version_id) REFERENCES apm_package_versions(version_id) ON DELETE CASCADE;


--
-- Name: apm_package_vers_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_package_versions
    ADD CONSTRAINT apm_package_vers_id_fk FOREIGN KEY (version_id) REFERENCES acs_objects(object_id);


--
-- Name: apm_package_vers_pack_key_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_package_versions
    ADD CONSTRAINT apm_package_vers_pack_key_fk FOREIGN KEY (package_key) REFERENCES apm_package_types(package_key);


--
-- Name: apm_packages_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_packages
    ADD CONSTRAINT apm_packages_package_id_fk FOREIGN KEY (package_id) REFERENCES acs_objects(object_id);


--
-- Name: apm_packages_package_key_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_packages
    ADD CONSTRAINT apm_packages_package_key_fk FOREIGN KEY (package_key) REFERENCES apm_package_types(package_key);


--
-- Name: apm_parameter_values_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_parameter_values
    ADD CONSTRAINT apm_parameter_values_fk FOREIGN KEY (value_id) REFERENCES acs_objects(object_id);


--
-- Name: apm_parameters_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_parameters
    ADD CONSTRAINT apm_parameters_fk FOREIGN KEY (parameter_id) REFERENCES acs_objects(object_id);


--
-- Name: app_groups_group_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY application_groups
    ADD CONSTRAINT app_groups_group_id_fk FOREIGN KEY (group_id) REFERENCES groups(group_id);


--
-- Name: app_groups_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY application_groups
    ADD CONSTRAINT app_groups_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: applications_application_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_applications
    ADD CONSTRAINT applications_application_id_fk FOREIGN KEY (application_id) REFERENCES apm_packages(package_id);


--
-- Name: arr_maintainer_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_reference_repositories
    ADD CONSTRAINT arr_maintainer_id_fk FOREIGN KEY (maintainer_id) REFERENCES persons(person_id);


--
-- Name: arr_repository_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_reference_repositories
    ADD CONSTRAINT arr_repository_id_fk FOREIGN KEY (repository_id) REFERENCES acs_objects(object_id);


--
-- Name: asc_enum_values_attr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY acs_enum_values
    ADD CONSTRAINT asc_enum_values_attr_id_fk FOREIGN KEY (attribute_id) REFERENCES acs_attributes(attribute_id);


--
-- Name: attach_fldr_map_folder_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY attachments_fs_root_folder_map
    ADD CONSTRAINT attach_fldr_map_folder_id_fk FOREIGN KEY (folder_id) REFERENCES fs_root_folders(folder_id);


--
-- Name: attach_fldr_map_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY attachments_fs_root_folder_map
    ADD CONSTRAINT attach_fldr_map_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: attachments_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY attachments
    ADD CONSTRAINT attachments_item_id_fk FOREIGN KEY (item_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: attachments_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY attachments
    ADD CONSTRAINT attachments_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: auth_authorities_aid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_authorities
    ADD CONSTRAINT auth_authorities_aid_fk FOREIGN KEY (authority_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: auth_authority_auth_impl_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_authorities
    ADD CONSTRAINT auth_authority_auth_impl_fk FOREIGN KEY (auth_impl_id) REFERENCES acs_objects(object_id);


--
-- Name: auth_authority_pwd_impl_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_authorities
    ADD CONSTRAINT auth_authority_pwd_impl_fk FOREIGN KEY (pwd_impl_id) REFERENCES acs_objects(object_id);


--
-- Name: auth_authority_reg_impl_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_authorities
    ADD CONSTRAINT auth_authority_reg_impl_fk FOREIGN KEY (register_impl_id) REFERENCES acs_objects(object_id);


--
-- Name: auth_authority_userinf_impl_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_authorities
    ADD CONSTRAINT auth_authority_userinf_impl_fk FOREIGN KEY (user_info_impl_id) REFERENCES acs_objects(object_id);


--
-- Name: auth_batch_job_entries_job_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_batch_job_entries
    ADD CONSTRAINT auth_batch_job_entries_job_fk FOREIGN KEY (job_id) REFERENCES auth_batch_jobs(job_id) ON DELETE CASCADE;


--
-- Name: auth_batch_job_entries_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_batch_job_entries
    ADD CONSTRAINT auth_batch_job_entries_user_fk FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL;


--
-- Name: auth_batch_job_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_batch_jobs
    ADD CONSTRAINT auth_batch_job_user_fk FOREIGN KEY (creation_user) REFERENCES users(user_id) ON DELETE SET NULL;


--
-- Name: auth_batch_jobs_auth_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_batch_jobs
    ADD CONSTRAINT auth_batch_jobs_auth_fk FOREIGN KEY (authority_id) REFERENCES auth_authorities(authority_id) ON DELETE CASCADE;


--
-- Name: auth_driver_params_aid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_driver_params
    ADD CONSTRAINT auth_driver_params_aid_fk FOREIGN KEY (authority_id) REFERENCES auth_authorities(authority_id);


--
-- Name: auth_driver_params_iid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY auth_driver_params
    ADD CONSTRAINT auth_driver_params_iid_fk FOREIGN KEY (impl_id) REFERENCES acs_objects(object_id);


--
-- Name: cal_item_cal_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cal_items
    ADD CONSTRAINT cal_item_cal_item_id_fk FOREIGN KEY (cal_item_id) REFERENCES acs_events(event_id);


--
-- Name: cal_item_type_cal_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cal_item_types
    ADD CONSTRAINT cal_item_type_cal_id_fk FOREIGN KEY (calendar_id) REFERENCES calendars(calendar_id);


--
-- Name: cal_item_which_cal_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cal_items
    ADD CONSTRAINT cal_item_which_cal_fk FOREIGN KEY (on_which_calendar) REFERENCES calendars(calendar_id) ON DELETE CASCADE;


--
-- Name: cal_items_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cal_items
    ADD CONSTRAINT cal_items_type_fk FOREIGN KEY (on_which_calendar, item_type_id) REFERENCES cal_item_types(calendar_id, item_type_id);


--
-- Name: cal_pty_prefs_cal_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cal_party_prefs
    ADD CONSTRAINT cal_pty_prefs_cal_id_fk FOREIGN KEY (calendar_id) REFERENCES calendars(calendar_id) ON DELETE CASCADE;


--
-- Name: cal_pty_prefs_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cal_party_prefs
    ADD CONSTRAINT cal_pty_prefs_party_id_fk FOREIGN KEY (party_id) REFERENCES parties(party_id) ON DELETE CASCADE;


--
-- Name: cal_pty_prefs_time_zone_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cal_party_prefs
    ADD CONSTRAINT cal_pty_prefs_time_zone_fk FOREIGN KEY (time_zone) REFERENCES timezones(tz_id) ON DELETE CASCADE;


--
-- Name: calendars_calendar_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY calendars
    ADD CONSTRAINT calendars_calendar_id_fk FOREIGN KEY (calendar_id) REFERENCES acs_objects(object_id);


--
-- Name: calendars_calendar_owner_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY calendars
    ADD CONSTRAINT calendars_calendar_owner_id_fk FOREIGN KEY (owner_id) REFERENCES parties(party_id) ON DELETE CASCADE;


--
-- Name: calendars_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY calendars
    ADD CONSTRAINT calendars_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: cat_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY categories
    ADD CONSTRAINT cat_category_id_fk FOREIGN KEY (category_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cat_object_map_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_object_map
    ADD CONSTRAINT cat_object_map_category_id_fk FOREIGN KEY (category_id) REFERENCES categories(category_id) ON DELETE CASCADE;


--
-- Name: cat_object_map_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_object_map
    ADD CONSTRAINT cat_object_map_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cat_parent_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY categories
    ADD CONSTRAINT cat_parent_id_fk FOREIGN KEY (parent_id) REFERENCES categories(category_id);


--
-- Name: cat_trans_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_translations
    ADD CONSTRAINT cat_trans_category_id_fk FOREIGN KEY (category_id) REFERENCES categories(category_id) ON DELETE CASCADE;


--
-- Name: cat_trans_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_translations
    ADD CONSTRAINT cat_trans_locale_fk FOREIGN KEY (locale) REFERENCES ad_locales(locale);


--
-- Name: cat_tree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY categories
    ADD CONSTRAINT cat_tree_id_fk FOREIGN KEY (tree_id) REFERENCES category_trees(tree_id) ON DELETE CASCADE;


--
-- Name: cat_tree_map_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_tree_map
    ADD CONSTRAINT cat_tree_map_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cat_tree_map_subtree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_tree_map
    ADD CONSTRAINT cat_tree_map_subtree_id_fk FOREIGN KEY (subtree_category_id) REFERENCES categories(category_id);


--
-- Name: cat_tree_map_tree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_tree_map
    ADD CONSTRAINT cat_tree_map_tree_id_fk FOREIGN KEY (tree_id) REFERENCES category_trees(tree_id) ON DELETE CASCADE;


--
-- Name: cat_tree_trans_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_tree_translations
    ADD CONSTRAINT cat_tree_trans_locale_fk FOREIGN KEY (locale) REFERENCES ad_locales(locale);


--
-- Name: cat_tree_trans_tree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_tree_translations
    ADD CONSTRAINT cat_tree_trans_tree_id_fk FOREIGN KEY (tree_id) REFERENCES category_trees(tree_id) ON DELETE CASCADE;


--
-- Name: cat_trees_tree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_trees
    ADD CONSTRAINT cat_trees_tree_id_fk FOREIGN KEY (tree_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: category_links_from_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_links
    ADD CONSTRAINT category_links_from_fk FOREIGN KEY (from_category_id) REFERENCES categories(category_id) ON DELETE CASCADE;


--
-- Name: category_links_to_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_links
    ADD CONSTRAINT category_links_to_fk FOREIGN KEY (to_category_id) REFERENCES categories(category_id) ON DELETE CASCADE;


--
-- Name: category_results_query_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_search_results
    ADD CONSTRAINT category_results_query_fk FOREIGN KEY (query_id) REFERENCES category_search(query_id) ON DELETE CASCADE;


--
-- Name: category_results_synonym_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_search_results
    ADD CONSTRAINT category_results_synonym_fk FOREIGN KEY (synonym_id) REFERENCES category_synonyms(synonym_id) ON DELETE CASCADE;


--
-- Name: category_search_index_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_search_index
    ADD CONSTRAINT category_search_index_fk FOREIGN KEY (query_id) REFERENCES category_search(query_id) ON DELETE CASCADE;


--
-- Name: category_search_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_search
    ADD CONSTRAINT category_search_locale_fk FOREIGN KEY (locale) REFERENCES ad_locales(locale) ON DELETE CASCADE;


--
-- Name: category_synonym_index_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_synonym_index
    ADD CONSTRAINT category_synonym_index_fk FOREIGN KEY (synonym_id) REFERENCES category_synonyms(synonym_id) ON DELETE CASCADE;


--
-- Name: category_synonyms_cat_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_synonyms
    ADD CONSTRAINT category_synonyms_cat_fk FOREIGN KEY (category_id) REFERENCES categories(category_id) ON DELETE CASCADE;


--
-- Name: category_synonyms_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY category_synonyms
    ADD CONSTRAINT category_synonyms_locale_fk FOREIGN KEY (locale) REFERENCES ad_locales(locale) ON DELETE CASCADE;


--
-- Name: channel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY weblogger_channels
    ADD CONSTRAINT channel_id_fk FOREIGN KEY (channel_id) REFERENCES acs_objects(object_id);


--
-- Name: composition_rel_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY composition_rels
    ADD CONSTRAINT composition_rel_rel_id_fk FOREIGN KEY (rel_id) REFERENCES acs_rels(rel_id);


--
-- Name: cr_child_rels_rel_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_child_rels
    ADD CONSTRAINT cr_child_rels_rel_fk FOREIGN KEY (rel_id) REFERENCES acs_objects(object_id);


--
-- Name: cr_content_mime_map_ctyp_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_content_mime_type_map
    ADD CONSTRAINT cr_content_mime_map_ctyp_fk FOREIGN KEY (content_type) REFERENCES acs_object_types(object_type);


--
-- Name: cr_content_mime_map_typ_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_content_mime_type_map
    ADD CONSTRAINT cr_content_mime_map_typ_fk FOREIGN KEY (mime_type) REFERENCES cr_mime_types(mime_type);


--
-- Name: cr_extlink_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_extlinks
    ADD CONSTRAINT cr_extlink_id_fk FOREIGN KEY (extlink_id) REFERENCES cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_flder_pkg_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_folders
    ADD CONSTRAINT cr_flder_pkg_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: cr_fldr_pkg_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_folders
    ADD CONSTRAINT cr_fldr_pkg_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: cr_folder_type_map_fldr_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_folder_type_map
    ADD CONSTRAINT cr_folder_type_map_fldr_fk FOREIGN KEY (folder_id) REFERENCES cr_folders(folder_id);


--
-- Name: cr_folder_type_map_typ_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_folder_type_map
    ADD CONSTRAINT cr_folder_type_map_typ_fk FOREIGN KEY (content_type) REFERENCES acs_object_types(object_type);


--
-- Name: cr_item_keyword_map_item_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_item_keyword_map
    ADD CONSTRAINT cr_item_keyword_map_item_fk FOREIGN KEY (item_id) REFERENCES cr_items(item_id);


--
-- Name: cr_item_keyword_map_kw_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_item_keyword_map
    ADD CONSTRAINT cr_item_keyword_map_kw_fk FOREIGN KEY (keyword_id) REFERENCES cr_keywords(keyword_id);


--
-- Name: cr_item_rels_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_item_rels
    ADD CONSTRAINT cr_item_rels_fk FOREIGN KEY (rel_id) REFERENCES acs_objects(object_id);


--
-- Name: cr_item_rels_item_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_item_rels
    ADD CONSTRAINT cr_item_rels_item_fk FOREIGN KEY (item_id) REFERENCES cr_items(item_id);


--
-- Name: cr_item_rels_rel_obj__fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_item_rels
    ADD CONSTRAINT cr_item_rels_rel_obj__fk FOREIGN KEY (related_object_id) REFERENCES acs_objects(object_id);


--
-- Name: cr_item_template_map_ctx_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_item_template_map
    ADD CONSTRAINT cr_item_template_map_ctx_fk FOREIGN KEY (use_context) REFERENCES cr_template_use_contexts(use_context);


--
-- Name: cr_item_template_map_item_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_item_template_map
    ADD CONSTRAINT cr_item_template_map_item_fk FOREIGN KEY (item_id) REFERENCES cr_items(item_id);


--
-- Name: cr_item_template_map_tmpl_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_item_template_map
    ADD CONSTRAINT cr_item_template_map_tmpl_fk FOREIGN KEY (template_id) REFERENCES cr_templates(template_id);


--
-- Name: cr_items_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_items
    ADD CONSTRAINT cr_items_item_id_fk FOREIGN KEY (item_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cr_items_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_items
    ADD CONSTRAINT cr_items_locale_fk FOREIGN KEY (locale) REFERENCES cr_locales(locale);


--
-- Name: cr_items_parent_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_items
    ADD CONSTRAINT cr_items_parent_id_fk FOREIGN KEY (parent_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cr_items_rev_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_items
    ADD CONSTRAINT cr_items_rev_type_fk FOREIGN KEY (content_type) REFERENCES acs_object_types(object_type);


--
-- Name: cr_keywords_hier; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_keywords
    ADD CONSTRAINT cr_keywords_hier FOREIGN KEY (parent_id) REFERENCES cr_keywords(keyword_id);


--
-- Name: cr_mime_ext_map_mime_type_ref; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_extension_mime_type_map
    ADD CONSTRAINT cr_mime_ext_map_mime_type_ref FOREIGN KEY (mime_type) REFERENCES cr_mime_types(mime_type);


--
-- Name: cr_news_approval_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_news
    ADD CONSTRAINT cr_news_approval_user_fk FOREIGN KEY (approval_user) REFERENCES users(user_id);


--
-- Name: cr_news_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_news
    ADD CONSTRAINT cr_news_id_fk FOREIGN KEY (news_id) REFERENCES cr_revisions(revision_id);


--
-- Name: cr_release_periods_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_release_periods
    ADD CONSTRAINT cr_release_periods_fk FOREIGN KEY (item_id) REFERENCES cr_items(item_id);


--
-- Name: cr_revision_attributes_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_revision_attributes
    ADD CONSTRAINT cr_revision_attributes_fk FOREIGN KEY (revision_id) REFERENCES cr_revisions(revision_id);


--
-- Name: cr_revisions_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_revisions
    ADD CONSTRAINT cr_revisions_item_id_fk FOREIGN KEY (item_id) REFERENCES cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_revisions_lob_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_revisions
    ADD CONSTRAINT cr_revisions_lob_fkey FOREIGN KEY (lob) REFERENCES lobs(lob_id);


--
-- Name: cr_revisions_mime_type_ref; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_revisions
    ADD CONSTRAINT cr_revisions_mime_type_ref FOREIGN KEY (mime_type) REFERENCES cr_mime_types(mime_type);


--
-- Name: cr_revisions_rev_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_revisions
    ADD CONSTRAINT cr_revisions_rev_id_fk FOREIGN KEY (revision_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cr_symlink_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_symlinks
    ADD CONSTRAINT cr_symlink_id_fk FOREIGN KEY (symlink_id) REFERENCES cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_symlink_target_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_symlinks
    ADD CONSTRAINT cr_symlink_target_id_fk FOREIGN KEY (target_id) REFERENCES cr_items(item_id);


--
-- Name: cr_template_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_templates
    ADD CONSTRAINT cr_template_id_fk FOREIGN KEY (template_id) REFERENCES cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_type_children_child_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_type_children
    ADD CONSTRAINT cr_type_children_child_fk FOREIGN KEY (child_type) REFERENCES acs_object_types(object_type);


--
-- Name: cr_type_children_parent_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_type_children
    ADD CONSTRAINT cr_type_children_parent_fk FOREIGN KEY (parent_type) REFERENCES acs_object_types(object_type);


--
-- Name: cr_type_relations_child_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_type_relations
    ADD CONSTRAINT cr_type_relations_child_fk FOREIGN KEY (target_type) REFERENCES acs_object_types(object_type);


--
-- Name: cr_type_relations_parent_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_type_relations
    ADD CONSTRAINT cr_type_relations_parent_fk FOREIGN KEY (content_type) REFERENCES acs_object_types(object_type);


--
-- Name: cr_type_template_map_ctx_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_type_template_map
    ADD CONSTRAINT cr_type_template_map_ctx_fk FOREIGN KEY (use_context) REFERENCES cr_template_use_contexts(use_context);


--
-- Name: cr_type_template_map_tmpl_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_type_template_map
    ADD CONSTRAINT cr_type_template_map_tmpl_fk FOREIGN KEY (template_id) REFERENCES cr_templates(template_id);


--
-- Name: cr_type_template_map_typ_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY cr_type_template_map
    ADD CONSTRAINT cr_type_template_map_typ_fk FOREIGN KEY (content_type) REFERENCES acs_object_types(object_type);


--
-- Name: dav_impls_folder_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY dav_site_node_folder_map
    ADD CONSTRAINT dav_impls_folder_id_fk FOREIGN KEY (folder_id) REFERENCES cr_folders(folder_id);


--
-- Name: dav_side_node_folder_map_node_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY dav_site_node_folder_map
    ADD CONSTRAINT dav_side_node_folder_map_node_id_fk FOREIGN KEY (node_id) REFERENCES site_nodes(node_id) ON DELETE CASCADE;


--
-- Name: download_ar_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_archive_revisions
    ADD CONSTRAINT download_ar_id_fk FOREIGN KEY (revision_id) REFERENCES cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: download_ar_usr_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_archive_revisions
    ADD CONSTRAINT download_ar_usr_fk FOREIGN KEY (approved_user) REFERENCES users(user_id);


--
-- Name: download_archive_descs_archive_desc_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_archive_descs
    ADD CONSTRAINT download_archive_descs_archive_desc_id_fkey FOREIGN KEY (archive_desc_id) REFERENCES cr_revisions(revision_id);


--
-- Name: download_archive_rep_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_archive_types
    ADD CONSTRAINT download_archive_rep_id_fk FOREIGN KEY (repository_id) REFERENCES download_repository(repository_id);


--
-- Name: download_archives_a_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_archives
    ADD CONSTRAINT download_archives_a_id_fk FOREIGN KEY (archive_id) REFERENCES cr_items(item_id) ON DELETE CASCADE;


--
-- Name: download_archives_ad_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_archives
    ADD CONSTRAINT download_archives_ad_id_fk FOREIGN KEY (archive_desc_id) REFERENCES cr_revisions(revision_id);


--
-- Name: download_archives_at_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_archives
    ADD CONSTRAINT download_archives_at_id_fk FOREIGN KEY (archive_type_id) REFERENCES download_archive_types(archive_type_id);


--
-- Name: download_downloads_reason_fl; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_downloads
    ADD CONSTRAINT download_downloads_reason_fl FOREIGN KEY (reason_id) REFERENCES download_reasons(download_reason_id) ON DELETE SET NULL;


--
-- Name: download_downloads_rev_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_downloads
    ADD CONSTRAINT download_downloads_rev_fk FOREIGN KEY (revision_id) REFERENCES download_archive_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: download_downloads_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_downloads
    ADD CONSTRAINT download_downloads_user_fk FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL;


--
-- Name: download_ma_rep_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_archive_metadata
    ADD CONSTRAINT download_ma_rep_id_fk FOREIGN KEY (repository_id) REFERENCES download_repository(repository_id);


--
-- Name: download_ma_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_archive_metadata
    ADD CONSTRAINT download_ma_type_fk FOREIGN KEY (archive_type_id) REFERENCES download_archive_types(archive_type_id);


--
-- Name: download_mc_met_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_metadata_choices
    ADD CONSTRAINT download_mc_met_id_fk FOREIGN KEY (metadata_id) REFERENCES download_archive_metadata(metadata_id);


--
-- Name: download_reason_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_reasons
    ADD CONSTRAINT download_reason_id_fk FOREIGN KEY (repository_id) REFERENCES download_repository(repository_id);


--
-- Name: download_repository_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_repository
    ADD CONSTRAINT download_repository_id_fk FOREIGN KEY (repository_id) REFERENCES cr_items(item_id) ON DELETE CASCADE;


--
-- Name: download_revision_choice_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_revision_data
    ADD CONSTRAINT download_revision_choice_fk FOREIGN KEY (choice_id) REFERENCES download_metadata_choices(choice_id);


--
-- Name: download_revision_data_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_revision_data
    ADD CONSTRAINT download_revision_data_fk FOREIGN KEY (revision_id) REFERENCES download_archive_revisions(revision_id);


--
-- Name: download_revision_metadata_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY download_revision_data
    ADD CONSTRAINT download_revision_metadata_fk FOREIGN KEY (metadata_id) REFERENCES download_archive_metadata(metadata_id);


--
-- Name: etp_page_revisions_etp_page_revision_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY etp_page_revisions
    ADD CONSTRAINT etp_page_revisions_etp_page_revision_id_fkey FOREIGN KEY (etp_page_revision_id) REFERENCES cr_revisions(revision_id);


--
-- Name: forum_mess_parent_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY forums_messages
    ADD CONSTRAINT forum_mess_parent_id_fk FOREIGN KEY (parent_id) REFERENCES forums_messages(message_id);


--
-- Name: forums_forum_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY forums_forums
    ADD CONSTRAINT forums_forum_id_fk FOREIGN KEY (forum_id) REFERENCES acs_objects(object_id);


--
-- Name: forums_mess_forum_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY forums_messages
    ADD CONSTRAINT forums_mess_forum_id_fk FOREIGN KEY (forum_id) REFERENCES forums_forums(forum_id);


--
-- Name: forums_message_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY forums_messages
    ADD CONSTRAINT forums_message_id_fk FOREIGN KEY (message_id) REFERENCES acs_objects(object_id);


--
-- Name: fs_root_folder_folder_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY fs_root_folders
    ADD CONSTRAINT fs_root_folder_folder_id_fk FOREIGN KEY (folder_id) REFERENCES cr_folders(folder_id);


--
-- Name: fs_root_folder_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY fs_root_folders
    ADD CONSTRAINT fs_root_folder_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: fs_rss_subscrs_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY fs_rss_subscrs
    ADD CONSTRAINT fs_rss_subscrs_fk FOREIGN KEY (subscr_id) REFERENCES rss_gen_subscrs(subscr_id) ON DELETE CASCADE;


--
-- Name: fs_rss_subscrs_fldr_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY fs_rss_subscrs
    ADD CONSTRAINT fs_rss_subscrs_fldr_fk FOREIGN KEY (folder_id) REFERENCES cr_folders(folder_id);


--
-- Name: general_comments_comment_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY general_comments
    ADD CONSTRAINT general_comments_comment_id_fk FOREIGN KEY (comment_id) REFERENCES acs_messages(message_id) ON DELETE CASCADE;


--
-- Name: general_comments_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY general_comments
    ADD CONSTRAINT general_comments_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: general_objects_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY general_objects
    ADD CONSTRAINT general_objects_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id);


--
-- Name: group_elem_index_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_element_index
    ADD CONSTRAINT group_elem_index_rel_type_fk FOREIGN KEY (rel_type) REFERENCES acs_rel_types(rel_type);


--
-- Name: group_element_index_cont_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_element_index
    ADD CONSTRAINT group_element_index_cont_id_fk FOREIGN KEY (container_id) REFERENCES groups(group_id);


--
-- Name: group_element_index_elem_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_element_index
    ADD CONSTRAINT group_element_index_elem_id_fk FOREIGN KEY (element_id) REFERENCES parties(party_id);


--
-- Name: group_element_index_grp_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_element_index
    ADD CONSTRAINT group_element_index_grp_id_fk FOREIGN KEY (group_id) REFERENCES groups(group_id);


--
-- Name: group_element_index_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_element_index
    ADD CONSTRAINT group_element_index_rel_id_fk FOREIGN KEY (rel_id) REFERENCES acs_rels(rel_id);


--
-- Name: group_rels_group_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_rels
    ADD CONSTRAINT group_rels_group_id_fk FOREIGN KEY (group_id) REFERENCES groups(group_id) ON DELETE CASCADE;


--
-- Name: group_rels_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_rels
    ADD CONSTRAINT group_rels_rel_type_fk FOREIGN KEY (rel_type) REFERENCES acs_rel_types(rel_type) ON DELETE CASCADE;


--
-- Name: group_types_obj_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_types
    ADD CONSTRAINT group_types_obj_type_fk FOREIGN KEY (group_type) REFERENCES acs_object_types(object_type);


--
-- Name: groups_group_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY groups
    ADD CONSTRAINT groups_group_id_fk FOREIGN KEY (group_id) REFERENCES parties(party_id);


--
-- Name: gtr_group_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_type_rels
    ADD CONSTRAINT gtr_group_type_fk FOREIGN KEY (group_type) REFERENCES acs_object_types(object_type) ON DELETE CASCADE;


--
-- Name: gtr_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY group_type_rels
    ADD CONSTRAINT gtr_rel_type_fk FOREIGN KEY (rel_type) REFERENCES acs_rel_types(rel_type) ON DELETE CASCADE;


--
-- Name: host_node_map_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY host_node_map
    ADD CONSTRAINT host_node_map_fk FOREIGN KEY (node_id) REFERENCES acs_objects(object_id);


--
-- Name: images_image_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY images
    ADD CONSTRAINT images_image_id_fk FOREIGN KEY (image_id) REFERENCES cr_revisions(revision_id);


--
-- Name: journal_entries_journal_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY journal_entries
    ADD CONSTRAINT journal_entries_journal_id_fk FOREIGN KEY (journal_id) REFERENCES acs_objects(object_id);


--
-- Name: journal_entries_object_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY journal_entries
    ADD CONSTRAINT journal_entries_object_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: lang_message_keys_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY lang_message_keys
    ADD CONSTRAINT lang_message_keys_fk FOREIGN KEY (package_key) REFERENCES apm_package_types(package_key);


--
-- Name: lang_messages_audit_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY lang_messages_audit
    ADD CONSTRAINT lang_messages_audit_fk FOREIGN KEY (message_key, package_key) REFERENCES lang_message_keys(message_key, package_key) ON DELETE CASCADE;


--
-- Name: lang_messages_audit_l_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY lang_messages_audit
    ADD CONSTRAINT lang_messages_audit_l_fk FOREIGN KEY (locale) REFERENCES ad_locales(locale);


--
-- Name: lang_messages_audit_ou_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY lang_messages_audit
    ADD CONSTRAINT lang_messages_audit_ou_fk FOREIGN KEY (overwrite_user) REFERENCES users(user_id);


--
-- Name: lang_messages_creation_u_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY lang_messages
    ADD CONSTRAINT lang_messages_creation_u_fk FOREIGN KEY (creation_user) REFERENCES users(user_id);


--
-- Name: lang_messages_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY lang_messages
    ADD CONSTRAINT lang_messages_fk FOREIGN KEY (message_key, package_key) REFERENCES lang_message_keys(message_key, package_key) ON DELETE CASCADE;


--
-- Name: lang_messages_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY lang_messages
    ADD CONSTRAINT lang_messages_locale_fk FOREIGN KEY (locale) REFERENCES ad_locales(locale);


--
-- Name: lang_package_l_u_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ad_locale_user_prefs
    ADD CONSTRAINT lang_package_l_u_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: lob_data_lob_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY lob_data
    ADD CONSTRAINT lob_data_lob_id_fkey FOREIGN KEY (lob_id) REFERENCES lobs(lob_id);


--
-- Name: logger_entries_mid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_entries
    ADD CONSTRAINT logger_entries_mid_fk FOREIGN KEY (entry_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: logger_entries_pid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_entries
    ADD CONSTRAINT logger_entries_pid_fk FOREIGN KEY (project_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: logger_entries_v_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_entries
    ADD CONSTRAINT logger_entries_v_id_fk FOREIGN KEY (variable_id) REFERENCES logger_variables(variable_id) ON DELETE CASCADE;


--
-- Name: logger_project_pkg_map_pa_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_project_pkg_map
    ADD CONSTRAINT logger_project_pkg_map_pa_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: logger_project_pkg_map_pr_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_project_pkg_map
    ADD CONSTRAINT logger_project_pkg_map_pr_fk FOREIGN KEY (project_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: logger_project_var_map_pi_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_variables
    ADD CONSTRAINT logger_project_var_map_pi_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: logger_project_var_map_pid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_project_var_map
    ADD CONSTRAINT logger_project_var_map_pid_fk FOREIGN KEY (project_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: logger_project_var_map_vid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_project_var_map
    ADD CONSTRAINT logger_project_var_map_vid_fk FOREIGN KEY (variable_id) REFERENCES logger_variables(variable_id) ON DELETE CASCADE;


--
-- Name: logger_projections_pid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_projections
    ADD CONSTRAINT logger_projections_pid_fk FOREIGN KEY (project_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: logger_projections_vid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_projections
    ADD CONSTRAINT logger_projections_vid_fk FOREIGN KEY (variable_id) REFERENCES logger_variables(variable_id) ON DELETE CASCADE;


--
-- Name: logger_projects_pid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_projects
    ADD CONSTRAINT logger_projects_pid_fk FOREIGN KEY (project_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: logger_projects_pl_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_projects
    ADD CONSTRAINT logger_projects_pl_fk FOREIGN KEY (project_lead) REFERENCES users(user_id);


--
-- Name: logger_variables_pid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY logger_variables
    ADD CONSTRAINT logger_variables_pid_fk FOREIGN KEY (variable_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: ltr_locale_ref; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY lang_translation_registry
    ADD CONSTRAINT ltr_locale_ref FOREIGN KEY (locale) REFERENCES ad_locales(locale);


--
-- Name: membership_rel_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY membership_rels
    ADD CONSTRAINT membership_rel_rel_id_fk FOREIGN KEY (rel_id) REFERENCES acs_rels(rel_id);


--
-- Name: na_aggregators_aid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_aggregators
    ADD CONSTRAINT na_aggregators_aid_fk FOREIGN KEY (aggregator_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: na_aggregators_mid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_aggregators
    ADD CONSTRAINT na_aggregators_mid_fk FOREIGN KEY (maintainer_id) REFERENCES users(user_id);


--
-- Name: na_aggregators_pid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_aggregators
    ADD CONSTRAINT na_aggregators_pid_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: na_items_sid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_items
    ADD CONSTRAINT na_items_sid_fk FOREIGN KEY (source_id) REFERENCES na_sources(source_id);


--
-- Name: na_presubscribed_feeds_pid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_presubscribed_feeds
    ADD CONSTRAINT na_presubscribed_feeds_pid_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: na_presubscribed_feeds_sid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_presubscribed_feeds
    ADD CONSTRAINT na_presubscribed_feeds_sid_fk FOREIGN KEY (source_id) REFERENCES na_sources(source_id);


--
-- Name: na_purges_aid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_purges
    ADD CONSTRAINT na_purges_aid_fk FOREIGN KEY (aggregator_id) REFERENCES na_aggregators(aggregator_id);


--
-- Name: na_saved_items_aid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_saved_items
    ADD CONSTRAINT na_saved_items_aid_fk FOREIGN KEY (aggregator_id) REFERENCES na_aggregators(aggregator_id);


--
-- Name: na_saved_items_iid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_saved_items
    ADD CONSTRAINT na_saved_items_iid_fk FOREIGN KEY (item_id) REFERENCES na_items(item_id);


--
-- Name: na_sources_sid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_sources
    ADD CONSTRAINT na_sources_sid_fk FOREIGN KEY (source_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: na_subscriptions_aid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_subscriptions
    ADD CONSTRAINT na_subscriptions_aid_fk FOREIGN KEY (aggregator_id) REFERENCES na_aggregators(aggregator_id);


--
-- Name: na_subscriptions_sid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_subscriptions
    ADD CONSTRAINT na_subscriptions_sid_fk FOREIGN KEY (source_id) REFERENCES na_sources(source_id);


--
-- Name: na_user_preferences_pid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_user_preferences
    ADD CONSTRAINT na_user_preferences_pid_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: na_user_prefs_default_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_user_preferences
    ADD CONSTRAINT na_user_prefs_default_fk FOREIGN KEY (default_aggregator) REFERENCES na_aggregators(aggregator_id);


--
-- Name: na_user_prefs_uid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_user_preferences
    ADD CONSTRAINT na_user_prefs_uid_fk FOREIGN KEY (user_id) REFERENCES users(user_id);


--
-- Name: na_weblogs_pid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_weblogs
    ADD CONSTRAINT na_weblogs_pid_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: na_weblogs_uid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_weblogs
    ADD CONSTRAINT na_weblogs_uid_fk FOREIGN KEY (user_id) REFERENCES users(user_id);


--
-- Name: na_weblogs_weblog_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY na_weblogs
    ADD CONSTRAINT na_weblogs_weblog_id_fk FOREIGN KEY (weblog_id) REFERENCES acs_objects(object_id);


--
-- Name: notif_deliv_meth_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_delivery_methods
    ADD CONSTRAINT notif_deliv_meth_fk FOREIGN KEY (delivery_method_id) REFERENCES acs_objects(object_id);


--
-- Name: notif_deliv_meth_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_delivery_methods
    ADD CONSTRAINT notif_deliv_meth_impl_id_fk FOREIGN KEY (sc_impl_id) REFERENCES acs_sc_impls(impl_id);


--
-- Name: notif_deliv_meth_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_types
    ADD CONSTRAINT notif_deliv_meth_impl_id_fk FOREIGN KEY (sc_impl_id) REFERENCES acs_sc_impls(impl_id);


--
-- Name: notif_email_hold_reply_id_ref; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_email_hold
    ADD CONSTRAINT notif_email_hold_reply_id_ref FOREIGN KEY (reply_id) REFERENCES notification_replies(reply_id);


--
-- Name: notif_interv_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_intervals
    ADD CONSTRAINT notif_interv_id_fk FOREIGN KEY (interval_id) REFERENCES acs_objects(object_id);


--
-- Name: notif_notif_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notifications
    ADD CONSTRAINT notif_notif_id_fk FOREIGN KEY (notification_id) REFERENCES acs_objects(object_id);


--
-- Name: notif_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notifications
    ADD CONSTRAINT notif_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: notif_repl_from_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_replies
    ADD CONSTRAINT notif_repl_from_fk FOREIGN KEY (from_user) REFERENCES users(user_id);


--
-- Name: notif_repl_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_replies
    ADD CONSTRAINT notif_repl_obj_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id);


--
-- Name: notif_repl_repl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_replies
    ADD CONSTRAINT notif_repl_repl_id_fk FOREIGN KEY (reply_id) REFERENCES acs_objects(object_id);


--
-- Name: notif_repl_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_replies
    ADD CONSTRAINT notif_repl_type_id_fk FOREIGN KEY (type_id) REFERENCES notification_types(type_id);


--
-- Name: notif_reponse_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notifications
    ADD CONSTRAINT notif_reponse_id_fk FOREIGN KEY (response_id) REFERENCES acs_objects(object_id);


--
-- Name: notif_request_deliv_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_requests
    ADD CONSTRAINT notif_request_deliv_fk FOREIGN KEY (type_id, delivery_method_id) REFERENCES notification_types_del_methods(type_id, delivery_method_id);


--
-- Name: notif_request_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_requests
    ADD CONSTRAINT notif_request_id_fk FOREIGN KEY (request_id) REFERENCES acs_objects(object_id);


--
-- Name: notif_request_interv_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_requests
    ADD CONSTRAINT notif_request_interv_fk FOREIGN KEY (type_id, interval_id) REFERENCES notification_types_intervals(type_id, interval_id);


--
-- Name: notif_request_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_requests
    ADD CONSTRAINT notif_request_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: notif_request_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_requests
    ADD CONSTRAINT notif_request_type_id_fk FOREIGN KEY (type_id) REFERENCES notification_types(type_id) ON DELETE CASCADE;


--
-- Name: notif_type_del_meth_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_types_del_methods
    ADD CONSTRAINT notif_type_del_meth_id_fk FOREIGN KEY (delivery_method_id) REFERENCES notification_delivery_methods(delivery_method_id) ON DELETE CASCADE;


--
-- Name: notif_type_del_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_types_del_methods
    ADD CONSTRAINT notif_type_del_type_id_fk FOREIGN KEY (type_id) REFERENCES notification_types(type_id) ON DELETE CASCADE;


--
-- Name: notif_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notifications
    ADD CONSTRAINT notif_type_id_fk FOREIGN KEY (type_id) REFERENCES notification_types(type_id);


--
-- Name: notif_type_int_int_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_types_intervals
    ADD CONSTRAINT notif_type_int_int_id_fk FOREIGN KEY (interval_id) REFERENCES notification_intervals(interval_id) ON DELETE CASCADE;


--
-- Name: notif_type_int_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_types_intervals
    ADD CONSTRAINT notif_type_int_type_id_fk FOREIGN KEY (type_id) REFERENCES notification_types(type_id) ON DELETE CASCADE;


--
-- Name: notif_type_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notification_types
    ADD CONSTRAINT notif_type_type_id_fk FOREIGN KEY (type_id) REFERENCES acs_objects(object_id);


--
-- Name: notif_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY notifications
    ADD CONSTRAINT notif_user_id_fk FOREIGN KEY (notif_user) REFERENCES users(user_id);


--
-- Name: pages_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY pages
    ADD CONSTRAINT pages_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: parties_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY parties
    ADD CONSTRAINT parties_party_id_fk FOREIGN KEY (party_id) REFERENCES acs_objects(object_id);


--
-- Name: party_member_member_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY party_approved_member_map
    ADD CONSTRAINT party_member_member_fk FOREIGN KEY (member_id) REFERENCES parties(party_id);


--
-- Name: party_member_party_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY party_approved_member_map
    ADD CONSTRAINT party_member_party_fk FOREIGN KEY (party_id) REFERENCES parties(party_id);


--
-- Name: persons_person_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY persons
    ADD CONSTRAINT persons_person_id_fk FOREIGN KEY (person_id) REFERENCES parties(party_id);


--
-- Name: pinds_blog_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY pinds_blog_categories
    ADD CONSTRAINT pinds_blog_category_id_fk FOREIGN KEY (category_id) REFERENCES acs_objects(object_id);


--
-- Name: pinds_blog_entry_category_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY pinds_blog_entries
    ADD CONSTRAINT pinds_blog_entry_category_fk FOREIGN KEY (category_id) REFERENCES pinds_blog_categories(category_id);


--
-- Name: pinds_blog_entry_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY pinds_blog_entries
    ADD CONSTRAINT pinds_blog_entry_id_fk FOREIGN KEY (entry_id) REFERENCES acs_objects(object_id);


--
-- Name: pinds_blog_entry_package_id_kf; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY pinds_blog_categories
    ADD CONSTRAINT pinds_blog_entry_package_id_kf FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: pinds_blog_entry_package_id_kf; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY pinds_blog_entries
    ADD CONSTRAINT pinds_blog_entry_package_id_kf FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: rc_constraint_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rel_constraints
    ADD CONSTRAINT rc_constraint_id_fk FOREIGN KEY (constraint_id) REFERENCES acs_objects(object_id);


--
-- Name: rc_rel_segment_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rel_constraints
    ADD CONSTRAINT rc_rel_segment_fk FOREIGN KEY (rel_segment) REFERENCES rel_segments(segment_id);


--
-- Name: rc_rel_segment_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rc_segment_required_seg_map
    ADD CONSTRAINT rc_rel_segment_fk FOREIGN KEY (rel_segment) REFERENCES rel_segments(segment_id);


--
-- Name: rc_required_rel_segment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rel_constraints
    ADD CONSTRAINT rc_required_rel_segment FOREIGN KEY (required_rel_segment) REFERENCES rel_segments(segment_id);


--
-- Name: rc_required_rel_segment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rc_segment_required_seg_map
    ADD CONSTRAINT rc_required_rel_segment FOREIGN KEY (required_rel_segment) REFERENCES rel_segments(segment_id);


--
-- Name: recurs_interval_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY recurrences
    ADD CONSTRAINT recurs_interval_type_fk FOREIGN KEY (interval_type) REFERENCES recurrence_interval_types(interval_type);


--
-- Name: rel_segments_group_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rel_segments
    ADD CONSTRAINT rel_segments_group_id_fk FOREIGN KEY (group_id) REFERENCES groups(group_id);


--
-- Name: rel_segments_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rel_segments
    ADD CONSTRAINT rel_segments_rel_type_fk FOREIGN KEY (rel_type) REFERENCES acs_rel_types(rel_type);


--
-- Name: rel_segments_segment_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rel_segments
    ADD CONSTRAINT rel_segments_segment_id_fk FOREIGN KEY (segment_id) REFERENCES parties(party_id);


--
-- Name: rl_resource_category_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rl_resource_category_map
    ADD CONSTRAINT rl_resource_category_fk FOREIGN KEY (category_id) REFERENCES rl_resource_category(category_id);


--
-- Name: rl_resource_category_map_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rl_resource_category_map
    ADD CONSTRAINT rl_resource_category_map_fk FOREIGN KEY (resource_item_id) REFERENCES rl_resources(resource_item_id);


--
-- Name: rl_resource_category_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rl_resource_category
    ADD CONSTRAINT rl_resource_category_type_fk FOREIGN KEY (category_type) REFERENCES rl_resource_category_type(category_id);


--
-- Name: rl_resource_revs_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rl_resources_revisions
    ADD CONSTRAINT rl_resource_revs_id_fk FOREIGN KEY (resource_revision_id) REFERENCES cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: rl_resources_resource_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rl_resources
    ADD CONSTRAINT rl_resources_resource_id_fk FOREIGN KEY (resource_item_id) REFERENCES cr_items(item_id) ON DELETE CASCADE;


--
-- Name: rss_gen_subscrs_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rss_gen_subscrs
    ADD CONSTRAINT rss_gen_subscrs_id_fk FOREIGN KEY (subscr_id) REFERENCES acs_objects(object_id);


--
-- Name: rss_gen_subscrs_impl_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY rss_gen_subscrs
    ADD CONSTRAINT rss_gen_subscrs_impl_fk FOREIGN KEY (impl_id) REFERENCES acs_sc_impls(impl_id);


--
-- Name: services_service_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY apm_services
    ADD CONSTRAINT services_service_id_fk FOREIGN KEY (service_id) REFERENCES apm_packages(package_id);


--
-- Name: sgc_object_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY subsite_callbacks
    ADD CONSTRAINT sgc_object_type_fk FOREIGN KEY (object_type) REFERENCES acs_object_types(object_type) ON DELETE CASCADE;


--
-- Name: site_nodes_node_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY site_nodes
    ADD CONSTRAINT site_nodes_node_id_fk FOREIGN KEY (node_id) REFERENCES acs_objects(object_id);


--
-- Name: site_nodes_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY site_nodes
    ADD CONSTRAINT site_nodes_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id);


--
-- Name: site_nodes_parent_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY site_nodes
    ADD CONSTRAINT site_nodes_parent_id_fk FOREIGN KEY (parent_id) REFERENCES site_nodes(node_id);


--
-- Name: site_nodes_sel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY site_nodes_selection
    ADD CONSTRAINT site_nodes_sel_id_fk FOREIGN KEY (node_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: snom_node_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY site_node_object_mappings
    ADD CONSTRAINT snom_node_id_fk FOREIGN KEY (node_id) REFERENCES site_nodes(node_id);


--
-- Name: snom_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY site_node_object_mappings
    ADD CONSTRAINT snom_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id);


--
-- Name: syndication_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY syndication
    ADD CONSTRAINT syndication_object_id_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: tb_pings_comment_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY trackback_pings
    ADD CONSTRAINT tb_pings_comment_id_fk FOREIGN KEY (comment_id) REFERENCES general_comments(comment_id);


--
-- Name: timezone_rules_tz_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY timezone_rules
    ADD CONSTRAINT timezone_rules_tz_id_fk FOREIGN KEY (tz_id) REFERENCES timezones(tz_id) ON DELETE CASCADE;


--
-- Name: tm_ntrvl_sts_interval_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY timespans
    ADD CONSTRAINT tm_ntrvl_sts_interval_id_fk FOREIGN KEY (interval_id) REFERENCES time_intervals(interval_id) ON DELETE CASCADE;


--
-- Name: trb_language_preference_lid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ad_locale_user_prefs
    ADD CONSTRAINT trb_language_preference_lid_fk FOREIGN KEY (locale) REFERENCES ad_locales(locale) ON DELETE CASCADE;


--
-- Name: ttl_area_assignments_ticket_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_area_assignments
    ADD CONSTRAINT ttl_area_assignments_ticket_fk FOREIGN KEY (area_id) REFERENCES ttl_areas(area_id);


--
-- Name: ttl_area_assignments_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_area_assignments
    ADD CONSTRAINT ttl_area_assignments_user_fk FOREIGN KEY (user_id) REFERENCES users(user_id);


--
-- Name: ttl_areas_object_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_areas
    ADD CONSTRAINT ttl_areas_object_fk FOREIGN KEY (area_id) REFERENCES acs_objects(object_id);


--
-- Name: ttl_assignments_ticket_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_assignments
    ADD CONSTRAINT ttl_assignments_ticket_fk FOREIGN KEY (ticket_id) REFERENCES ttl_tickets(ticket_id);


--
-- Name: ttl_assignments_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_assignments
    ADD CONSTRAINT ttl_assignments_user_fk FOREIGN KEY (user_id) REFERENCES users(user_id);


--
-- Name: ttl_comments_ticket_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_comments
    ADD CONSTRAINT ttl_comments_ticket_fk FOREIGN KEY (ticket_id) REFERENCES ttl_tickets(ticket_id);


--
-- Name: ttl_comments_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_comments
    ADD CONSTRAINT ttl_comments_user_fk FOREIGN KEY (creation_user) REFERENCES users(user_id);


--
-- Name: ttl_pref_area_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_prefs
    ADD CONSTRAINT ttl_pref_area_fk FOREIGN KEY (area_id) REFERENCES ttl_areas(area_id);


--
-- Name: ttl_prefs_user_ref; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_prefs
    ADD CONSTRAINT ttl_prefs_user_ref FOREIGN KEY (user_id) REFERENCES users(user_id);


--
-- Name: ttl_tickets_area_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_tickets
    ADD CONSTRAINT ttl_tickets_area_fk FOREIGN KEY (area_id) REFERENCES ttl_areas(area_id);


--
-- Name: ttl_tickets_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_tickets
    ADD CONSTRAINT ttl_tickets_fk FOREIGN KEY (ticket_id) REFERENCES acs_objects(object_id);


--
-- Name: ttl_tickets_status_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ttl_tickets
    ADD CONSTRAINT ttl_tickets_status_fk FOREIGN KEY (status) REFERENCES ttl_status(status);


--
-- Name: user_portraits_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY user_portraits
    ADD CONSTRAINT user_portraits_user_id_fk FOREIGN KEY (user_id) REFERENCES users(user_id);


--
-- Name: users_auth_authorities_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_auth_authorities_fk FOREIGN KEY (authority_id) REFERENCES auth_authorities(authority_id);


--
-- Name: users_email_image_email_image_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY users_email_image
    ADD CONSTRAINT users_email_image_email_image_id_fkey FOREIGN KEY (email_image_id) REFERENCES cr_revisions(revision_id);


--
-- Name: users_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_user_id_fk FOREIGN KEY (user_id) REFERENCES persons(person_id);


--
-- Name: weblogger_blogroll_entries_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY weblogger_blogroll_entries
    ADD CONSTRAINT weblogger_blogroll_entries_id_fk FOREIGN KEY (link_id) REFERENCES acs_objects(object_id);


--
-- Name: weblogger_blogroll_entries_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY weblogger_blogroll_entries
    ADD CONSTRAINT weblogger_blogroll_entries_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: weblogger_channels_package_id_kf; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY weblogger_channels
    ADD CONSTRAINT weblogger_channels_package_id_kf FOREIGN KEY (package_id) REFERENCES apm_packages(package_id);


--
-- Name: weblogger_ping_urls_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY weblogger_ping_urls
    ADD CONSTRAINT weblogger_ping_urls_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: weblogger_ping_urls_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY weblogger_technorati_cache
    ADD CONSTRAINT weblogger_ping_urls_package_id_fk FOREIGN KEY (package_id) REFERENCES apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: wf_arc_place_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_arcs
    ADD CONSTRAINT wf_arc_place_fk FOREIGN KEY (workflow_key, place_key) REFERENCES wf_places(workflow_key, place_key) ON DELETE CASCADE;


--
-- Name: wf_arc_transition_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_arcs
    ADD CONSTRAINT wf_arc_transition_fk FOREIGN KEY (workflow_key, transition_key) REFERENCES wf_transitions(workflow_key, transition_key) ON DELETE CASCADE;


--
-- Name: wf_article_cases_case_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_article_cases
    ADD CONSTRAINT wf_article_cases_case_fk FOREIGN KEY (case_id) REFERENCES wf_cases(case_id) ON DELETE CASCADE;


--
-- Name: wf_attr_val_audit_attr_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_attribute_value_audit
    ADD CONSTRAINT wf_attr_val_audit_attr_fk FOREIGN KEY (attribute_id) REFERENCES acs_attributes(attribute_id) ON DELETE CASCADE;


--
-- Name: wf_attr_val_audit_case_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_attribute_value_audit
    ADD CONSTRAINT wf_attr_val_audit_case_fk FOREIGN KEY (case_id) REFERENCES wf_cases(case_id) ON DELETE CASCADE;


--
-- Name: wf_attr_val_audit_journal_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_attribute_value_audit
    ADD CONSTRAINT wf_attr_val_audit_journal_fk FOREIGN KEY (journal_id) REFERENCES journal_entries(journal_id);


--
-- Name: wf_case_assign_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_case_assignments
    ADD CONSTRAINT wf_case_assign_fk FOREIGN KEY (case_id) REFERENCES wf_cases(case_id) ON DELETE CASCADE;


--
-- Name: wf_case_assign_party_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_case_assignments
    ADD CONSTRAINT wf_case_assign_party_fk FOREIGN KEY (party_id) REFERENCES parties(party_id) ON DELETE CASCADE;


--
-- Name: wf_case_assign_role_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_case_assignments
    ADD CONSTRAINT wf_case_assign_role_fk FOREIGN KEY (workflow_key, role_key) REFERENCES wf_roles(workflow_key, role_key) ON DELETE CASCADE;


--
-- Name: wf_case_deadline_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_case_deadlines
    ADD CONSTRAINT wf_case_deadline_fk FOREIGN KEY (case_id) REFERENCES wf_cases(case_id) ON DELETE CASCADE;


--
-- Name: wf_case_deadline_trans_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_case_deadlines
    ADD CONSTRAINT wf_case_deadline_trans_fk FOREIGN KEY (workflow_key, transition_key) REFERENCES wf_transitions(workflow_key, transition_key) ON DELETE CASCADE;


--
-- Name: wf_cases_acs_object_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_cases
    ADD CONSTRAINT wf_cases_acs_object_fk FOREIGN KEY (case_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: wf_cases_context_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_cases
    ADD CONSTRAINT wf_cases_context_fk FOREIGN KEY (context_key) REFERENCES wf_contexts(context_key) ON DELETE CASCADE;


--
-- Name: wf_cases_object_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_cases
    ADD CONSTRAINT wf_cases_object_fk FOREIGN KEY (object_id) REFERENCES acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: wf_cases_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_cases
    ADD CONSTRAINT wf_cases_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_context_assign_context_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_assignments
    ADD CONSTRAINT wf_context_assign_context_fk FOREIGN KEY (context_key) REFERENCES wf_contexts(context_key) ON DELETE CASCADE;


--
-- Name: wf_context_assign_party_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_assignments
    ADD CONSTRAINT wf_context_assign_party_fk FOREIGN KEY (party_id) REFERENCES parties(party_id) ON DELETE CASCADE;


--
-- Name: wf_context_assign_role_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_assignments
    ADD CONSTRAINT wf_context_assign_role_fk FOREIGN KEY (workflow_key, role_key) REFERENCES wf_roles(workflow_key, role_key) ON DELETE CASCADE;


--
-- Name: wf_context_assign_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_assignments
    ADD CONSTRAINT wf_context_assign_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_context_panels_context_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_task_panels
    ADD CONSTRAINT wf_context_panels_context_fk FOREIGN KEY (context_key) REFERENCES wf_contexts(context_key) ON DELETE CASCADE;


--
-- Name: wf_context_panels_trans_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_task_panels
    ADD CONSTRAINT wf_context_panels_trans_fk FOREIGN KEY (workflow_key, transition_key) REFERENCES wf_transitions(workflow_key, transition_key) ON DELETE CASCADE;


--
-- Name: wf_context_panels_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_task_panels
    ADD CONSTRAINT wf_context_panels_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_context_role_context_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_role_info
    ADD CONSTRAINT wf_context_role_context_fk FOREIGN KEY (context_key) REFERENCES wf_contexts(context_key) ON DELETE CASCADE;


--
-- Name: wf_context_role_role_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_role_info
    ADD CONSTRAINT wf_context_role_role_fk FOREIGN KEY (workflow_key, role_key) REFERENCES wf_roles(workflow_key, role_key) ON DELETE CASCADE;


--
-- Name: wf_context_role_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_role_info
    ADD CONSTRAINT wf_context_role_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_context_trans_context_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_transition_info
    ADD CONSTRAINT wf_context_trans_context_fk FOREIGN KEY (context_key) REFERENCES wf_contexts(context_key);


--
-- Name: wf_context_trans_trans_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_transition_info
    ADD CONSTRAINT wf_context_trans_trans_fk FOREIGN KEY (workflow_key, transition_key) REFERENCES wf_transitions(workflow_key, transition_key) ON DELETE CASCADE;


--
-- Name: wf_context_trans_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_transition_info
    ADD CONSTRAINT wf_context_trans_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key);


--
-- Name: wf_context_wf_context_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_workflow_info
    ADD CONSTRAINT wf_context_wf_context_fk FOREIGN KEY (context_key) REFERENCES wf_contexts(context_key) ON DELETE CASCADE;


--
-- Name: wf_context_wf_principal_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_workflow_info
    ADD CONSTRAINT wf_context_wf_principal_fk FOREIGN KEY (principal_party) REFERENCES parties(party_id) ON DELETE SET NULL;


--
-- Name: wf_context_wf_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_context_workflow_info
    ADD CONSTRAINT wf_context_wf_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_place_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_places
    ADD CONSTRAINT wf_place_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_role_asgn_map_trans_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_transition_role_assign_map
    ADD CONSTRAINT wf_role_asgn_map_trans_fk FOREIGN KEY (workflow_key, transition_key) REFERENCES wf_transitions(workflow_key, transition_key) ON DELETE CASCADE;


--
-- Name: wf_role_asgn_map_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_transition_role_assign_map
    ADD CONSTRAINT wf_role_asgn_map_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_roles_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_roles
    ADD CONSTRAINT wf_roles_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_task_assign_task_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_task_assignments
    ADD CONSTRAINT wf_task_assign_task_fk FOREIGN KEY (task_id) REFERENCES wf_tasks(task_id) ON DELETE CASCADE;


--
-- Name: wf_task_case_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tasks
    ADD CONSTRAINT wf_task_case_fk FOREIGN KEY (case_id) REFERENCES wf_cases(case_id) ON DELETE CASCADE;


--
-- Name: wf_task_holding_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tasks
    ADD CONSTRAINT wf_task_holding_user_fk FOREIGN KEY (holding_user) REFERENCES users(user_id) ON DELETE CASCADE;


--
-- Name: wf_task_party_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_task_assignments
    ADD CONSTRAINT wf_task_party_fk FOREIGN KEY (party_id) REFERENCES parties(party_id) ON DELETE CASCADE;


--
-- Name: wf_task_transition_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tasks
    ADD CONSTRAINT wf_task_transition_fk FOREIGN KEY (workflow_key, transition_key) REFERENCES wf_transitions(workflow_key, transition_key);


--
-- Name: wf_task_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tasks
    ADD CONSTRAINT wf_task_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key);


--
-- Name: wf_token_canceled_journal_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tokens
    ADD CONSTRAINT wf_token_canceled_journal_fk FOREIGN KEY (canceled_journal_id) REFERENCES journal_entries(journal_id);


--
-- Name: wf_token_consumed_journal_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tokens
    ADD CONSTRAINT wf_token_consumed_journal_fk FOREIGN KEY (consumed_journal_id) REFERENCES journal_entries(journal_id);


--
-- Name: wf_token_locked_journal_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tokens
    ADD CONSTRAINT wf_token_locked_journal_fk FOREIGN KEY (locked_journal_id) REFERENCES journal_entries(journal_id);


--
-- Name: wf_token_place_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tokens
    ADD CONSTRAINT wf_token_place_fk FOREIGN KEY (workflow_key, place_key) REFERENCES wf_places(workflow_key, place_key);


--
-- Name: wf_token_produced_journal_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tokens
    ADD CONSTRAINT wf_token_produced_journal_fk FOREIGN KEY (produced_journal_id) REFERENCES journal_entries(journal_id);


--
-- Name: wf_token_task_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tokens
    ADD CONSTRAINT wf_token_task_fk FOREIGN KEY (locked_task_id) REFERENCES wf_tasks(task_id);


--
-- Name: wf_token_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tokens
    ADD CONSTRAINT wf_token_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key);


--
-- Name: wf_token_workflow_instance_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_tokens
    ADD CONSTRAINT wf_token_workflow_instance_fk FOREIGN KEY (case_id) REFERENCES wf_cases(case_id) ON DELETE CASCADE;


--
-- Name: wf_tr_role_asgn_map_asgn_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_transition_role_assign_map
    ADD CONSTRAINT wf_tr_role_asgn_map_asgn_fk FOREIGN KEY (workflow_key, assign_role_key) REFERENCES wf_roles(workflow_key, role_key) ON DELETE CASCADE;


--
-- Name: wf_trans_attr_map_attribute_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_transition_attribute_map
    ADD CONSTRAINT wf_trans_attr_map_attribute_fk FOREIGN KEY (attribute_id) REFERENCES acs_attributes(attribute_id);


--
-- Name: wf_trans_attr_map_trans_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_transition_attribute_map
    ADD CONSTRAINT wf_trans_attr_map_trans_fk FOREIGN KEY (workflow_key, transition_key) REFERENCES wf_transitions(workflow_key, transition_key) ON DELETE CASCADE;


--
-- Name: wf_trans_attr_map_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_transition_attribute_map
    ADD CONSTRAINT wf_trans_attr_map_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_transition_role_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_transitions
    ADD CONSTRAINT wf_transition_role_fk FOREIGN KEY (workflow_key, role_key) REFERENCES wf_roles(workflow_key, role_key);


--
-- Name: wf_transition_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_transitions
    ADD CONSTRAINT wf_transition_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_ts_arc_workflow_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_arcs
    ADD CONSTRAINT wf_ts_arc_workflow_fk FOREIGN KEY (workflow_key) REFERENCES wf_workflows(workflow_key) ON DELETE CASCADE;


--
-- Name: wf_workflows_workflow_key_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wf_workflows
    ADD CONSTRAINT wf_workflows_workflow_key_fk FOREIGN KEY (workflow_key) REFERENCES acs_object_types(object_type) ON DELETE CASCADE;


--
-- PostgreSQL database dump complete
--

